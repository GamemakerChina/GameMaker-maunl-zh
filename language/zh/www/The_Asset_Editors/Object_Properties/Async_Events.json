{
    "An Asynchronous Event is one that is fired off when {}GameMaker{} receives a {}callback{}&nbsp;from some external source, which can be from the web or from the device running your game. Basically, you tell {}GameMaker{} to do something -&nbsp;like load an image -&nbsp;and it\u0027ll start to do this but continue doing whatever it else it has to do meanwhile its working. Then, when the request has been completed, a callback will be sent to GameMaker Studio 2 and any Asynchronous Events defined for that type of callback will be fired.":"异步事件是当 {}GameMaker{} 从某些外部来源 (可以来自 Web 或运行游戏的设备) 接收到 {} 回调 {} 时触发的事件。基本上，你告诉 {}GameMaker{} 做一些事情 —— 比如加载图像 —— 它会开始这样做，但在工作的同时继续做它必须做的任何事情。然后，当请求完成时，将向 GameMaker 发送回调Studio 2 和为该类型回调定义的任何异步事件都将被触发。",
    "An Asynchronous Event is one that is fired when {}GameMaker{} receives a {}callback{}&nbsp;from some external source, which can be from the web or from the device running your game.":"异步事件是指当{}GameMaker{}从外部源(可以是Web或运行游戏的设备)接收到{}回调{}时触发的事件。",
    "Async Image Loaded Event":"异步图像加载事件",
    "Audio Playback":"音频回放",
    "Audio Playback Ended":"音频播放结束",
    "Audio Recording":"音频录制",
    "Basically, you tell {}GameMaker{} to do something -&nbsp;like load an image -&nbsp;and it will start to do this. As an example, let\u0027s say you want to add a sprite from an external file. This can be done {}synchronously{} or&nbsp;{}asynchronously{}. To do this synchronously, you use the function&nbsp;{}{}sprite_add{}{}:&nbsp;":"基本上，你告诉{}GameMaker{}做一些事情-比如加载一个图像-它会开始这样做。作为一个例子，让我们假设你想从一个外部文件添加一个精灵。这可以{}同步{}或{}异步{}完成。要同步完成这一点，你使用函数{}{}sprite_add{}{}：",
    "Cloud":"云",
    "Dialog":"对话框",
    "Image Loaded":"图像加载",
    "In App Purchase":"在应用程序购买",
    "In the example of&nbsp;{}{}sprite_add{}{}, you can use its asynchronous counterpart&nbsp;{}{}sprite_add_ext{}{}&nbsp;to just&nbsp;{}start{} loading the sprite and trigger an async event afterwards:&nbsp;":"在{}{}sprite_add{}{}的示例中，您可以使用其异步对应项{}{}sprite_add_ext{}{}来{}开始{}加载sprite，然后触发一个sprite事件：",
    "It may be that if you are making extensions for different platforms you would like to target one or more of these asynchronous events for callbacks from your extension functions. To that end, you can find a table below that outlines each of the internal event name constants and their corresponding ID value.":"如果你正在为不同的平台做扩展，你可能希望从你的扩展函数中回调一个或多个异步事件。为此，你可以找到下面的表格，列出每个内部事件名称常量和它们对应的ID值。",
    "It may be that if you are making extensions for different platforms you would like to target one or more of these asynchronous events for callbacks from your extension functions. To that end, you can find a table below that outlines each of the internal event name constants and their corresponding ID value. Note that these event constants are {}only{} for use with extensions!":"如果您正在为不同的平台进行扩展，您可能希望将这些异步事件中的一个或多个定位为扩展函数的回调。为此，您可以在下面找到一个表格，概述了每个内部事件名称常量及其对应的ID值。请注意，这些事件常量{}仅{}用于扩展！",
    "Networking":"联网",
    "Please note that the Asynchronous Events are fired for {}all {}instances that have them, much like the keyboard events, so you can - for example - do an {}http_get(){} call&nbsp;in one instance, yet have the {}Asynchronous HTTP Event{} in another to deal with the callback.":"请注意，异步事件是为 {} 所有 {} 具有它们的实例触发的，就像键盘事件一样，因此您可以在一个实例中执行 {}http_get(){} 调用，但在另一个实例中使用 {} 异步 HTTP 事件 {} 来处理回调。",
    "Please note that the Asynchronous Events are fired for {}all {}instances that have them, much like the keyboard events, so you can - for example - do an&nbsp;{}{}http_get{}{} call&nbsp;in one instance, yet have the {}Asynchronous HTTP Event{} in another to deal with the callback.":"请注意，异步事件会为 {} 所有 {} 具有它们的实例触发，这与键盘事件非常相似，因此您可以在一个实例中执行 {}{}http_get{}{} 调用，但在另一个实例中使用 {} 异步 HTTP 事件 {} 来处理回调。",
    "Push Notifications":"推送通知",
    "Save / Load":"保存/加载",
    "Social":"社交",
    "System":"系统",
    "The Async Events":"异步事件",
    "The&nbsp;{}Async Events{}":"{}异步事件{}",
    "There are various types of events associated with the Asynchronous event category, and they are all explained in the sections below:":"有多种类型的事件与异步事件类别相关联，它们都在以下部分中进行了解释：",
    "There are&nbsp;other situations in which you don\u0027t want the game to wait until something that might take an amount of time to complete has finished, such as making HTTP requests to a web server.":"还有其他一些情况，您不希望游戏等待可能需要大量时间才能完成的事情完成，例如向Web服务器发出HTTP请求。",
    "This function has a bit&nbsp;of a disadvantage, however, as it&nbsp;{}fully l{}oads the sprite immediately{}{}. The next line&nbsp;of code will&nbsp;only be executed after that\u0027s finished!&nbsp;This may barely be noticeable if you\u0027re just adding a single small sprite, but might freeze your game when loading&nbsp;one big sprite&nbsp;or many small&nbsp;ones.":"但是这个函数有一个缺点，因为它会立即{}完全加载精灵{}{}。下一行代码只有在加载完成后才会执行！如果你只是添加一个小精灵，这可能不会被注意到，但是当加载一个大精灵或许多小精灵时，可能会冻结你的游戏。",
    "You don\u0027t always have to call a function yourself first in&nbsp;order to receive a callback in the form&nbsp;of an async event, for example the async&nbsp;{}System{}&nbsp;event will be triggered when a gamepad is connected&nbsp;or disconnected. For this you don\u0027t have to call a function first.":"您不必总是先自己调用函数才能接收异步事件形式的回调，例如，当游戏手柄连接或断开连接时，将触发异步 {}System{} 事件。 为此，您不必先调用函数。",
    "{}/// \"The sprite you requested has finished loading\"{}":"{}///\"您请求的精灵已完成加载\"{}",
    "{}GameMaker{} also has built-in functions that work {}asynchronously{} instead. Using these functions {}GameMaker{}&nbsp;only&nbsp;{}starts{} doing what you asked, but doesn\u0027t stop executing code until this has finished. It continues to process your async request \"in the background\" and continues to run the rest of your game\u0027s code normally. When the request completes, a callback will be sent to {}GameMaker{}&nbsp;and any Asynchronous Events defined for that type of callback will be fired.":"{}GameMaker{} 也有 {} 异步 {} 工作的内置函数。使用这些函数，{}GameMaker{} 只会 {} 开始 {} 执行您要求的操作，但不会停止执行代码，直到完成。它会继续在后台处理您的 GameMaker 请求，并继续正常运行游戏的其余代码。当请求完成时，一个回调将被发送到 {}GameMaker{}，并且为该类型的回调定义的任何异步事件将被触发。",
    "{}NOTE{}: The variable {}{}{}async_load{}{}{}&nbsp; which is mentioned in the following sections is {}only valid in these events{}, as the DS map that it&nbsp;points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of -1 at all other times.":"{} 注意 {}：变量 {}{}{}async_load{}{}{}在以下部分中，{} 仅在这些事件 {} 中有效，因为它指向的 DS 映射是在事件开始时创建的，然后在结束时再次删除，此变量在所有其他时间都被重置为 -1 值。",
    "{}NOTE{}: You should be aware that due to XSS protection in browsers, requests and attempts to load resources from across domains are blocked and may appear to return blank results when using any of the following events.":"{}注意{}：您应该知道，由于浏览器中的XSS保护，从跨域加载资源的请求和尝试会被阻止，并且在使用以下任何事件时可能会返回空白结果。",
    "{}var{} _new_big_sprite = {}sprite_add_ext{}({}\"my_new_sprite_image.png\"{}, {}1{}, {}0{}, {}0{}, {}true{});{} {} {}// A lot more code below this line that will be executed almost instantly after the call to sprite_add_ext {}":"{}var{} _new_big_sprite = {}sprite_add_ext{}({}\"my_new_sprite_image.png\"{}, {}1{}, {}0{}, {}0{}, {}true{});{} {} {}// 在这一行下面有更多的代码，在调用sprite_add_ext之后几乎立即执行{}",
    "{}var{} _new_big_sprite = {}sprite_add{}({}\"my_new_sprite_image.png\"{}, {}1{}, {}false{}, {}true{}, {}0{}, {}0{});{} {} {}// A lot more code below this line that all needs to be executed&nbsp;on time to keep a steady FPS {}":"{}var{} _new_big_sprite = {}sprite_add{}({}\"my_new_sprite_image.png\"{}, {}1{}, {}false{}, {}true{}, {}0{}, {}0{});{} {} {}// 在这一行下面有很多代码，所有代码都需要按时执行，以保持稳定的FPS{}",
    "{}{}NOTE{}{}&nbsp;The variable&nbsp;{}{}async_load{}{} which is mentioned in the following sections is {}only valid in these events{}, as the {}DS map{} that it&nbsp;points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of {}-1{} at all other times.":"{}{}注意{}{}以下部分中提到的变量 {}{}async_load{}{} {}仅在这些事件中有效{}，因为它指向的 {}DS map{} 在事件开始时创建，然后在结束时再次删除，并且该变量在所有其他时间都会重置为值 {}-1{}。",
    "{}{}NOTE{}{}&nbsp;These event constants are {}only{} for use with extensions!":"{}{}注意{}{}这些事件常量{}仅{}用于扩展！",
    "{}{}NOTE{}{}&nbsp;You should be aware that due to XSS protection in browsers, requests and attempts to load resources from across domains are blocked and may appear to return blank results when using any of the following events.":"{}{}注意{}{}您应该注意，由于浏览器中的XSS保护，从跨域加载资源的请求和尝试会被阻止，并且在使用以下任何事件时可能会返回空白结果。"
}