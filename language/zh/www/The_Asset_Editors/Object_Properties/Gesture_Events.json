{
    "Events in the Gesture Event category will be triggered whenever {}GameMaker{} detects a \"gesture\" of the mouse or a touch screen event (while these gesture events are designed specifically for mobile use, they can also be used on other targets to detect the mouse, although they will not detect multiple touches in this case). The goal of the gesture system is to try and recognise inputs at a higher level than the direct mouse\\touch reading functions, and is designed to simplify the implementation of commonly used inputs on touch-based devices.":"手势事件类别中的事件将在{}GameMaker{}检测到鼠标或触摸屏事件时触发(虽然这些手势事件是专门为移动使用设计的，但它们也可以用于其他目标来检测鼠标，尽管在这种情况下它们不会检测多个触摸)。手势系统的目标是尝试并识别比直接鼠标/触摸阅读功能更高级别的输入，旨在简化基于触摸的设备上常用输入的实现。",
    "If both touches are moving, their velocities must be in approximately opposite directions and the same angular threshold check is also done to ensure the touches are moving in approximate alignment.":"如果两个触点都在移动，则它们的速度必须大致相反，并执行相同的角度阈值检查，以确保两个触点以大致对齐的方式移动。",
    "If one of the touches isn\u0027t moving, the other must be moving towards it or away from it within a threshold angle (which can be set using the functions {}{}gesture_pinch_angle_towards(){}{}&nbsp;and - {}{}gesture_pinch_angle_away(){}{}).":"如果其中一个触摸没有移动，则另一个触摸必须在阈值角度内朝向它或远离它 (可以使用函数 {}{}gesture_pinch_angle_towards(){}{} 和 {}{}gesture_pinch_angle_away(){}{}) 进行设置。",
    "It is worth noting that if you have multiple instances under the position being touched and they all have a gesture event, then {}all {}of them will trigger, not just the \"topmost\" instance. Also note that when using multiple camera views and dragging an instance, the values returned will be based on the view you were in when the initial touch/click was received - this is true for all subsequent events in that gesture for that instance. So touching and dragging an instance in one view then releasing the touch in another view, will return values relative to the initial view where the gesture was first detected.":"值得注意的是，如果您在被触摸的位置下有多个实例，并且它们都有一个手势事件，那么它们{}都{}会被触发，而不仅仅是最上面的实例。另请注意，当使用多个摄像头视图并拖动实例时，返回的值将基于接收到初始触摸/单击时所在的视图-对于该实例该手势中的所有后续事件都是如此。因此，在一个视图中触摸和拖动实例，然后在另一个视图中释放触摸，将返回相对于首次检测到手势的初始视图的值。",
    "The \"Pinch\" events are based on two touches to the devices screen being recognised at once, where one (or both) have moved more than a certain distance. The angle of movement of the touches along with the movement of each touch is what will determine the detection of a Pinch or Rotate event, where (in the case of the Pinch Event type):":"\"捏\"事件是基于一次对设备屏幕的两次触摸被识别的，其中一次(或两次)移动超过了一定距离。触摸的移动角度以及每次触摸的移动将确定捏或旋转事件的检测，其中(在捏事件类型的情况下)：",
    "The \"Rotate\" events are based on two touches to the devices screen being recognised at once, and where there has been a consistent angular rotation between the two within a specific time. The angle of movement of the touches along with the movement of each touch is what will determine the detection of a Pinch or Rotate event, where (in the case of the Rotate Event type):":"\"旋转\"事件是基于对设备屏幕的两次触摸被一次识别，并且在特定时间内两者之间存在一致的角度旋转。触摸的移动角度以及每次触摸的移动将确定是否检测到挤压或旋转事件，其中(在旋转事件类型的情况下)：",
    "The \"Tap\", \"Drag\" and \"Flick\" events are all based on a single touch or mouse click on the screen and the {}event_data{} DS Map will contain the following keys:":"点击、拖动和点击事件均基于屏幕上的一次触摸或鼠标点击，并且{}event_data{} DS 映射将包含以下键：",
    "The Double Tap event will be triggered when an instance has been touched or clicked twice in quick succession (or - if it is a global event - when the game registers two quick touches or clicks anywhere in the room). A double tap is considered two quick touches and releases, but if any of the touches lasts too long then it will be considered a Drag (and trigger the Drag gesture events instead of the Double Tap event). This event will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"当一个实例被快速连续触摸或点击两次时 (或者-如果它是一个全局事件-当游戏记录了两次快速触摸或在房间中的任何地方点击时)，将触发双击事件。双击被认为是两次快速触摸和释放，但如果任何一次触摸持续时间太长，则将被视为拖动 (并触发拖动手势事件，而不是双击事件)。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Drag End event is triggered when the user releases the touch/click on the instance (or the screen if the event is global). This event will generate an {}event_data{} DS map which you can then use to get information about the event, but in this event the map will have an extra key: \"{}isflick{}\". Flick is calculated as the distance per second that the drag has occurred over, and the value for the \"{}isflick{}\" key will be true if it is greater than the defined distance per second value, or false otherwise. Note that the default is 2 inches per second, but you can set it to another value using the function {}{}gesture_flick_speed(){}{}. Also note that there is a dedicated Flick event which will also be triggered if the \"isflick\" variable is true. An example of use would be:":"当用户在实例 (如果事件是全局事件，则是屏幕) 上释放触摸 / 单击时，将触发拖动结束事件。此事件将生成一个 {}event_data{}DS 映射，然后您可以使用该映射来获取有关该事件的信息，但在此事件中，该映射将有一个额外的密钥：\"{}isflick{}\"。轻拍按发生拖动的每秒距离计算，如果大于定义的每秒距离值，\"{}isflick{}\" 键的值将为 True，否则为 False。请注意，缺省值为每秒 2 英寸，但您可以使用函数 {}{}gesture_flick_speed(){}{} 将其设置为另一个值。还要注意，如果 \"isflick\" 变量为真，则也会触发专用的轻击事件。使用的一个示例是：",
    "The Drag Start event will be triggered when the user maintains a touch or click without releasing it. It will be triggered once when a set time has passed after the initial touch, which is 0.16 seconds by default (although you can set this to any other value in seconds using the function {}{}gesture_drag_time(){}{}). After this event has been triggered, and as long as the user has a touch/click held down, then the Dragging event will be triggered every step until the touch/click has been released. This event will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"当用户保持触摸或单击而不松开它时，将触发拖动开始事件。它会在初始触摸后经过设置的时间时触发一次，默认为 0.16 秒 (尽管您可以使用函数 {}{}gesture_drag_time(){}{} 将其设置为以秒为单位的任何其他值)。在此事件被触发后，只要用户按住触摸 / 点击，则每一步都会触发拖动事件，直到触摸 / 点击被释放。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Dragging event is triggered after the Drag Start event, and will be triggered for every step that the user maintains the touch/click on the instance (or the screen, if it\u0027s a global event) and moves more than the defined dragging threshold. This distance is 0.1 inches by default but can be set using the function {}{}gesture_drag_distance(){}{}. If there is no movement or the movement is under the defined threshold, the event will not be triggered. This event will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"拖拽事件是在拖拽开始事件之后触发的，用户在实例 (或屏幕，如果是全局事件) 上保持触摸 / 点击并移动超过定义的拖拽阈值的每一步都会触发拖拽事件。默认情况下，此距离为 0.1 英寸，但可以使用函数 {}{}gesture_drag_distance(){}{} 设置。如果没有移动或移动低于定义的阈值，则不会触发该事件。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Flick event is only triggered when a touch/click has been held, dragged and then released and the distance between the last drag position and the release position is greater than 2 inches per second (this is the default setting, although this can be changed using the function {}{}gesture_flick_speed(){}{}). This event will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"仅当按住、拖动并释放触摸 / 点击，并且最后一次拖动位置与释放位置之间的距离大于每秒 2 英寸时，才会触发 Flick 事件 (这是默认设置，但可以使用函数 {}{}gesture_flick_speed(){}{} 进行更改)。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Gesture Events":"手势事件",
    "The Pinch End event will be triggered when the user releases one (or both) of the touches from the device. This events will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"当用户从设备释放一个 (或两个) 触摸时，将触发捏结束事件。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Pinch In and Pinch Out events will be triggered every step that the distance between the two touches that make up the pinch changes over the minimum threshold (set to +/- 0.1 inches by default, but you can change it using the function gesture_pinch_distance). If there is no movement of the pinch touches then these events will not trigger. These events will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"构成收缩的两个触摸之间的距离超过最小阈值 (默认情况下设置为 +/-0.1 英寸，但您可以使用函数 gesture_pinch_distance 更改) 的每一步都将触发收缩和收缩事件。如果按压触摸没有移动，则不会触发这些事件。这些事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The Pinch Start event will be triggered when an instance (or the screen if the event is global) has been touched by two \"fingers\" (and the touch is maintained) and then one or both of the \"fingers\" is moved. If the touches move away from each other or towards each other more than the minimum check distance (which is 0.1 inches by default, but it can be set using the function {}{}gesture_pinch_distance(){}{}), and the angle between them is within the defined value (this defaults to 45° but can be set using {}{}gesture_pinch_angle_towards(){}{}&nbsp;and {}{}gesture_pinch_angle_away(){}{}), then a Pinch Start event will be triggered. In this event you can set variables or store position date for future use. For example: ":"当实例 (如果事件是全局的，则是屏幕) 被两个 \" 手指 \" 触摸 (并且保持触摸)，然后移动一个或两个 \" 手指 \" 时，将触发捏开始事件。如果触点彼此远离或朝向彼此移动的距离超过最小检查距离 (默认为 0.1 英寸，但可以使用函数 {}{}gesture_pinch_distance(){}{}) 进行设置，并且它们之间的角度在定义的值内 (此默认为 45°，但可以使用 {}{}gesture_pinch_angle_towards(){}{} 和 {}{}gesture_pinch_angle_away(){}{} 设置)，则将触发收缩开始事件。在这种情况下，您可以设置变量或存储职位日期以备将来使用。例如：",
    "The Rotate End event will be triggered when one (or both) touches that comprise the gesture are released from the device screen. This event can be used to set variables and manipulate instances, for example:":"当构成手势的一个(或两个)触摸从设备屏幕上释放时，将触发旋转结束事件。此事件可用于设置变量和操作实例，例如：",
    "The Rotate Start event will be triggered when an instance (or the screen if the event is global) has been touched by two \"fingers\" (and the touch is maintained) and then one or both of the \"fingers\" is rotated from its start position. The rotation of the touches needs to have started within a short period of time (0.16 seconds by default, but it can be set using the function {}{}gesture_rotate_time(){}{}) and be greater than the minimum angular threshold (by default 5°, but, this can be changed using the function {}{}gesture_rotate_angle(){}{}). If these checks are true, then a Rotate Start event will be triggered and you can use it to store values or set variables for use with the rest of the rotate events. For example:":"当实例 (如果事件是全局的，则是屏幕) 被两个“手指”触摸 (并且保持触摸)，然后一个或两个“手指”从其开始位置旋转时，将触发旋转开始事件。触摸的旋转需要在短时间内开始 (默认为 0.16 秒，但可以使用函数 {}{}gesture_rotate_time(){}{}) 进行设置，并且大于最小角度阈值 (默认为 5°，但可以使用函数 {}{}gesture_rotate_angle(){}{} 进行更改)。如果这些检查为真，则将触发旋转开始事件，您可以使用它来存储值或设置变量，以便与其余旋转事件一起使用。例如：",
    "The Rotating event will be triggered every step that the touches on the screen rotate around each other, as long as the movement is greater than the minimum angular threshold (by default 5°, but, this can be changed using the function {}{}gesture_rotate_angle(){}{}). This event can be used to set variables and manipulate instances, for example:":"只要移动大于最小角度阈值 (默认为 5°，但可以使用函数 {}{}gesture_rotate_angle(){}{})，屏幕上的触点围绕彼此旋转的每一步都会触发正在旋转事件。此事件可用于设置变量和操作实例，例如：",
    "The Tap event will be triggered when an instance has been touched or clicked or - if it is a global event - when the game registers a touch or click anywhere in the room. A tap is considered a quick touch and release, and if the touch lasts too long then it will be considered a Drag (and trigger the Drag gesture events instead of the Tap event). This event will generate an {}event_data{} DS map which you can then use to get information about the event. For example:":"Tap 事件将在实例被触摸或点击时触发，或者-如果它是全局事件-当游戏记录到房间中的任何位置被触摸或点击时。轻触被认为是快速触摸和释放，如果触摸持续太长时间，则将被视为拖动 (并触发拖动手势事件，而不是轻击事件)。此事件将生成一个 {}event_data{} DS 映射，然后您可以使用该映射获取有关该事件的信息。例如：",
    "The above code rotates the camera view depending on the rotational movement of the touches in the event.":"上面的代码根据事件中触摸的旋转移动来旋转相机视图。",
    "The above code simply detects a double tap and then destroys the instance. Note that you can set the time between taps to trigger a double tap using the function {}{}gesture_double_tap_time(){}{}&nbsp;(which has a default value - in seconds - of 0.16) and you can also set the distance for detection between taps with the function {}{}gesture_double_tap_distance(){}{}&nbsp;(if a second tap is detected outside of this distance it will be considered a regular tap event).":"上面的代码只是检测到双击，然后销毁实例。请注意，您可以使用函数 {}{}gesture_double_tap_time(){}{} (默认值为秒) 设置两次轻击之间的时间间隔，也可以使用函数 {}{}gesture_double_tap_distance(){}{} (如果设置两次轻击之间的检测距离。",
    "The above code simply gets the difference in x and y position of the last Dragging event and the current Drag End event, and if the movement has been greater than the flick threshold, it sets some variables that are use to the move the instance in the step event.":"上面的代码只是获取最后一个拖动事件和当前拖动结束事件的 X 和 Y 位置之差，如果移动大于轻击阈值，它将设置一些用于在步事件中移动实例的变量。",
    "The above code simply gets the difference in x and y position of the last Dragging event and the current Flick event, and if the movement has been greater than the flick threshold, it sets some variables that are use to the move the instance in the step event.":"上面的代码只是获取最后一个拖动事件和当前轻击事件的 X 和 Y 位置之差，如果移动超过了轻击阈值，它将设置一些用于在步事件中移动实例的变量。",
    "The above code simply sets up some variables for rotating the view camera, and then in the Rotate Start event, it sets one of them to true.":"上面的代码简单地设置了一些用于旋转视图相机的变量，然后在旋转开始事件中，它将其中一个设置为 true。",
    "The above code uses the Drag Start event to get the position of the touch/click and use it to set an offset value for the x and y axis. This can then be used when dragging the instance to ensure that it doesn\u0027t \"jump\" to the position that the touch/click was detected at (see the Dragging event below for a continuation of this example).":"上面的代码使用拖动开始事件来获取触摸 / 单击的位置，并使用它来设置 X 和 Y 轴的偏移值。然后可以在拖动实例时使用它，以确保它不会 \" 跳转 \" 到检测到触摸 / 单击的位置 (请参阅下面的拖动事件以继续此示例)。",
    "The above code uses the Rotate End event to detect when the user stops the gesture and then sets a variable. This variable is then used in the step event to rotate the view camera back to its original position.":"上面的代码使用旋转结束事件来检测用户何时停止手势，然后设置一个变量。然后，在步事件中使用此变量将视图相机旋转回其原始位置。",
    "The above code will detect a pinch and store the midpoint position for that pinch.":"上面的代码将检测一个捏点并存储该捏点的中点位置。",
    "The above code will detect a tap on the screen and then get the position of the tap to move the instance to that position. Note that if you want to have a longer or shorter tap detection time then you can set it with the function {}{}gesture_drag_time(){}{}. This sets the time between the initial detection and the tap becoming a drag, so set it to a higher value to make tap detection longer or a lower value to make it shorter (value is in seconds and defaults to 0.16).":"上面的代码将检测屏幕上的点击，然后获取点击的位置以将实例移动到该位置。请注意，如果您想要更长或更短的点击检测时间，则可以使用函数 {}{}gesture_drag_time(){}{} 进行设置。这设置了从初始检测到轻触变为拖拽之间的时间，因此将其设置为较高的值可延长轻触检测的时间，或设置较低的值可缩短轻触检测的时间 (值以秒为单位，默认为 0.16)。",
    "The above code will scale the view based on the relative scale of the pinch touches.":"上面的代码将根据捏触点的相对比例来缩放视图。",
    "The above code will set the view position to be centered on the midpoint of the two touches that made up the pinch when the touches are released.":"上面的代码将在释放触摸时将视图位置设置为两个触摸的中点为中心。",
    "The example code above uses the offset variables set in the Drag Start event to move the instance when the Dragging event is triggered.":"当触发拖动事件时，上面的示例代码使用在拖动开始事件中设置的偏移变量来移动实例。",
    "The rotation amount must exceed the minimum threshold angle (which is set to 5° by default, but this can be changed using the function {}{}gesture_rotate_angle(){}{}).":"旋转量必须超过最小阈值角度 (默认情况下设置为 5°，但可以使用函数 {}{}gesture_rotate_angle(){}{} 进行更改)。",
    "Two touches must be held down for a specified minimum time (the default time is 0.16 seconds, but you can change it using the function {}{}gesture_rotate_time(){}{}).":"必须在指定的最短时间内按住两次触摸 (默认时间为 0.16 秒，但您可以使用函数 {}{}gesture_rotate_time(){}{}) 进行更改)。",
    "When a gesture is recognised, it will trigger one or more of the available events, and the event triggered will depend on the type of gesture that has been detected. In every case, however, a {}DS Map{}&nbsp;will be generated for you and stored in the built-in variable {}event_data{}. The keys available will depend on which kind of event it has been created by and are shown in each of the sub-sections below.":"当手势被识别时，它将触发一个或多个可用事件，并且触发的事件将取决于已检测到的手势的类型。但是，在任何情况下，都会为您生成一个{}DS 映射{} ，并将其存储在内置变量{}event_data{}中。可用的密钥将取决于它是由哪种事件创建的，并在下面的每个小节中显示。",
    "When two touches and a movement are detected with the above criteria, a Pinch Event will be triggered, and in each of the events the {}event_data{} DS Map will be populated with the following keys:":"当检测到符合上述标准的两次触摸和一次移动时，将触发夹压事件，并且在每个事件中，将使用以下键填充 {}event_data{} DS 映射：",
    "When two touches and a movement are detected with the above criteria, a Rotate Event will be triggered, and in each of the events the {}event_data{} DS Map will be populated with the following keys:":"当检测到符合上述标准的两次触摸和一次移动时，将触发旋转事件，并且在每个事件中，将使用以下键填充{}event_data{} DS 映射：",
    "Within this minimum time period they must rotate in a consistent direction (if the rotation direction changes within that time then no rotate is started).":"在这一最小时间段内，它们必须以一致的方向旋转(如果旋转方向在该时间内改变，则不会开始旋转)。",
    "You can choose to detect either {}instance {}gestures or {}global {}gestures, where instance gesture events will only be triggered when the initial touch/click is on an instance within the room. Note that the instance must have a valid collision mask (see {}The Sprite Editor - Collision Mask{} and {}The Object Editor - Collision Mask{} sections for more details) for this event to be triggered. Global events, however, will be triggered by touching/clicking anywhere within the game room, and for all instances that have the event.":"您可以选择检测{}实例{}手势或{}全局{}手势，其中实例手势事件只有在初始触摸/点击房间内的实例时才会被触发。请注意，实例必须具有有效的碰撞遮罩(有关详细信息，请参见{}精灵编辑器-碰撞遮罩{}和{}对象编辑器-碰撞遮罩{}部分)，才能触发此事件。然而，全局事件将通过触摸/点击游戏室内的任何位置以及所有具有该事件的实例来触发。",
    "{} The X position of the mid point between the two touches in room space.":"{} 房间空间中两个接触点之间的中点的 X 位置。",
    "{} The X position of the rotation pivot point in room space.":"{} 旋转轴心点在房间空间中的 X 位置。",
    "{} The Y position of the mid point between the two touches in room space.":"{} 房间空间中两个接触点之间的中点的 Y 位置。",
    "{} The Y position of the rotation pivot point in room space.":"{} 旋转轴心点在房间空间中的 Y 位置。",
    "{} This is an ID value that is {}unique{} to the gesture that is in play. This allows you to link the different parts of multi-part gestures (such as drag start, dragging and drag end) together.":"{} 这是一个 ID 值，对于正在使用的手势是 {} 唯一的 {}。这允许您将多部分手势的不同部分 (如拖动开始、拖动和拖动结束) 链接在一起。",
    "{} This is difference in rotation compared to the last event in this gesture, measured in degrees":"{}这是与此手势中的最后一个事件相比的旋转差异，以度为单位",
    "{} This is difference in scale compared to the last event in this gesture (so for {}Pinch In{} events this will always be smaller than 1.0, whereas for {}Pinch Out{} events it will always be larger than 1.0)":"{}这是与此手势中的最后一个事件相比的比例差异(因此，对于{}事件中的{}捏，它将始终小于 1.0，而对于{}捏出{}事件，它将始终大于 1.0)",
    "{} This is the difference in angle compared to where the fingers were when the gesture started, measured in degrees. So, for example, if the fingers have rotated a quarter-circle since the start of the gesture then this value will be 90° or -90°, depending on the direction of rotation.":"{}这是与手势开始时手指所在位置相比的角度差异，以度为单位。因此，例如，如果手指从手势开始旋转了四分之一圈，则该值将为 90°或 -90°，具体取决于旋转方向。",
    "{} This is the gui-space X difference between the position of the current touch and the position of the last touch in this gesture.":"{} 这是当前触摸的位置与此手势中最后一次触摸的位置之间的图形用户界面空间 X 的差。",
    "{} This is the gui-space X position of the first touch (equivalent to getting the mouse position using {}{}{}device_mouse_x_to_gui(){}{}{}).":"{} 这是第一次触摸的图形用户界面空间 X 位置 (相当于使用 {}{}{}device_mouse_x_to_gui(){}{}{} 获取鼠标位置)。",
    "{} This is the gui-space X position of the second touch.":"{}这是第二次触摸的图形用户界面空间 X 位置",
    "{} This is the gui-space X position of the touch (equivalent to getting the mouse position using {}{}{}device_mouse_x_to_gui(){}{}{}).":"{}这是触摸的图形用户界面空间 X 位置(相当于使用{}{}{}device_mouse_x_to_gui(){}{}{}获取鼠标位置)。",
    "{} This is the gui-space X start position of the current gesture.":"{} 这是当前手势的图形用户界面空间 X 开始位置。",
    "{} This is the gui-space Y difference between the position of the current touch and the position of the last touch in this gesture.":"{} 这是当前触摸的位置与此手势中最后一次触摸的位置之间的图形用户界面空间 Y 的差。",
    "{} This is the gui-space Y position of the second touch (equivalent to getting the mouse position using {}{}{}device_mouse_y_to_gui(){}{}{}).":"{} 这是第一次触摸的图形用户界面空间 Y 位置 (相当于使用 {}{}{}device_mouse_y_to_gui(){}{}{} 获取鼠标位置)。",
    "{} This is the gui-space Y position of the second touch.":"{}这是第二次触摸的图形用户界面空间 Y 位置",
    "{} This is the gui-space Y position of the touch (equivalent to getting the mouse position using {}{}{}device_mouse_y_to_gui(){}{}{}).":"{}这是触摸的图形用户界面空间 Y 位置(相当于使用{}{}{}device_mouse_y_to_gui(){}{}{}获取鼠标位置)。",
    "{} This is the gui-space Y start position of the current gesture.":"{} 这是当前手势的图形用户界面空间 Y 开始位置。",
    "{} This is the index of the first touch that is being used as part of the pinch gesture. In general this will be 0, but if the user is touching the screen anywhere else when this event is triggered by another touch, then the value will be greater than 0.":"{} 这是作为捏手势一部分使用的第一次触摸的索引。一般来说，该值将为 0，但如果当此事件由另一次触摸触发时，用户正在触摸其他任何地方的屏幕，则该值将大于 0。",
    "{} This is the index of the second touch that is being used as part of the pinch gesture. In general this will be 1 more than the value for touch1, but may be some other value depending on the number of touches being detected elsewhere.":"{} 这是作为捏手势一部分使用的第二次触摸的索引。通常，这将比 touch1 的值多 1，但也可以是其他值，具体取决于在其他地方检测到的触摸次数。",
    "{} This is the index of the touch that is being used for the gesture. In general this will start at 0 and increase for each finger that is held down, then reset back to 0 when all fingers are removed, but if the user is touching the screen anywhere else when this event is triggered by another touch, then the value will be greater than 0.":"{} 这是手势正在使用的触摸的索引。通常情况下，这将从 0 开始，并随着按下的每个手指的增加而增加，然后在所有手指被移除时重置回 0，但如果当该事件被另一次触摸触发时，用户正在触摸屏幕的其他位置，则该值将大于 0。",
    "{} This is the raw X difference between the position of the current touch and the position of the last touch in this gesture.":"{} 这是当前触摸的位置与此手势中最后一次触摸的位置之间的原始 X 的差。",
    "{} This is the raw X start position of the current gesture.":"{} 这是当前手势的原始 X 开始位置。",
    "{} This is the raw Y difference between the position of the current touch and the position of the last touch in this gesture.":"{} 这是当前触摸的位置与此手势中最后一次触摸的位置之间的原始 Y 的差。",
    "{} This is the raw Y start position of the current gesture.":"{} 这是当前手势的原始 Y 开始位置。",
    "{} This is the raw window-space X position of the mid point.":"{} 这是中点的原始窗口空间 X 位置。",
    "{} This is the raw window-space X position of the rotational pivot point.":"{} 这是旋转轴心点的原始窗口空间 X 位置。",
    "{} This is the raw window-space Y position of the mid point.":"{} 这是中点的原始窗口空间 Y 位置。",
    "{} This is the raw window-space Y position of the rotational pivot point.":"{} 这是旋转轴心点的原始窗口空间 Y 位置。",
    "{} This is the room X start position of the current gesture.":"{} 这是当前手势的房间 X 开始位置。",
    "{} This is the room Y start position of the current gesture.":"{} 这是当前手势的房间 Y 开始位置。",
    "{} This is the room-space X difference between the position of the current touch and the position of the last touch in this gesture.":"{}这是此手势中当前触摸位置和最后一次触摸位置之间的房间空间 X 的差。",
    "{} This is the room-space X position of the first touch.":"{} 这是第一次触摸的房间空间 X 位置。",
    "{} This is the room-space X position of the second touch.":"{} 这是第二次触摸的房间空间 X 位置。",
    "{} This is the room-space X position of the touch.":"{} 这是触摸的房间空间 X 位置。",
    "{} This is the room-space Y difference between the position of the current touch and the position of the last touch in this gesture.":"{}这是此手势中当前触摸位置和最后一次触摸位置之间的房间空间 Y 的差。",
    "{} This is the room-space Y position of the first touch.":"{} 这是第一次触摸的房间空间 Y 位置。",
    "{} This is the room-space Y position of the second touch.":"{} 这是第二次触摸的房间空间 Y 位置。",
    "{} This is the room-space Y position of the touch.":"{} 这是触摸的房间空间 Y 位置。",
    "{} This is the scale compared to where the fingers were when the gesture started (so if the distance between the fingers has halved then this will be 0.5 whereas if the distance has doubled it will be 2.0).":"{}这是手势开始时手指所在位置的比例尺(因此，如果手指之间的距离减半，则为 0.5，而如果距离增加一倍，则为 2.0)。",
    "{} This is the {}raw{} window-space X position of the first touch (equivalent to getting the mouse position using {}{}{}device_mouse_raw_x(){}{}{}).":"{} 这是第一次触摸的 {} 原始 {} 窗口空间 X 位置 (相当于使用 {}{}{}device_mouse_raw_x(){}{}{} 获取鼠标位置)。",
    "{} This is the {}raw{} window-space X position of the first touch.":"{} 这是第二次触摸的 {} 原始 {} 窗口空间 X 位置。",
    "{} This is the {}raw{} window-space X position of the touch (equivalent to getting the mouse position using {}{}{}device_mouse_raw_x(){}{}{}).":"{}这是触摸的{}原始{}窗口空间 X 位置(相当于使用{}{}{}device_mouse_raw_x(){}{}{}获取鼠标位置)。",
    "{} This is the {}raw{} window-space Y position of the first touch (equivalent to getting the mouse position using {}{}{}device_mouse_raw_y(){}{}{}).":"{} 这是第一次触摸的 {} 原始 {} 窗口空间 Y 位置 (相当于使用 {}{}{}device_mouse_raw_y(){}{}{} 获取鼠标位置)。",
    "{} This is the {}raw{} window-space Y position of the second touch.":"{} 这是第二次触摸的 {} 原始 {} 窗口空间 Y 位置。",
    "{} This is the {}raw{} window-space Y position of the touch (equivalent to getting the mouse position using {}{}{}device_mouse_raw_y(){}{}{}).":"{}这是触摸的{}原始{}窗口空间 Y 位置(相当于使用{}{}{}device_mouse_raw_y(){}{}{}获取鼠标位置)。",
    "{} This the gui-space X position of the mid point.":"{}这是中点的图形用户界面空间 X 位置。",
    "{} This the gui-space X position of the rotational pivot point.":"{} 这是旋转轴心点的图形用户界面空间 X 位置。",
    "{} This the gui-space Y position of the mid point.":"{}这是中点的图形用户界面空间 Y 位置。",
    "{} This the gui-space Y position of the rotational pivot point.":"{} 这是旋转轴心点的图形用户界面空间 Y 位置。",
    "{}Double Tap{}{}Double Tap{}":"{}双击{}{}双击{}",
    "{}Drag End{}{}Drag End{}":"{}拖动结束{}{}拖动结束{}",
    "{}Drag Start{}{}Drag Start{}":"{}拖动开始{}{}拖动开始{}",
    "{}Dragging{}{}Dragging{}":"{}正在拖动{}{}正在拖动{}",
    "{}Flick{}{}Flick{}":"{}轻击{}{}轻击{}",
    "{}NOTE{}&nbsp;These events will not be triggered on the HTML5 platform due to lack of support for multi-touch using these events on that platform. If you are looking for gestures on that target then you should be using the {}device functions{}.":"{}注意{} 这些事件不会在HTML5平台上触发，因为该平台不支持使用这些事件的多点触摸。如果您要在该目标上查找手势，则应使用{}设备功能{}。",
    "{}NOTE{}: The variable {}event_data{} is only valid in these events, as the DS map that it points to is automatically created at the start of the event, then destroyed again at the end, with this variable being reset to a value of -1 at all other times.":"{}注意{}：变量 {}event_data{} 仅在这些事件中有效，因为它所指向的 DS 映射是在事件开始时自动创建的，然后在结束时再次销毁，而此变量在所有其他时间都被重置为值 -1。",
    "{}Pinch End{}{}Pinch End{}":"{}捏停止{}{}捏停止{}",
    "{}Pinch Events{}{}Pinch Events{}":"{}捏事件(双指向内){}{}捏事件(双指向内){}",
    "{}Pinch In / Pinch Out{}{}Pinch In / Pinch Out{}":"{}捏入/捏出{}{}捏入/捏出{}",
    "{}Pinch Start{}{}Pinch Start{}":"{}捏开始{}{}捏开始{}",
    "{}Rotate End{}{}Rotate End{}":"{}旋转结束{}{}旋转结束{}",
    "{}Rotate Events{}{}Rotate Events{}":"{}旋转事件{}{}旋转事件{}",
    "{}Rotate Start{}{}Rotate Start{}":"{}旋转开始{}{}旋转开始{}",
    "{}Rotating{}{}Rotating{}":"{}正在旋转{}{}正在旋转{}",
    "{}Tap, Drag, And Flick Events{}{}Tap, Drag, And Flick Events{}":"{}点击、拖动和点击事件{}{}点击、拖动和点击事件{}",
    "{}Tap{}{}Tap{}":"{}点击{}{}点击{}",
    "{}{} Only available in the Drag End event{}. This is set to 1 if the end of the drag is detected as a flick, meaning that you don\u0027t need a separate {}Flick Event{} if you\u0027re handling dragging anyway.":"{}{} 仅在拖动结束事件中可用 {}。如果检测到拖动结束为轻拍，则将其设置为 1，这意味着如果您无论如何都在处理拖动，则不需要单独的 {}轻击事件 {}。"
}