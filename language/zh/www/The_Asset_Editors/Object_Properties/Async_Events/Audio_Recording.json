{
    "\"{}buffer_id{}\" - the ID of the temporary {}buffer{}&nbsp;you can use to retrieve the audio data":"\"{}buffer_id{}\"- 可用于检索音频数据的临时{}缓冲区{}的 ID ",
    "\"{}channel_index{}\" - the recording channel index as returned by the calling function that this data came from":"\"{}channel_index{}\"- 此数据来自的调用函数返回的录制频道索引",
    "\"{}data_len{}\" - the length of data (in bytes) you\u0027ve received":"\"{}data_len{}\"- 您收到的数据长度(以字节为单位)",
    "Audio Recording":"音频录制",
    "Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:":"现在检测到录音的每个游戏步骤都会触发一个异步音频录制事件，您可以在其中处理录制的输入，如下所示：",
    "Here we simply check the \"channel_index\" key to make sure it matches the value returned when we started recording, and if it does we copy the contents of the temporary buffer created for this event into our custom buffer. After that you can do what you want with the custom buffer - you could play it using the dedicated buffer audio functions, you could process it and send it over the network, you could save it to disk... Once you have your recorded audio in a buffer, you can do basically anything you want.":"在这里，我们只需检查 \"channel_index\" 键以确保它与我们开始录制时返回的值匹配，如果匹配，我们将为此事件创建的临时缓冲区的内容复制到我们的自定义缓冲区中。之后你就可以用自定义缓冲区做你想做的 —— 你可以使用专用的缓冲区音频功能播放它，你可以处理它并通过网络发送它，你可以把它保存到磁盘上…一旦你在缓冲区中录制了音频，你基本上可以做到任何你想要的。",
    "In the usage example below we will create a custom buffer to store our recorded audio, and also set our game to record from input source 0:":"在下面的使用示例中，我们将创建一个自定义缓冲区来存储我们录制的音频，并将我们的游戏设置为从输入源0录制：",
    "The following keys will be available in the ds_map:":"ds_map中将提供以下密钥：",
    "{}Audio Recording{}":"{}录音{}",
    "{}NOTE{}: As mentioned at the start of this page, the variable {}async_load {}is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.":"{}注意{}：如本页开头所述，变量 {}async_load{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除。但是，请注意，所有音频与映射一起存储的临时缓冲区也将在事件结束时被删除，因此如果您想保留它以供以后使用，您应该将其复制到自定义缓冲区。",
    "{}This event can only be triggered by the {}{}audio_start_recording(){}{}&nbsp;function and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs depending on the {}callback{} from the function that has triggered the event.":"{}此事件只能由{}{}audio_start_recoring(){}{} 函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {5}DS映射{6}，它包含不同的键 / 值对，具体取决于触发该事件的函数的{}回调{}。",
    "{}This event can only be triggered by the&nbsp;{}{}audio_start_recording{}{} function and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs depending on the {}callback{} from the function that has triggered the event.":"{}此事件只能由{}{}audio_start_recoring(){}{} 函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {5}DS映射{6}，它包含不同的键 / 值对，具体取决于触发该事件的函数的{}回调{}。",
    "{}{}NOTE{}{}&nbsp;As mentioned at the start of this page, the variable&nbsp;{}{}async_load{}{} is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.":"{}{}注意{}{}：如本页开头所述，变量 {}{}async_load{}{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除。但是，请注意，所有音频与映射一起存储的临时缓冲区也将在事件结束时被删除，因此如果您想保留它以供以后使用，您应该将其复制到自定义缓冲区。"
}