{
    "\"{}buffer_id{}\" - the buffer ID for the {}buffer{}&nbsp;that is no longer being played from.":"\"{}buffer_id{}\"-不再播放的{}缓冲区{}的缓冲区ID。",
    "\"{}queue_id{}\" - the queue index for the queue that has finished playing, as returned by the function {}{}audio_create_play_queue(){}{}.":"\"{}queue_id{}\"- 已完成播放的队列的队列索引，由函数返回 {}{}audio_create_play_queue(){}{}.",
    "\"{}queue_shutdown{}\" - this is set to 0 during normal playback and 1 when the event is received because {}{}audio_free_play_queue(){}{}&nbsp;has been called. When this is set to 1, you don\u0027t want to queue up any further data.":"\"{}queue_shutdown{}\"-在正常播放期间设置为0，在接收到事件时设置为1，因为{}{}audio_free_play_queue(){}{}被称为。当此值设置为1时，您不希望排队等待任何进一步的数据。",
    "Audio Playback":"音频回放",
    "Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:":"现在检测到录音的每个游戏步骤都会触发一个异步音频录制事件，您可以在其中处理录制的输入，如下所示：",
    "Here we check the queue ID and if it\u0027s the one we want, we then check the buffer ID to see which buffer has finished being played. We also then set a local var to that index value for checking later and set the buffer back to the start for that sound. Once our local variable reaches 9, indicating that the queue has finished, we stop the sound playing and free the queue.":"在这里，我们检查队列ID，如果它是我们想要的，我们然后检查缓冲区ID以查看哪个缓冲区已完成播放。然后，我们还将本地变量设置为该索引值以供稍后检查，并将缓冲区设置回初始值声音。一旦我们的局部变量达到9，表明队列已经完成，我们就停止声音播放并释放队列。",
    "In the example of use given below we will create an audio queue with 10 buffered audio sounds added to it and then play the queue:":"在下面给出的使用示例中，我们将创建一个音频队列，其中添加了10个缓冲的音频声音，然后播放队列：",
    "Since an audio queue can be created from multiple buffers, this event can be triggered multiple times for one queue as the end of each section of buffered audio is reached, hence the \"buffer_id\" key.":"由于可以从多个缓冲区创建音频队列，因此当到达缓冲音频的每个部分的末尾时，可以为一个队列多次触发此事件，因此使用\"buffer_id\"键。",
    "The following keys will be available in the DS map:":"以下键将在DS地图中可用：",
    "{}Audio Playback{}":"{}音频播放{}",
    "{}NOTE{}: The variable {}async_load{}&nbsp; is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of -1. However, all further data-structures created from the event must be cleaned up using the appropriate functions.":"{}注意{}：变量 {}async_load{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除，使用这个变量被重置为 -1 的值。但是，必须使用相应的函数清理从该事件中创建的所有其他数据结构。",
    "{}This event can only be triggered by the {}audio queue{} play functions&nbsp;and will return a {}DS Map{}&nbsp;stored in the variable {} {}async_load{}{}, containing different key/value pairs relating to the audio queue that has triggered the event. The event is triggered by a&nbsp;{}callback{}&nbsp;when you have selected an audio queue to playback and a buffer in that audio queue is finished playing.":"{}此事件只能由{}音频队列{}播放函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {3}DS Map{4}，包含与触发事件的音频队列相关的不同键 / 值对。当你选择了要播放的音频队列和时，该事件由 {}回调{} 触发该音频队列中的缓冲区已播放完毕。",
    "{}This event can only be triggered by the {}audio queue{} play functions&nbsp;and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs relating to the audio queue that has triggered the event. The event is triggered by a&nbsp;{}callback{}&nbsp;when you have selected an audio queue to playback and a buffer in that audio queue has finished playing.":"{}此事件只能由{}音频队列{}播放函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {3}DS Map{4}，包含与触发事件的音频队列相关的不同键 / 值对。当你选择了要播放的音频队列和时，该事件由 {}回调{} 触发该音频队列中的缓冲区已播放完毕。",
    "{}{}NOTE{}{}&nbsp;The variable&nbsp;{}{}async_load{}{} is only valid in the asynchronous events, as the DS map that it points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of {}-1{}. However, all further data structures created from the event must be cleaned up using the appropriate functions.":"{}{}注意{}{}：变量 {}{}async_load{}{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除，使用这个变量被重置为 {}-1{} 的值。但是，必须使用相应的函数清理从该事件中创建的所有其他数据结构。"
}