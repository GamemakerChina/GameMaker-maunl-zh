{
    "Apart from the main Draw event, you also have a {} Draw Begin{} and a {}Draw End{}&nbsp;event too. These act exactly the same as a standard Draw event (i.e.: they will draw whatever you put in them every step of the game and for all viewports), but they do not \"default draw\" anything if they have not been explicitly added to an object, and they will always run before/after the standard Draw event. So, when the game is running you will {}always{}&nbsp;have the Draw Begin event for all instances, then the Draw event for all instances, then finally the Draw End event for all instances.":"除了主绘制事件之外，还有{}绘制开始{}和{}绘制结束{}事件。它们的作用与标准绘制事件完全相同(即：它们将在游戏的每一步和所有视口中绘制您放入其中的任何内容)，但是如果它们没有被显式地添加到对象，则它们不会\"默认绘制\"任何内容，并且它们总是在标准的Draw事件之前/之后运行。所以，当游戏运行时，你将{}总是{}有所有实例的Draw开始事件，然后是所有实例的Draw事件，最后是所有实例的Draw End事件。",
    "Apart from the main Draw event, you also have a {} Draw Begin{} and a {}Draw End{}&nbsp;event too. These act exactly the same as a standard Draw event (ie: they will draw whatever you put in them every step of the game and for all viewports), but they do not \"default draw\" anything if they have not been explicitly added to an object, and they will always run before/after the standard Draw event. So, when the game is running you will {}always{}&nbsp;have the Draw Begin event for all instances, then the Draw event for all instances, then finally the Draw End event for all instances.":"除了主绘制事件之外，您还有一个{}绘制开始{}和一个{}绘制结束{}事件。这些行为完全一样的标准绘制事件(即：他们将绘制任何你把他们在游戏的每一步和所有视口)，但他们不默认绘制任何东西，如果他们没有被明确添加到一个对象，他们将始终运行之前/之后的标准绘制事件。因此，当游戏运行时，您将{}始终{}对所有实例有绘制开始事件，然后对所有实例有绘制事件，最后对所有实例有绘制结束事件。",
    "If your object has had the visible parameter set to {}off {}(so that the instances of the object are not drawn) then {}all Draw events are skipped {}(except for the {}Resize {}event). This means that making an instance invisible will stop all code placed in any of these events from running, so don\u0027t put essential code in the Draw events if they are not going to be visible.":"如果您的对象已将visible参数设置为{}off{}(以便不绘制对象的实例)，则{}所有Draw事件都将被跳过{}({}Resize{}事件除外)。这意味着使实例不可见将停止放置在任何这些事件中的所有代码的运行，因此，如果Draw事件不可见，请不要将基本代码放入其中。",
    "If your object has had the visible parameter set to {}off {}(so that the instances of the object are not drawn) then {}all draw events are skipped {}(except for the {}Resize {}event). This means that making an instance invisible will stop all code placed in any of these events from running, so don\u0027t put essential code in the draw events if they are not going to be visible.":"如果您的对象已将可见参数设置为 {}off{} ( 以便不绘制对象的实例)，则 {} 所有绘制事件都将跳过 {}({} 调整大小 {} 事件除外)。这意味着使实例不可见将阻止放置在任何这些事件中的所有代码运行，因此如果它们不可见，请不要将基本代码放在绘制事件中。",
    "In this way, you can draw things or set draw properties in the Draw Begin step in one instance and be sure that all instances with a standard Draw event or Draw End event will use these properties or draw over what the first instance has drawn. Basically it\u0027s a sure fire way to guarantee that certain things are drawn at certain times, much like the {}Begin Step{} and {}End Step {}events do.":"通过这种方式，您可以在一个实例的绘制开始步骤中绘制内容或设置绘制属性，并确保具有标准绘制事件或绘制结束事件的所有实例都将使用这些属性或绘制第一个实例已绘制的内容。基本上，这是一种确保在特定时间绘制特定内容的可靠方法，就像{}开始步骤{}和{}结束步骤{}事件一样。",
    "In this way, you can draw things or set draw properties in the Draw Begin step in one instance and be sure that all instances with a standard Draw event or Draw End event will use these properties or draw over what the first instance has drawn. Basically its a sure fire way to guarantee that certain things are drawn at certain times, much like the {}Begin Step{} and {}End Step {}events do.":"通过这种方式，您可以在一个实例中的绘制开始步骤中绘制东西或设置绘制属性，并确保具有标准绘制事件或绘制结束事件的所有实例都将使用这些属性或绘制第一个实例绘制的内容。基本上，这是一种确保某些东西在特定时间被绘制的可靠方法，就像{}开始步骤{}和{}结束步骤{}事件所做的那样。",
    "In this way, you can draw things or set draw properties in the Draw GUI Begin in one instance and be sure that all instances with a standard Draw GUI or Draw GUI End event&nbsp;will use these properties or draw over what the first instance has drawn. Basically it\u0027s a sure fire way to guarantee that certain things are drawn at certain times, much like the {}Begin Step{} and {}End Step{}&nbsp;events do.":"通过这种方式，您可以在一个实例中的绘制 GUI 开始中绘制东西或设置绘制属性，并确保具有标准绘制 GUI 或绘制 GUI 结束事件的所有实例都将使用这些属性或绘制第一个实例绘制的内容。基本上，这是一种确保某些东西在特定时间被绘制的可靠方法，就像 {} 开始步骤 {} 和 {} 结束步骤 {} 事件所做的那样。",
    "It is worth noting that this event happens {}before {}the display buffer is cleared for regular drawing meaning that if you do not switch off view clearing in the room editor then nothing that is drawn in the Pre Draw event will be seen, as the first viewport draw will clear it. If you want to be able to see through the viewports&nbsp;themselves, or you are not using viewports&nbsp;at all, then you should also have set the background colour to have an alpha of 0 in the {}{}Room Editor{}{}.":"值得注意的是，这个事件发生在{}{}显示缓冲区被清空之前，这意味着如果你没有在房间编辑器中关闭视图清空，那么在预绘制事件中绘制的东西将不会被看到，因为第一次视口绘制将清空它。如果你想看透视口本身，或者你根本不使用视口，那么你也应该在{}{}房间编辑器{}{}中把背景颜色设置为alpha值为0。",
    "It is worth noting that this event happens {}before {}the display buffer is cleared for regular drawing, meaning that if you do not switch off view clearing in&nbsp;{}The Room Editor{} then nothing that is drawn in the Pre-Draw event will be seen, as the first viewport draw will clear it. If you want to be able to see through the viewports&nbsp;themselves, or you are not using viewports&nbsp;at all, then you should also have set the background colour to have an alpha of 0 in {}The Room Editor{}.":"值得注意的是，此事件发生在显示缓冲区为常规绘图而清除 {} 之前 {}，这意味着如果您没有在 {} 房间编辑器 {} 中关闭视图清除，则在预绘制事件中绘制的任何内容都不会被看到，因为第一个视口绘制将清除它。如果您希望能够通过视口本身进行查看，或者根本不使用视口，那么你也应该在 {} 房间编辑器 {} 中设置背景颜色为 0。",
    "On the UWP target platform it is important that you catch any resizing of the display buffer from the \"snapping\" of the game window (when the user drags the window to the side of the display, for example). This event will do just that and is triggered every time the window is changed, permitting you to add custom code here that will resize the view or re-position {}HUD{} elements as necessary. This function is provided as a convenient way to avoid having step event code that checks for these things all the time.":"在UWP目标平台上，重要的是你要捕捉到游戏窗口的 \"捕捉 \"带来的任何显示缓冲区的大小调整（例如，当用户将窗口拖到显示器的一侧时）。这个事件就可以做到这一点，并且在每次改变窗口时都会被触发，允许你在这里添加自定义代码，在必要时调整视图大小或重新定位{}HUD{}元素。这个函数是作为一种方便的方式提供的，以避免一直检查这些东西的步骤事件代码。",
    "The Draw Events":"绘制事件",
    "The Draw GUI event type falls under the Draw Event category and is specifically designed for drawing {}GUI{}&nbsp;elements that are not affected by the view camera scale or rotation. This means that you can have an instance draw all the elements for your {}HUD{}&nbsp;or user interface without having to base all the positioning of the elements on the the instance position within the room or the position of the current camera view.":"绘制 GUI 事件类型属于绘制事件类别，专为绘制不受视图相机比例或旋转影响的 {}GUI{} 元素而设计。这意味着您可以让一个实例为您的 {}HUD{} 或用户交互界面绘制所有元素，而不必将元素的所有位置基于房间内的实例位置或当前相机视图的位置。",
    "The Draw GUI event type falls under the Draw Event category and is specifically designed for drawing {}GUI{}&nbsp;elements that are not affected by the view camera scale or rotation. This means that you can have an instance draw all the elements for your {}HUD{}&nbsp;or user interface without having to base all the positioning of the elements on the&nbsp;instance position within the room or the position of the current camera view.":"绘制 GUI 事件类型属于绘制事件类别，专为绘制不受视图相机比例或旋转影响的 {}GUI{} 元素而设计。这意味着您可以让一个实例为您的 {}HUD{} 或用户交互界面绘制所有元素，而不必将元素的所有位置基于房间内的实例位置或当前相机视图的位置。",
    "The Draw event is a very intensive event, in that it\u0027s one of the events that takes up most time and resources... To that end it is never a good idea to do anything in the Draw event other than drawing. So save your large code or complex actions for the Step event or Alarms or whatever other event fits, but leave the Draw event clear for the drawing as that\u0027s what it does best.":"Draw事件是一个非常密集的事件，因为它是占用最多时间和资源的事件之一.为此，在Draw事件中执行除绘图之外的任何操作都不是一个好主意。因此，将您的大型代码或复杂操作保存为Step事件或Alarms或任何其他适合的事件，但将Draw事件保留为绘图事件，因为这是它最擅长的。",
    "The Post Draw event is triggered {}after {}all the standard draw events, but {}before {}the Draw GUI events. Like the Pre Draw event, it is based on the size of the display buffer, and is placed before the Draw GUI events to enable you to perform post-processing effects and other things on a full screen basis simply and easily without interfering with any {}HUD{}/ {}GUI{}&nbsp;elements that you may have in your game.":"Post Draw事件是在所有标准绘制事件{}之后{}，但{}在{}绘制GUI事件之前触发的。与Pre Draw事件一样，它基于显示缓冲区的大小，并被置于绘制GUI事件之前，以使你能够在全屏基础上简单轻松地执行后期处理效果和其他事情，而不干扰你在游戏中可能有的任何{}HUD{}/{}GUI{}&nbsp;元素。",
    "The Post-Draw event is triggered {}after {}all the standard draw events, but {}before {}the Draw GUI events. Like the Pre-Draw event, it is based on the size of the display buffer, and is placed before the Draw GUI events to enable you to perform post-processing effects and other things on a full screen basis simply and easily without interfering with any {}HUD{}/ {}GUI{}&nbsp;elements that you may have in your game.":"绘制后事件在所有标准绘制事件{}之后{}触发，但在绘制GUI事件{}之前{}触发。与绘制前事件一样，它基于显示缓冲区的大小，并位于绘图GUI事件之前，使您能够在不干扰任何{}HUD{}/{}GUI{}的情况下，简单轻松地在全屏基础上执行后期处理效果和其他操作你在游戏中可能会遇到的问题。",
    "The Pre Draw and Post Draw events are part of the Draw Event category. However, unlike the other Draw events these draw {}directly {}to the {}display buffer{}, which will be the size of the combined screen space for all viewports&nbsp;currently visible, {}or {}the window size if only using one viewport or none at all. The image below illustrates this:":"Pre Draw和Post Draw事件是Draw事件的一部分。然而，与其他绘制事件不同的是，这些事件{}直接绘制{}到{}显示缓冲区{}，这将是所有视口&nbsp;当前可见的屏幕空间的总和，{}或者{}窗口大小，如果只使用一个视口或者根本不使用。下面的图片说明了这一点。",
    "The Pre Draw event is triggered before any other draw event, and in it you can set values, set draw properties and even draw things without worrying about the viewports&nbsp;or the size of the GUI layer (the GUI layer size may be the same as the screen buffer, but it may not be since you can set the GUI resolution in code).":" Pre Draw事件在任何其他绘制事件之前被触发，在其中你可以设置值，设置绘制属性，甚至绘制东西，而不必担心视口&nbsp;或GUI层的大小（GUI层的大小可能与屏幕缓冲区相同，但也可能不相同，因为你可以在代码中设置GUI分辨率）。",
    "The Pre-Draw event is triggered before any other Draw event, and in it you can set values, set draw properties and even draw things without worrying about the viewports&nbsp;or the size of the GUI layer (the GUI layer size may be the same as the screen buffer, but it may not be since you can set the GUI resolution in code).":"Pre-Draw事件在任何其他Draw事件之前触发，在其中您可以设置值，设置绘制属性，甚至绘制东西，而无需担心视口或GUI层的大小(GUI层大小可能与屏幕缓冲区相同，但可能不是，因为您可以在代码中设置GUI分辨率)。",
    "The draw event is a very intensive event, in that it\u0027s one of the events that takes up most time and resources... to that end it is never a good idea to do anything in the draw event other than drawing. So save your large code or complex actions for the Step event or Alarms or whatever other event fits, but leave the draw event clear for the drawing as that\u0027s what it does best.":"绘制事件是一个非常密集的活动，因为这是一个占用大多数时间和资源的事件...为此，在绘制事件中做除了绘制任何事情都不是一个好主意。因此，请在\"步骤\"事件或\"报警\"或其他任何适合的事件保存大型代码或复杂动作，但请保留绘制事件的清除状态，因为这是绘制的最佳选择。",
    "The rest of the Draw events are explained in the sections listed below:":"其余的绘制事件将在下面列出的部分中进行说明：",
    "The rest of the draw events are explained in the sections listed below:":"其余绘制事件在以下章节中进行了解释：",
    "The {}Pre-Draw{} and {}Post-Draw{} events are part of the Draw Event category. However, unlike the other Draw events these draw {}directly {}to the {}display buffer{}, which will be the size of the combined screen space for all viewports&nbsp;currently visible, {}or {}the window size if only using one viewport or none at all. The image below illustrates this:":"{} 绘制前 {} 和 {} 绘制后 {} 事件是绘制事件类别的一部分。但是，与其他绘制事件不同，这些事件 {} 直接 {} 绘制到 {} 显示缓冲区 {}，显示缓冲区将是当前可见的所有视口的组合屏幕空间的大小，{} 或 {} 窗口大小 (如果仅使用一个视口或根本不使用视口)。下图说明了这一点：",
    "The {}custom draw{}, which is when you place code or actions in the Draw event. This is telling {}GameMaker{} \"{}I want to control what you draw for instances of this object{}\" and it completely overrides the default drawing. This means that, for example, you can have an object with a sprite assigned, then set the Draw event to draw text and the text will be drawn on-screen, but the sprite will {}not {}be drawn as you have not told {}GameMaker{} to draw it along with the text.":"{}自定义绘制{}，当您在Draw事件中放置代码或操作时。这告诉{}GameMaker{}\"{}我想控制您为此对象的实例绘制的内容{}\"，它完全覆盖默认绘制。这意味着，例如，您可以为对象分配精灵，然后将Draw事件设置为绘制文本，文本将在屏幕上绘制，但精灵将{}不会{}被绘制，因为你没有告诉{}GameMaker{}将其沿着绘制在文本中。",
    "The {}custom draw{}, which is when you place code or actions in the draw event. This is telling {}GameMaker{} \"{}I want to control what you draw for instances of this object{}\" and it completely overrides the default drawing. This means that, for example, you can have an object with a sprite assigned, then set the draw event to draw text and the text will be drawn on-screen, but the sprite will {}not {}be drawn as you have not told {}GameMaker{} to draw it along with the text.":"{} 自定义绘制 {}，即在绘制事件中放置代码或操作时。这告诉 {}GameMaker{}\"{} 我想控制你为这个对象 {} 的实例绘制什么\"，它完全覆盖了默认绘制。这意味着，例如，您可以为一个对象分配一个精灵，然后将绘制事件设置为绘制文本，文本将在屏幕上绘制，但精灵不会 {}{} 被绘制，因为您没有告诉 {}GameMaker{} 将其与文本一起绘制。",
    "The {}default draw{}, which is when you define the sprite in the object properties and place no actions or code in the normal Draw event, and in this case {}GameMaker{} will draw the assigned sprite automatically. Note that any transforms you perform in other events to change the image scale, index, blending etc... will be reflected too as long as the draw event is empty.":"{} 默认绘制 {}，即您在对象属性中定义精灵并在正常的绘制事件中不放置任何操作或代码时，在这种情况下 {}GameMaker{} 将自动绘制分配的精灵。请注意，只要绘制事件为空，您在其他事件中执行的任何转换以更改图像比例、索引、混合等都会得到反映。",
    "The {}default draw{}, which is when you define the sprite in the object properties and place no actions or code in the normal Draw event. In this case {}GameMaker{} will draw the assigned sprite automatically, or nothing if you don\u0027t assign&nbsp;sprite. Note that any changes you make in other events to e.g. {}{}image_xscale{}{}, {}{}image_yscale{}{}, {}{}sprite_index{}{}, {}{}image_blend{}{}, etc. will be reflected too as long as the Draw event is empty.":"{}默认绘制{}，即当您在对象属性中定义精灵，并且在正常的Draw事件中不放置任何动作或代码时。在这种情况下，{}GameMaker{}将自动绘制指定的精灵，或者如果您不指定精灵，则不绘制任何东西。请注意，您在其他事件中所做的任何更改，例如，{}{}image_xscale{}{}，{}{}image_yscale{}{}，{}{}sprite_index{}{}，   {}{}image_blend{}{}等也将被反映，只要Draw事件为空。",
    "There are a few things to note when drawing things in {}GameMaker{}, whether it\u0027s a sprite you are drawing or a shader, or a 3D buffer:":"在 {}GameMaker{} 中绘制东西时需要注意一些事情，无论是您正在绘制的精灵、着色器还是 3D 缓冲区：",
    "These events can also be used in conjunction with the normal Draw events (which will be affected by the camera view position, scale and rotation as normal). If you have no Draw Event but you do have a Draw GUI Event, then {}GameMaker{} will still default draw the sprite for the instance (if it has one) as normal.":"这些事件也可以和普通的Draw事件一起使用（Draw事件会受到摄像机视图位置、比例和旋转的正常影响）。如果你没有绘制事件，但你有一个绘制GUI事件，那么{}GameMaker{}仍然会默认为实例绘制精灵（如果它有的话），就像平常一样。",
    "This event type falls under the Draw Event category, and although it doesn\u0027t actually draw anything, it does react to changes in the display buffer - specifically, it is designed for reacting to the change in the UWP display buffer size when the game window is \"snapped\".":"这个事件类型属于 \"绘制事件 \"类别，虽然它实际上并不绘制任何东西，但它确实对显示缓冲区的变化做出反应--具体而言，它被设计用来对游戏窗口被 \"捕捉 \"时的UWP显示缓冲区大小变化做出反应。",
    "What you draw has nothing to do with the collision engine you choose (traditional or physics) as that is defined by the object properties and the sprite (or mask) that the object has been given.":"您绘制的内容与您选择的碰撞引擎(传统或物理)无关，因为碰撞引擎由对象属性和对象给定的精灵(或掩码)定义。",
    "When drawing in these event it is important that you understand that the draw coordinates do not change even when camera views are active and (0,0) is {}always {}the top left hand corner of either the application surface or the display (see the note at the bottom of this section), and the default width and height are 1:1 with the application surface. Depth ordering is still maintained between different instances on different layers (so an instance on a higher layer will be drawn under one at a lower layer) and also within the events themselves, as the {}Draw GUI Begin{} event will draw for all instances first, then the standard {}Draw GUI{} will draw for all instances over that, and finally the {}Draw Gui End&nbsp;{}event is triggered.":"在这些事件中绘制时，重要的是您要理解绘制坐标不会改变，即使相机视图处于活动状态，并且 (0,0){} 始终 {} 位于应用程序表面或显示器的左上角 (请参阅本节底部的注释)，默认宽度和高度与应用程序表面为 1:1。深度排序仍然保持在不同层上的不同实例之间 (因此较高层上的实例将在较低层的实例下绘制)，也在事件本身内部，因为 {}Draw GUI 开始 {} 事件将首先为所有实例绘制，然后标准 {}Draw GUI{} 将为所有实例绘制，最后 {}Draw GUI 结束 {} 事件被触发。",
    "When drawing in these events it is important that you understand that the draw coordinates do not change even when camera views are active and (0,0) is {}always {}the top left hand corner of either the application surface or the display (see the note at the bottom of this section), and the default width and height are 1:1 with the application surface. Depth ordering is still maintained between different instances on different layers (so an instance on a higher layer will be drawn under one at a lower layer) and also within the events themselves, as the {}Draw GUI Begin{} event will draw for all instances first, then the standard {}Draw GUI{} will draw for all instances over that, and finally the {}Draw GUI End&nbsp;{}event is triggered.":"在这些事件中绘图时，请务必了解，即使相机视图处于活动状态，绘图坐标也不会更改，并且(0，0){}始终{}位于应用程序表面或显示屏的左手上角(请参阅本节底部的注释)，默认宽度和高度为1：在不同层上的不同实例之间仍然保持深度顺序(因此，较高层上的实例将绘制在较低层上的实例之下)以及事件本身内，因为{}绘制GUI开始{}事件将首先为所有实例绘制，然后标准{}绘制GUI{}将为所有实例绘制，最后触发{}绘制GUI结束{}事件。",
    "With relation to the other draw events, the Draw GUI events will always draw over anything drawn in the normal draw events. So, if you have an instance on a lower layer with a Draw GUI event, it will draw over the instance that is on a higher layer with a regular draw event. If both instances have a Draw GUI event, then the layer order will be respected.":"关于其他的绘制事件，Draw GUI事件将总是在普通绘制事件中绘制的任何东西上绘制。因此，如果你有一个实例在较低的层上有一个Draw GUI事件，它将在较高的层上有一个普通绘制事件的实例上绘制。如果两个实例都有一个Draw GUI事件，那么层的顺序将被尊重。",
    "{}Draw Begin And Draw End{}{}Draw Begin And Draw End{}":"{} 绘制开始和绘制结束 {}{} 绘制开始和绘制结束 {}",
    "{}Draw Events{}":"{}绘制事件{}",
    "{}Draw GUI{}{}Draw GUI{}":"{}绘制GUI{}{}绘制GUI{}",
    "{}NOTE{}: If you switch off these options, you may notice unwanted artefacts being drawn on the screen when the game is tested (like \"trails\" from instances). This is because you are drawing directly over the previous frame of the display buffer without it being cleared. However you can use {}{}draw_clear_alpha(){}&nbsp;{}to do this yourself.":"{}注意{}: 如果你关闭了这些选项，你可能会注意到在游戏测试时，屏幕上会出现不需要的东西（比如实例的 \"痕迹\"）。这是因为你直接在显示缓冲区的前一帧上作画，而没有将其清除。然而，你可以使用{}{}draw_clear_alpha(){}&nbsp;{}来自己清除。",
    "{}NOTE{}: This event will, by default, draw 1:1 with the application surface size, which is normally the size of the room or the view port. This means that when you have {}Aspect Ratio Correction{} on in the Game Options the GUI is not going to be drawn over the black bars that \"letterbox\" the game. This behavior can be switched off using the {}{} {}display_set_gui_maximise(){}{}{}&nbsp;function, and you can also lock the GUI event to a specific size which will then be scaled to fit the display or application surface dimensions automatically by using the function {}{}display_set_gui_size(){}{}.":"{}注意{}: 默认情况下，该事件将与应用表面尺寸（通常是房间或视口的尺寸）成1:1。这意味着，当你在游戏选项中打开{}纵横比校正{}时，GUI将不会被绘制在游戏的黑色边框上。这种行为可以通过{}{}{}display_set_gui_maximise(){}{}{}&nbsp;函数关闭，你也可以通过{}{}display_set_gui_size(){}{}函数将GUI事件锁定为特定尺寸，然后自动缩放以适应显示器或应用表面尺寸。",
    "{}NOTE{}: You cannot draw in this event! It is triggered by resizing the window and is only for catching this change... any drawing that should be done still must be in one of the other draw events.":"{}注意{}：你不能在这个事件中绘制！它是由调整窗口大小触发，并且只用于捕捉这一变化......任何应该进行的绘制仍然必须在其他的绘制事件中进行。",
    "{}Pre And Post Draw{}{}Pre And Post Draw{}":"{}开始绘制和结束绘制{}{}开始绘制和结束绘制{}",
    "{}So, if you are using the Pre or Post draw events, you are drawing to the full screen render target (display buffer) which will have the same size as the window to which all viewports&nbsp;are made to fit. If you have no viewports&nbsp;active, this is instead set to the size of the window itself.":"{}因此，如果你使用Pre或Post draw事件，你将绘制到全屏的渲染目标（显示缓冲区），它的大小与所有视口&nbsp;所适应的窗口相同。如果你没有活动的视口，这将被设置为窗口本身的大小。",
    "{}So, if you are using the {}Pre-Draw{} or {}Post-Draw{} events, you are drawing to the full screen render target (display buffer) which will have the same size as the window to which all viewports&nbsp;are made to fit. If you have no viewports&nbsp;active, this is instead set to the size of the window itself.":"{} 所以，如果使用 {}Pre-Draw{} 或 {}Post-Draw{} 事件，则绘制到全屏渲染目标 (显示缓冲区)，该目标的大小与所有视口都适合的窗口大小相同。如果没有活动的视口，则将其设置为窗口本身的大小。",
    "{}The Draw event category is the one that has all the events that govern what you see on the screen when you run your game. It is split into various separate events to better handle the different drawing requirements for your game. The&nbsp;image below illustrates the order in which the events are performed:&nbsp;":"{}绘制事件类别包含所有事件，这些事件控制您运行游戏时在屏幕上看到的内容。它分为各种单独的事件，以更好地处理游戏的不同绘制要求。下图说明了事件的执行顺序：",
    "{}The Draw event category is the one that has all the events that governs what you see on the screen when you run your game. It is split into various separate events to better handle the different drawing requirements for your game, and the&nbsp;image below illustrates the order in which each event is performed:":"{}绘制事件类别是一个包含所有事件的类别，这些事件控制着您在运行游戏时在屏幕上看到的内容。它被分成不同的独立事件，以更好地处理游戏的不同绘制要求，下图说明了每个事件的执行顺序：",
    "{}The normal Draw event falls into three sub-types: The {}Draw Begin{}, the standard {}Draw{} and the {}Draw End{} events. In general, you will only need to use the standard Draw event and you should be aware that all instances in a room will have this event triggered each step of the game, so this event will always be called as long as the instance has the {}visible {}flag set to true. It is important to understand that even if you have defined nothing for this sub-event in the object properties (ie: no code nor actions), {}if the object has a sprite assigned it will still have a draw event which will be triggered{}. This is because {}GameMaker{} has two ways to draw things in the Draw event:":"{} 正常的绘制事件分为三个子类型：{} 绘制开始 {}、标准 {} 绘制 {} 和 {} 绘制结束 {} 事件。一般来说，您只需要使用标准的绘制事件，并且您应该知道房间中的所有实例在游戏的每一步都会触发此事件，因此只要实例将 {} visible {} 标志设置为 true，就会始终调用此事件。重要的是要理解，即使您在对象属性中没有为此子事件定义任何内容 (即：没有代码或操作)，{} 如果对象分配了精灵，它仍然会有一个将被触发的绘制事件 {}。这是因为 {}GameMaker{} 有两种方法可以在绘制事件中绘制东西：",
    "{}The normal Draw event falls into three sub-types: The {}Draw Begin{}, the standard {}Draw{} and the {}Draw End{} events. In general, you will only need to use the standard Draw event and you should be aware that all instances in a room will have this event triggered each step of the game, so this event will always be called as long as the instance has the&nbsp;{}{}visible{}{} flag set to {}true{}. It is important to understand that even if you have defined nothing for this sub-event in the object properties (i.e.: no code nor actions), {}if the object has a sprite assigned it will still have a Draw event which will be triggered{}. This is because {}GameMaker{} has two ways to draw things in the Draw event:":"{}普通的绘制事件瀑布分为三个子类型：{}绘制开始{}、标准{}绘制{}和{}绘制结束{}事件。一般来说，您只需要使用标准绘制事件，并且您应该注意，房间中的所有实例都会在游戏的每一步触发此事件，因此只要实例具有   {}{}visible{}{}  flag设置为 {}true{}。重要的是要理解，即使你在对象属性中没有为这个子事件定义任何东西(即：没有代码也没有动作)，{}如果对象有一个指定的精灵，它仍然会有一个Draw事件被触发{}。这是因为{}GameMaker{}有两种方法在Draw事件中绘制东西：",
    "{}Window Resize{}{}Window Resize{}":"{}窗口大小调整{}{}窗口大小调整{}",
    "{}{}NOTE{}{}&nbsp;This event will, by default, draw 1:1 with the application surface size, which is normally the size of the room or the view port. This means that when you have {}Aspect Ratio Correction{} on in the&nbsp;{}Game Options{} the GUI is not going to be drawn over the black bars that \"letterbox\" the game. This behavior can be switched off using the&nbsp;{}{}display_set_gui_maximise{}{} function, and you can also lock the GUI event to a specific size which will then be scaled to fit the display or application surface dimensions automatically by using the function {}{}display_set_gui_size{}{}.":"{}{}注意{}{}默认情况下，此事件将与应用程序表面大小(通常是房间或视口的大小)1：1绘制。这意味着当您在{}游戏选项{}中启用{4}纵横比校正{5}时，GUI将不会绘制在\"信箱\"游戏的黑条上。此行为可以使用{}{}display_set_gui_maximum{}{}函数，您还可以将GUI事件锁定为特定大小，然后使用函数自动缩放该大小以适应显示或应用程序表面尺寸{}{}display_set_gui_size{}{} .",
    "{}{}{}NOTE{}{}&nbsp;{}If you switch off these options, you may notice unwanted artefacts being drawn on the screen when the game is tested (like \"trails\" from instances). This is because you are drawing directly over the previous frame of the display buffer without it being cleared. However you can use&nbsp;{}{}draw_clear_alpha{}{} to do this yourself.":"{}{}{} 注意{}{}{} 如果您关闭这些选项，您可能会注意到在测试游戏时屏幕上绘制了不需要的伪影 (例如实例的 \" 痕迹 \")。这是因为您直接在显示缓冲区的前一帧上绘制而未将其清除。但是您可以使用 {}{}draw_clear_alpha{}{} 自行完成此操作。",
    "{}{}{}NOTE{}{}&nbsp;{}You cannot draw in this event! It is triggered by resizing the window and is only for catching this change... Any drawing that should be done still must be in one of the other Draw events.":"{}{}{}注意{}{}{}您不能在此事件中绘制！它由调整窗口触发，仅用于捕获此更改.."
}