{
    "/// @description Your text here":"/// @description 描述文本放这",
    "And now in your Event Editor you\u0027ll see this:":"现在在你的事件编辑器中，你会看到这个：",
    "Asynchronous Events List":"异步事件列表",
    "At this point, you may be asked to choose between&nbsp;{}GML Visual{}&nbsp;and&nbsp;{}GML Code{}. See&nbsp;{}GameMaker Language{} for more information.":"在这一点上，你可能会被要求在&nbsp;{}GML Visual{}&nbsp;和&nbsp;{}GML Code{}之间选择。请参阅&nbsp;{}GameMaker语言{}了解更多信息。",
    "Event Order":"事件顺序",
    "Finally we have another section to the mouse events which is called the {}Global Mouse{}. In this sub-menu you will find a selection of events that are for recording mouse events in instances even when the mouse is not over them or even near them. These are events that are generated for {}all {}instances and if there are actions or code defined for the specified event then it will be run, regardless of the position of the mouse within the game room.":"最后，我们还有一个鼠标事件的部分，叫做{}全局鼠标{}。在这个子菜单中，你会发现有一些事件是用来记录实例中的鼠标事件的，即使鼠标不在它们上面，甚至不在它们附近。这些事件是为{}所有{}实例生成的，如果有为指定事件定义的动作或代码，那么它将被运行，无论鼠标在游戏中的位置如何。",
    "Finally, it should be noted that all collisions will be calculated once per game step before the collision event is triggered, such that when the collision event runs, all collisions will have been calculated already and pre-assigned. This means that if you create an instance in this event and then try to check for a collision with it, the collision wont be detected or resolved until the next {}iteration{} of the game loop.":"最后，应该注意的是，在碰撞事件被触发之前，所有的碰撞将在每个游戏步骤中被计算一次，这样，当碰撞事件运行时，所有的碰撞都已经被计算并预先分配了。这意味着，如果你在这个事件中创建了一个实例，然后试图用它来检查碰撞，那么在游戏循环的下一次{}迭代{}之前，碰撞将不会被检测到或解决。",
    "For most things the standard step event will be fine to use, but sometimes you want a bit more control over what code runs and at what time, so for that you are provided with the {}Begin {}and {}End {}step events. All three are checked every step, but their order will never vary even if future updates to the {}GameMaker{} engine change other events, which means that this is the only reliable method of making sure that something always happens before something else.":"对于大多数情况，使用标准步骤事件都很好，但有时您需要对运行的代码和运行时间进行更多控制，因此为您提供了{}开始{}和{}结束{}步骤事件。每一步都会检查这三个事件，但它们的顺序永远不会改变，即使将来对{}GameMaker{}引擎的更新更改了其他事件，这意味着这是唯一可靠的方法来确保某件事总是在另一件事之前发生。",
    "For&nbsp;{}GML Visual{} users, adding a comment requires the use of the&nbsp;{}Execute Code{}&nbsp;action, which should be placed at the very top of the actions for the event, before everything else. When you add this action, you then give it the same line of code that is shown above to name the event, e.g.:":"对于&nbsp;{}GML Visual{}用户来说，添加注释需要使用&nbsp;{}Execute Code{}&nbsp;动作，这个动作应该放在事件的动作的最上面，在所有其他动作之前。当你添加这个动作时，你再给它加上上面显示的那行代码，以命名该事件，例如。",
    "If you have {}Physics {}on, then the collision will be based on the type of {}collision shape{} ({}Fixture{}) that you have defined for the object in its physics properties, as will its reaction to the collision. This means you may not need any code to deal with the collision, but this event will still {}need to have at least a comment in it {}for the collisions to be detected.":"如果{}物理{}是启用的，那么碰撞将基于你在物体的物理属性中为其定义的{}碰撞形状{}（{}Fixture{}）的类型，以及它对碰撞的反应。这意味着你可能不需要任何代码来处理碰撞，但这个事件仍然{}需要至少有一个注释在里面{}，以便检测碰撞。",
    "In beta versions, this list also contains the {}Rollback Start{} and {}Rollback Event{} events.":"在测试版中，此列表还包含{}回滚开始{}和{}回滚事件{}事件。",
    "It is designed for you to use to \"clean up\" any dynamic resources that you may have in your game (like surfaces, data structures, etc...) or to perform any task that you need performed {}once {}when the instance is removed from the game in any way.":"它被设计用于\"清理\"游戏中可能存在的任何动态资源(如表面、数据结构等)，或者在实例以任何方式从游戏中移除时执行需要执行{}一次{}的任何任务。",
    "It is worth noting that an alarm with no actions or code in it in it will {}not {}count down. However, even with just a comment and no code or actions, then the alarm will continue to count down and can be set and checked as you would normally.":"值得注意的是，一个没有任何动作或代码的计时器将{}不会{}倒数。但是，如果 只有注释，没有代码或动作，那么计时器也会继续倒计时，可以像平时一样进行设置和检查。",
    "It should be noted that keyboard events are actually triggered in all active instances in a room whenever a key is used, but only those that have an event defined for that particular key will respond and you can create multiple keyboard events in any object and the instances of that object will respond to all of them while the game is running.":"应该注意的是，每当使用一个键时，键盘事件实际上会在房间里的所有活动实例中被触发，但只有那些为该特定键定义了事件的实例才会做出反应，你可以在任何对象中创建多个键盘事件，在游戏运行时，该对象的实例会对所有事件做出反应。",
    "Let\u0027s look at a typical object setup with events and code:":"让我们看看一个有事件和代码的典型对象设置。",
    "Letting the player control the different aspects of your game is very important, and to that end {}GameMaker{} provides you with a very comprehensive list of keyboard events that can be used in any of the three main keyboard categories. For the general Keyboard category, it is triggered continuously&nbsp;every step&nbsp;for as long as the selected key is pressed down, while the Press and Release category events will only be triggered once when the key is initially pressed down or released.":"让玩家控制你游戏的不同方面是非常重要的，为此{}GameMaker{}为你提供了一个非常全面的键盘事件列表，可以在三个主要的键盘类别中的任何一个使用。对于一般的键盘类别，只要选定的键被按下，它就会被连续触发&nbsp;每一步&nbsp;，而按压和释放类别的事件只会在最初按压或释放键时被触发一次。",
    "Note that the above is simply an overview of how the Asynchronous Event works, but for full details on all the available sub-events, please see the following section:":"请注意，以上只是对异步事件如何工作的概述，但关于所有可用的子事件的完整细节，请参见下面的章节。",
    "Note that the above is simply an overview of how the Draw Events work, but for full details on all the available sub-events, please see the following section:":"请注意，以上只是对Draw Events工作方式的概述，但关于所有可用的子活动的全部细节，请参见以下章节。",
    "Note that this event will be called {}instantly {}after the event that triggered it, but the instance will not actually be removed from the game {}until the end of the current event{}. For example, if you call {}instance_destroy(){} in the Step Event, then the Destroy Event will be called, then the Clean Up Event, and then {}the rest of the Step Event will finish running{}. This means that any code you have after the call to {}instance_destroy(){} will still be run and be a potential cause for errors if you\u0027ve cleaned up a data structure or some other resource that the code requires, so care must be taken when using this event.":"请注意，此事件将在触发它的事件之后{}立即{}被调用，但直到当前{}事件结束时，实例才会实际从游戏中{}移除。例如，如果您在Step Event中调用{}instance_destroy(){}，则会调用Destroy Event，然后是Clean Up Event，然后{}步骤事件的其余部分将完成运行{}。这意味着在调用{}instance_destroy(){}之后，您拥有的任何代码仍将运行，并且如果您已经清理了代码所需的数据结构或其他资源，则可能会导致错误，因此在使用此事件时必须小心。",
    "Object Events":"对象事件",
    "Obviously when making a game, it is very important that you know when two (or more) instances of an object have collided, and for that we have the {}Collision Event{}. This is an event that you place in an object and then specify against which other object you should be checking for collisions.":"显然，在制作游戏时，你必须知道一个物体的两个（或多个）实例发生了碰撞，为此我们有{}碰撞事件{}。这是一个你放置在一个对象中的事件，然后指定你应该针对哪个其他对象来检查碰撞。",
    "Once the alarm has reached 0 and run the code, it will then count down to -1, where it will remain until set again (meaning you can check the value of an alarm to see if it is greater than -1, which will tell you if it\u0027s running or not). So, say you set {}alarm[0]{} in the create event of the object to 30, this means that {}GameMaker{} will count down 30 game steps before it runs the actions or code that are placed in the {}alarm[0]{} event. Note that setting an alarm to 0 will {}not {}run the alarm code, as the event is triggered, but the alarm is set to -1 immediately, so the code is skipped. If you need an alarm to run the very next step, then you should set it to 1.":"一旦计时器达到0并运行代码，它就会倒数到-1，在那里它将一直保持，直到再次设置（意味着你可以检查计时器的值是否大于-1，这将告诉你它是否正在运行）。所以，假设你在对象的创建事件中把{}alarm[0]{}设置为30，这意味着{}GameMaker{}将在运行放在{}alarm[0]{}事件中的动作或代码之前倒数30步。注意，将计时器设置为0将{}不会{}运行计时器代码，因为虽然事件被触发了，但计时器被立即设置为-1，所以代码被跳过。如果你需要一个计时器来运行下一个步骤，那么你应该把它设置为1。",
    "Once you have selected your event, the event\u0027s editor window&nbsp;will be chained to it and open up on the right.":"一旦你选择了你的事件，事件的编辑窗口&nbsp;将被链到它，并在右边打开。",
    "Please note that on mobile or touch-screen devices the left mouse button {}&nbsp;can also be used to check for a finger tab on a touch screen, and the right mouse button {}&nbsp;is triggered by a double tap on the screen (this behaviour can be changed using code).":"请注意，在移动或触摸屏设备上，鼠标左键{}&nbsp;也可以用来检查触摸屏上的手指，而鼠标右键{}&nbsp;是由双击屏幕触发的（这个行为可以用代码改变）。",
    "Remember that you can modify anything you set up in the Create Event from the {}Instance Creation Code{}&nbsp;in the Room Editor, as that is run directly after the create event for the instance and can be used to create {}Instance Variables{}&nbsp;or to override any variables added as Object Variables or in the actual Create Event.":"记住，你可以从房间编辑器中的{}实例创建代码{}&nbsp;中修改你在创建事件中设置的任何内容，因为那是在实例的创建事件之后直接运行的，可以用来创建{}实例变量{}&nbsp;或覆盖作为对象变量或在实际创建事件中添加的任何变量。",
    "So, say you want to add an image file to {}GameMaker{}. Well, you would code this in another event (maybe the Create Event) of an object and then have that object draw a loading bar while waiting (for example), polling the appropriate asynchronous event until the {}callback{} that tells {}GameMaker{} the file has loaded. You can then use the data returned in this event to do other things, like change room, or purchase an item.":"所以，说你想添加一个图像文件到{}GameMaker{}。那么，你可以在一个对象的另一个事件（也许是创建事件）中编码，然后让这个对象在等待时画一个加载条（例如），轮询适当的异步事件，直到告诉{4}GameMaker{5}文件已加载的{}回调{}。然后你可以使用这个事件中返回的数据来做其他事情，比如换房间，或者购买物品。",
    "So, what are object {}events{}? Basically, these are discreet moments in the game loop where things are made to happen based on what you have programmed for them. {}GameMaker{} works with cycles of these events - from the moment a room is started to the moment it is finished there is a game loop running where every {}step {}a series of events are run or checked, and you can choose to place code or GML Visual actions in your objects that respond to these events (a step is a moment in game time, governed by the room speed setting, and can also be called a {}frame{}) .":"那么，什么是对象{}事件{}？基本上，这些都是游戏循环中的独立时刻，在这些时刻，事情会根据你的编程而发生。{}GameMaker{}在这些事件的循环中工作--从一个房间开始到结束，有一个游戏循环在运行，每{}步{}都有一系列的事件被运行或检查，你可以选择在你的对象中放置代码或GML Visual动作来响应这些事件（一个步骤是游戏时间的一个时刻，由房间速度设置决定，也可以称为{}帧{}）。",
    "So, what are {}Object Events{}? Basically, these are discreet moments in the game loop where things are made to happen based on what you have programmed for them. {}GameMaker{} works with cycles of these events - from the moment a room is started to the moment it is finished there is a game loop running where every {}step {}a series of events are run or checked, and you can choose to place&nbsp;{}GML Code{} or {}GML Visual{}&nbsp;actions in your objects that respond to these events (a step is a moment in game time, governed by the&nbsp;{}Game Frames Per Second{} setting, and can also be called a {}frame{}).":"那么，什么是{}对象事件{}？基本上，这些都是游戏循环中的谨慎时刻，事情会根据你为它们编程的内容发生。{}GameMaker{}与这些事件的循环一起工作-从房间开始的那一刻到它结束的那一刻，有一个游戏循环在运行，每一{}步{}都会运行或检查一系列事件，您可以选择将{}GML代码{}或{}GML视觉{}动作放置在响应这些事件的对象中({}每秒游戏帧数{}是游戏时间中的一个时刻，由每秒游戏帧数设置控制，也可以称为{}帧{})。",
    "So, you could have something like this in - for example - an {}Alarm {}event:":"因此，你可以在--例如--一个{}计时器{}事件中拥有这样的东西。",
    "The Async Events":"异步事件",
    "The Draw Event":"绘制事件",
    "The Draw Events":"绘制事件",
    "The Gesture Event":"手势事件",
    "The Gesture Events":"手势事件",
    "The Mouse category is separated into a series of events that can be selected to give you a more precise control over what is happening in your game. Here you can see exactly what these events are:":"鼠标类别被分成一系列的事件，可以选择这些事件来给你一个更精确的控制你的游戏中发生的事情。在这里你可以看到这些事件到底是什么。",
    "The Other Events":"其他事件",
    "The alarm category is split into 12 events, one for each of the possible alarms that can be set in an instance. So, when you click on the {}Add Alarm {}category you are presented with this window:":"计时器类别被分成12个事件，每个事件对应一个实例中可能设置的计时器。因此，当你点击{}添加计时器{}类别时，你会看到这个窗口。",
    "The full list of events is given below:":"事件的完整列表如下:",
    "The gesture events&nbsp;detect&nbsp;the following:":"手势事件&nbsp;检测&nbsp;如下。",
    "The mouse enter and leave events are also similar to the button events in that they too rely on the mask of the instance to work, but this time they are triggered when the mouse first \"enters\" (touches) the instance or when the mouse \"leaves\" (stops touching) the instance. These events are not continuous however, and are triggered only once for each time the mouse enters or leaves the object - so they are an ideal method for creating, for example, buttons that need to change as the mouse hovers over them before going back to normal when the mouse is removed.":"鼠标进入和离开事件也与按钮事件类似，它们也依赖于实例的掩码来工作，但这次它们是在鼠标第一次 \"进入\"（触摸）实例或鼠标 \"离开\"（停止触摸）实例时触发的。然而，这些事件不是连续的，每当鼠标进入或离开对象时只被触发一次--所以它们是一种理想的方法，例如，创建需要在鼠标悬停时改变的按钮，当鼠标移开时又恢复正常。",
    "The standard draw events draw {}before {}the {}Draw GUI {}events and {}between {}the {}Pre Draw {}and {}Post Draw {}events, meaning that everything that is drawn in this event is drawn beneath that of the {}Draw GUI {}event, regardless of the layer (ie: anything drawn in the Draw GUI event will always be drawn over anything drawn in the normal draw event, regardless of layer order).":"标准的绘制事件是在{}绘制GUI{}事件{0}之前{1}和{}Pre Draw{}和{}Post Draw{}事件{4}之间{5}，这意味着在这个事件中绘制的所有东西都在{}绘制GUI{}事件的下面，而不考虑图层（即：在绘制GUI事件中绘制的东西总是在普通绘制事件中绘制的东西上面，而不考虑图层顺序）。",
    "The step event is actually comprised of three sub events that are outlined below:":"步骤事件实际上由三个子事件组成，概述如下。",
    "The {}Press {}and {}Release {}events for the keyboard are almost exactly the same as the regular keyboard event, except that instead of being triggered continuously, they are triggered once only. When the keyboard first registers that a key has been pressed it will generate a {}Keyboard Pressed{} event (as well as a regular Keyboard event), and the first time after that where a key is no longer being detected as pressed it will trigger a single {}Keyboard Release{} event.":"键盘的{}Press {}和{}Release {}事件与常规键盘事件几乎完全相同，只是它们不是连续触发，而是只触发一次。当键盘第一次记录到一个键被按下时，它将产生一个{}键盘按下{}事件（以及一个常规的键盘事件），之后第一次不再检测到一个键被按下时，它将触发一个{}键盘释放{}事件。",
    "There are a number of special events for use when making games with {}GameMaker{} and they are mostly grouped together under the Other event and can be selected from the pop up menu of sub events that comes up when you select this. Here is an image of all these other events:":"在用{}GameMaker{}制作游戏时，有一些特殊的事件，它们大多被分组在其他事件下，可以从你选择这个时出现的子事件的弹出菜单中选择。下面是所有这些其他事件的图片。",
    "This can be very useful as it allows you to set things in motion at precise moments, and you can even have them repeat as there is nothing to stop you setting an alarm in its own event. Imagine you have a monster and you want it to turn right every three seconds... well, you would set an alarm in its create event to the room speed * 3 (if the room speed is 30, that\u0027s 30 steps per second, so multiply that by 3 and you get 3 seconds!) and then in the alarm event you would have the code or action to set its direction, as well as the action (or code) to set its alarm to room speed * 3&nbsp;again. In this way, you can set up simple game loops where things only happen at specific intervals.":"这可能非常有用，因为它允许你用精确的时刻设置事物的运动，你甚至可以让它们重复，因为没有什么可以阻止你在计时器的事件中设置一个计时器。想象一下，你有一个怪物，你想让它每隔三秒钟向右转......好吧，你可以在它的创建事件中设置一个计时器，以room_speed*3（如果房间速度是30，那就是每秒30步，所以乘以3，你就得到了3秒！）然后在计时器事件中，你会有代码或动作来设置它的方向，以及动作（或代码）来设置其计时器为房间速度*3&nbsp；再者。通过这种方式，你可以设置简单的游戏循环，事情只在特定的时间间隔发生。",
    "This event category is special in that the events it contains are not triggered by default by {}GameMaker{}, but rather by the end of some other action, like the loading of a file, or the reply from a web server. The category is split into the following events:":"这个事件类别很特别，因为它所包含的事件不是由{}GameMaker{}默认触发的，而是由其他一些动作的结束而触发的，比如加载一个文件，或者来自网络服务器的回复。该类别被分割成以下事件。",
    "This event category is the one that governs what you see on the screen when you run your game, and is split into various discreet events:":"这个事件类别是支配你在运行游戏时在屏幕上看到的东西，它被分成各种不相关的事件。",
    "This event happens when an instance of the object is first created, and is the very first thing that happens within an instance placed in the room through the Room Editor when a room is entered. This means that this event is the ideal place to initialize {}variable{}{}s{}, start {}Timelines{}, set {}Paths{}&nbsp;etc... and do anything else that generally only needs to be done once or only when an instance is first created in the room. If your object has any {}Object Variables{} or {}Instance Variables{} added in either the Object Editor or the Room Editor, then these variables will be initialised first and then the {}Create Event{} will be run.":"这个事件发生在对象的一个实例被首次创建时，也是通过房间编辑器放置在房间里的实例在进入房间时发生的第一件事。这意味着该事件是初始化{}变量{}{}{}、启动{}时间线{}、设置{}路径{}&nbsp;等......以及其他任何通常只需要做一次或只在房间中首次创建实例时做的事情的理想场所。如果你的对象在对象编辑器或房间编辑器中添加了任何{}对象变量{}或{}实例变量{}，那么这些变量将首先被初始化，然后{}创建事件{}将被运行。",
    "This event is the event to be executed when an instance is destroyed. It is often overlooked when adding behaviours to objects, but it can be very useful, for example by creating explosion or particle effects when an enemy is killed, or for re-spawning a new instance of the object in another part of the room, or even for adding points onto a score.":"这个事件是一个实例被销毁时要执行的事件。在给对象添加行为时，它经常被忽略，但它可以非常有用，例如，当敌人被杀死时，它可以产生爆炸或粒子效果，或者在房间的另一个地方重新生成对象的新实例，甚至可以在分数上加分。",
    "This event is the one that will be triggered by the user touching the screen (on mobile) or clicking and moving the mouse (on all other platforms). These events are similar to the mouse events, in that you have regular versions and&nbsp;{}global{}&nbsp;versions. The regular versions of these events will only be triggered when the touches occur on an instance that has a sprite (or a mask) and the touches occur within its {}bounding box{}. The global versions of these events, however, will be triggered by the user touching {}anywhere {}on the screen.":"这个事件是由用户触摸屏幕（在手机上）或点击并移动鼠标（在所有其他平台上）而触发的。这些事件类似于鼠标事件，你有常规版本和{}全局{}&nbsp;版本。这些事件的常规版本只有在触摸发生在有精灵（或掩码）的实例上，并且触摸发生在其{}边界框{}内时才会被触发。然而，这些事件的全局版本将由用户在屏幕上的任何地方触摸{}而触发。",
    "This event will be called after any event that removes an instance of the object from the room. So, it will be triggered if:":"此事件将在任何从房间中删除对象实例的事件之后调用。因此，如果出现以下情况，则会触发此事件：",
    "What can the step event be used for? Well, it can be used for actions or code that needs to be executed continuously. For example, if one object should follow another, here you can adapt the direction of motion towards the object we are following to keep it moving smoothly behind. Be careful with this event though, and don\u0027t put many complicated actions in the step event of objects, especially if you are planning on having lots of instances of the object in your game room, as this might slow the game down. Many things can be placed into alarms, or set to trigger using some of the {}Other {}events, rather than happening all the time.":"步骤事件可以用来做什么？嗯，它可以用于需要连续执行的动作或代码。例如，如果一个物体应该跟随另一个物体，在这里你可以对我们所跟随的物体的运动方向进行调整，以保持它在后面平稳地移动。不过要小心处理这个事件，不要在物体的步骤事件中放入很多复杂的动作，尤其是当你打算在游戏室里有很多物体的实例时，因为这可能会使游戏变慢。许多事情都可以放入计时器，或者使用一些{}其他{}事件设置为触发，而不是一直发生。",
    "When removing events, you can use {}&nbsp;+ {}&nbsp;to select multiple events and then delete them all together. Each object you create has its own discreet list of events which are added into it from {}The Object Editor{}. These events fall into two categories:":"删除事件时，您可以使用{}+{}选择多个事件，然后将它们一起删除。您创建的每个对象都有自己的独立事件列表，这些事件是从{}对象编辑器{}添加到其中的。这些事件分为两类：",
    "When removing events, you can use {}&nbsp;+ {}&nbsp;to select multiple events and then delete them all together.Each object you create has its own discreet list of events which are added into it from the {}Object Editor{}. These events fall into two categories:":"当删除事件时，你可以使用{}&nbsp;+ {}&nbsp;来选择多个事件，然后将它们全部删除。你创建的每个对象都有自己的事件列表，这些事件由{}对象编辑器{}添加到其中。这些事件可分为两类。",
    "When you add any keyboard event to an object, you will be presented with the keyboard sub event menu where you can specify the key you are to be checking for:":"当你向一个对象添加任何键盘事件时，你会看到键盘子事件菜单，你可以指定你要检查的键:",
    "When you don\u0027t have physics turned on, these collisions will be calculated based on the mask of the two objects (the mask is defined within the sprite properties, or can be assigned independently in the object properties) and whether they overlap or not. Note, that if one or the other instances in the collision does not have a mask assigned (or the sprite mask is set to nothing), {}even if it is drawing something{} no collisions will be detected.":"当你没有开启物理时，这些碰撞将根据两个物体的遮罩（遮罩在精灵属性中定义，或者可以在物体属性中独立分配）以及它们是否重叠来计算。请注意，如果碰撞中的一个或另一个实例没有分配掩码（或者精灵掩码被设置为无），{}即使它正在绘制什么东西{}也不会被检测到碰撞。",
    "You can click the right mouse button {}&nbsp;on any event that has been added to an object to get the following menu options:":"你可以在任何已添加到对象的事件上点击鼠标右键{}&nbsp;，以获得以下菜单选项。",
    "You can now edit the GML code (or blocks) to give your object a specific behaviour or reaction to that event.":"现在你可以编辑GML代码（或代码块），给你的对象一个特定的行为或对该事件的反应。",
    "You can now edit the {}GML Code{}&nbsp;(or blocks) to give your object a specific behaviour or reaction to that event.":"现在，您可以编辑{}GML代码{}(或块)，以给予对象对该事件的特定行为或反应。",
    "You should also note that you can name events, or at least give them a short descriptive text that will be shown beside them in the Event Editor. To do this, simply add the following into the very first line of the code editor for the event (when using {}GML Code{}):":"你还应该注意，你可以给事件命名，或者至少给它们一个简短的描述性文本，在事件编辑器中显示在它们旁边。要做到这一点，只需在事件的代码编辑器的第一行添加以下内容（当使用{}GML代码{}时）。",
    "the game ends":"游戏结束",
    "the instance is destroyed":"实例被销毁",
    "the room ends":"房间结束了",
    "those that are \"triggered\" by a game event, like the instance reaching the room edge or a keyboard or mouse press.":"那些由游戏事件 \"触发 \"的事件，如实例到达房间边缘或按下键盘或鼠标。",
    "those that run every single game step":"那些运行每帧都运行的",
    "{}&nbsp;{}drags {}- when a user touches/clicks and maintains it then moves their finger/cursor":"{}&nbsp;{}拖动 {}- 当用户触摸/点击并保持，然后移动他们的手指/光标时",
    "{}&nbsp;{}flicks {}- when the user moves and releases a touch/click in one movement":"{}&nbsp;{}滑动{}- 当用户在一个动作中移动和释放触摸/点击时",
    "{}&nbsp;{}pinches {}- when the user has two fingers on the screen and then moves them together/apart":"{}&nbsp;{}夹开{}--当用户在屏幕上有两个手指，然后一起/分开移动它们时",
    "{}&nbsp;{}rotates {}- when the user has two fingers on the screen and then rotates them around a point":"{}&nbsp;{}旋转{}--当用户在屏幕上有两个手指，然后围绕一个点旋转时。",
    "{}&nbsp;{}taps {}- when a user clicks/touches and releases quickly":"{}&nbsp;{}点击 {}- 当用户点击/触摸并迅速释放时",
    "{}/// @description This is the AI Fight alarm{}":"{}/// @description 这个是AI战斗用的计时器{}",
    "{}Add Event{} - Add a new event from the event list.":"{}添加事件{} - 从事件列表中添加一个新事件。",
    "{}Alarm{}{}Alarm{}":"{}计时器{}{}计时器{}",
    "{}As you can see in our example object there are a number of events listed that it should respond to, but initially when you create an object this list is empty and you must decide which events you need and what instances of that object should do when those events are triggered. To add events into the object, you press the {}Add Event{} button found at the bottom of the events list which will bring up the following window:":"{}正如你所看到的，在我们的例子对象中，列出了一些它应该响应的事件，但最初当你创建一个对象时，这个列表是空的，你必须决定你需要哪些事件，以及当这些事件被触发时该对象的实例应该做什么。要将事件添加到对象中，你可以按下事件列表底部的{}添加事件{}按钮，这将带来以下窗口。",
    "{}As you can see in our example object there are a number of events listed that it should respond to, but initially when you create an object this list is empty and you must decide which events you need and what instances of that object should do when those events are triggered. To add events into the object, you press the {}Add Event{} button found at the bottom of the events list which will bring up the following window:&nbsp;":"{}As你可以看到在我们的例子对象中列出了许多它应该响应的事件，但是最初当你创建一个对象时，这个列表是空的，你必须决定你需要哪些事件以及当这些事件被触发时该对象的实例应该做什么。要向对象中添加事件，按下事件列表底部的{}添加事件{}按钮，将弹出以下窗口：",
    "{}As you can see, the draw event category has multiple different event types. {}Draw Begin{}, {}Draw {}and {}Draw End{} are the \"standard\" draw events which you will probably use most. By default the main Draw event is always called for every instance, regardless of whether it has a sprite or not, although if you flag the instance as invisible, the event will not be triggered (so keep this in mind if you have any game logic in the draw event of an invisible object, as it won\u0027t run). The main draw event is also where {}GameMaker{} default draws the instance sprite when there is no code nor actions in the event (ie: you haven\u0027t added it into the event list for the object). Default drawing uses the sprite associated with the instance and will draw that with any transforms set in code or actions applied.":"{}正如你所看到的，绘制事件类别有多种不同的事件类型。{}Draw Begin{}、{}Draw {}和{}Draw End{}是 \"标准 \"的绘制事件，你可能最常使用。默认情况下，每一个实例都会被调用主绘制事件，不管它是否有精灵，不过如果你将实例标记为不可见，该事件将不会被触发（所以如果你在不可见对象的绘制事件中设置了任何游戏逻辑，请记住这一点，因为它不会运行）。主绘制事件也是{}GameMaker{}默认绘制实例精灵的地方，当事件中没有代码或动作时（即：你没有把它添加到对象的事件列表中）。默认绘制使用与实例相关联的精灵，并将在代码中设置的任何转换或应用的动作中绘制。",
    "{}Asynchronous{}{}Asynchronous{}":"{}异步{}{}异步{}",
    "{}Change Event{} - Change the event. This will prompt you to choose another event category and once selected the contents of the current event will be changed to the new event (removing the original event in the process).":"{}更改事件{} - 更改事件。这将提示您选择另一个事件类别，一旦选定，当前事件的内容将被改变为新的事件（在此过程中删除原事件）。",
    "{}Clean Up{}{}Clean Up{}":"{}清理{}{}清理{}",
    "{}Collision{}{}Collision{}":"{}碰撞{}{}碰撞{}",
    "{}Convert To GML Visual / Code{} - Object events will be created using the method chosen when you created the project, either using GML Code or GML Visual actions. With this option you can convert from one to the other, regardless of the project type.":"{}转换为 GML 可视化 / 代码 {}- 对象事件将使用您在创建项目时选择的方法创建，使用 GML 代码或 GML 可视化操作。使用此选项，您可以从一个转换为另一个，而不考虑项目类型。",
    "{}Convert To GML Visual / Code{} - Object events will be created using the method chosen when you created the project, either using code or using GML Visual actions. With this option you can convert from one to the other, regardless of the project type.":"{}Convert To GML Visual / Code{} - 对象事件将使用你创建项目时选择的方法创建，可以使用代码或使用GML Visual动作。有了这个选项，你可以从一个转换到另一个，不管项目类型如何。",
    "{}Convert To GML Visual / Code{} - Object events will be created using the method chosen when you created the project, either using {}GML Code{}&nbsp;or {}GML Visual{}&nbsp;actions. With this option you can convert from one to the other, regardless of the project type.":"{}转换为GML Visual / Code{}-将使用创建项目时选择的方法创建对象事件，可以使用{}GML Code{}或{}GML Visual{}操作。使用此选项，您可以从一种方法转换为另一种方法，而不考虑项目类型。",
    "{}Create{}{}Create{}":"{}创建{}{}创建{}",
    "{}Cut {}/ {}Copy {}/ {}Paste Events{} - Cut, copy or paste the selected event. You can use the standard keyboard shortcuts too: {}&nbsp;/&nbsp;{} + {}X{}, {}&nbsp;/&nbsp;{}&nbsp;+ {}C{}, and {}&nbsp;/&nbsp;{}&nbsp;+ {}V{}.":"{}剪切{}/ {}复制{}/ {}粘贴事件{} - 剪切、复制或粘贴所选事件。你也可以使用标准的键盘快捷键：{}&nbsp;/&nbsp;{}+ {}X{}, &nbsp，{}&nbsp;/&nbsp;{}&nbsp;+{}C{}，以及{}&nbsp;/&nbsp;{}&nbsp;+{}V{}。",
    "{}Delete Event{} - Delete the event (or events).":"{}删除事件{} - 删除事件（或多个事件）。",
    "{}Destroy{}{}Destroy{}":"{}销毁{}{}销毁{}",
    "{}Draw{}{}Draw{}":"{}绘制{}{}绘制{}",
    "{}Duplicate Event{} - Duplicate the chosen event. This will take the contents of the chosen event and duplicate them in another event that you specify.":"{}重复事件{} - 重复所选事件。这将把所选事件的内容复制到你指定的另一个事件中。",
    "{}For additional information on some of the above events and general event running order, please see the following sections:":"{}关于上述一些活动的其他信息和一般活动的运行顺序，请见以下章节：",
    "{}For more information on each of the events listed in the image above, please see the following section:":"{}关于上面图片中列出的每个事件的更多信息，请参见以下部分。",
    "{}For most things the standard step event will be fine to use, but sometimes you want a bit more control over what code runs and at what time, so for that you are provided with the {}Begin {}and {}End {}step events. All three are checked every step, but their order will never vary even if future updates to the {}GameMaker{} engine change other events, which means that this is the only reliable method of making sure that something always happens before something else.":"{}对于大多数事情来说，使用标准的步骤事件就可以了，但有时你想更多地控制什么代码在什么时间运行，所以我们为你提供了{}Begin {}和{}End {}step事件。这三个事件每一步都会被检查，但它们的顺序永远不会改变，即使将来{}GameMaker{}引擎的更新改变了其他事件，这意味着这是唯一可靠的方法，可以确保某些事情总是发生在其他事情之前。",
    "{}GameMaker{} splits time into {}steps {}with the game speed defining how many of these steps there are supposed to be per second (a step can also be called a {}frame{}). A single step, is basically the loop that runs constantly with all the events being checked and triggered as necessary while the game runs, so as you can imagine, the {}Step Event {}is an event that is checked every single step of the game while the instance exists.":"{}GameMaker{}将时间划分为{}步{}，游戏速度定义了每秒应该有多少步(一个步骤也可以被称为{}帧{})。一个步骤，基本上是一个循环，不断运行的所有事件被检查和触发的必要，而游戏运行，所以你可以想象，{}步骤事件{}是当实例存在时在游戏的每一步都检查的事件。",
    "{}GameMaker{} splits time into {}steps {}with the room speed defining how many of these steps there are supposed to be per second (a step can also be called a {}frame{}). A single step, is basically the loop that runs constantly with all the events being checked and triggered as necessary while the game runs, so as you can imagine, the {}Step Event {}is an event that is checked every single step of the game while the instance exists.":"{}GameMaker{}将时间分成{}步{}，房间的速度定义了每秒应该有多少步（一个步骤也可以称为{}帧{}）。一个步骤，基本上是在游戏运行时不断检查和触发所有事件的循环，所以你可以想象，{}步骤事件{}是一个在实例存在时每一步游戏都要检查的事件。",
    "{}Gestures{}{}Gestures{}":"{}手势{}{}手势{}",
    "{}Here you select the alarm that you wish to create and, once that is done, you will see that it has been added to the event window allowing you to add code to it as normal. But what is an alarm? Well, it is a special event that does nothing unless the alarm has been previously set, and then it will wait until that alarm has counted down to 0 before running the actions or code that you have added into it.":"{}在这里，你选择你想创建的计时器，一旦完成，你会看到它已经被添加到事件窗口，允许你像平常一样向它添加代码。但什么是计时器打响？嗯，它是一个特殊的事件，除非事先设置了计时器，否则它不会做任何事情，它将等待计时器倒计时到0，然后再运行你添加到它的动作或代码。",
    "{}It is designed for you to use to \"clean up\" any dynamic resources that you may have in your game (like surfaces, data structures, etc...) or to perform any task that you need performed {}once {}when the instance is removed from the game in any way.{}":"{}它是为你设计的，用来 \"清理 \"你游戏中的任何动态资源（比如表面、数据结构等），或者执行任何你需要执行的任务，{}一旦{}实例以任何方式从游戏中删除。{}",
    "{}Keyboard Press,{}{}Keyboard Press,{}":"{}键盘按下,{}{}键盘按下,{}",
    "{}Keyboard Release{}{}Keyboard Release{}":"{}键盘松开{}{}键盘松开{}",
    "{}Keyboard,{}{}Keyboard,{}":"{}键盘,{}{}键盘,{}",
    "{}Most of them are fairly obvious, but let\u0027s just go through the sections briefly - at the top we have the arrow keys, followed by the most used modifier keys, then the rest of the keyboard (split into further sub-sections so you can get the exact key required like {}&nbsp;or&nbsp;{}) and finally two very special sub events, {}No Key{} and {}Any Key{}. As their names imply, these are sub events that check for when {}no {}key is pressed or for when {}any {}key is pressed. Please note that the keys on the numeric keypad only produce the corresponding events when {}Number Lock {}is enabled.":"{}它们中的大多数是相当明显的，但让我们简单地浏览一下这些部分--在顶部我们有方向键，其次是最常用的修改键，然后是键盘的其他部分（分成更多的子部分，这样你就可以得到所需的确切键，如{}&nbsp;或&nbsp;{}），最后是两个非常特殊的子事件，{}No Key{}和{}Any Key{}。正如它们的名字所暗示的，这些是检查{}无{}键被按下时或{}任何{}键被按下时的子事件。请注意，数字键盘上的按键只有在{}数字锁{}被启用时才会产生相应的事件。",
    "{}Mouse{}{}Mouse{}":"{}鼠标{}{}鼠标{}",
    "{}NOTE{}&nbsp;Instances in a room are created in a certain {}order{}, and their Create events are also executed as they are created one-by-one. This means that you must be careful when reading variables from other instances in the Create event, as that other instance may not have run its Create event yet!{} {} For example: let\u0027s say {}ObjectA{} is created before {}ObjectB{}, and you have the following code in those objects\u0027 Create events:{} {} {}ObjectA {}Create -&nbsp;{}myValue = objectB.myValue;{}{} {}ObjectB {}Create -&nbsp;{}myValue = 10;{}{} {} ObjectA is created first and its Create event runs, which then crashes the game:{} {} {}{}\"Variable objectB.myValue(100003, -2147483648) not set before reading it.\"{}{}{} {} That\u0027s simply because ObjectB has not even been created yet, so any variables initialised in its Create event do not yet exist. This is why you must take caution when referencing other instances&nbsp;like this in the Create event, including any code run inside {}{}with(){}{} blocks. ":"{}注意{}&nbsp;房间中的实例是按照一定的{}顺序{}创建的，它们的创建事件也是在逐一创建时执行的。这意味着，当你在创建事件中从其他实例中读取变量时，必须小心谨慎，因为其他实例可能还没有运行其创建事件！{} {} 例如：假设{}ObjectA{}在{}ObjectB{}之前被创建，而你在这些对象的创建事件里有以下代码：{} {} {}ObjectA {}Create -&nbsp;{}myValue = objectB.myValue;{}{} {}ObjectB {}Create -&nbsp;{}myValue = 10;{}{} {} ObjectA先被创建，它的创建事件运行，然后游戏崩溃：{} {} {}{}\"Variable objectB.myValue(100003, -2147483648) not set before reading it.\"{}{}{} {} 这只是因为ObjectB还没有被创建，所以在其创建事件中初始化的任何变量还不存在。这就是为什么当你在创建事件中引用其他实例&nbsp;时必须谨慎，包括在{}{}with(){}{}块内运行的任何代码。 ",
    "{}Note that this event will be called {}instantly {}after the event that triggered it, but the instance will not actually be removed from the game {}until the end of the current event{}. For example, if you call {}instance_destroy(){} in the Step Event, then the Destroy Event will be called, then the Clean Up Event, and then {}the rest of the Step Event will finish running{}. This means that any code you have after the call to {}instance_destroy(){} will still be run and be a potential cause for errors if you\u0027ve cleaned up a data structure or some other resource that the code requires, so care must be taken when using this event.{} ":"{}注意，这个事件将在触发它的事件之后{}立即{}被调用，但实例实际上不会被从游戏中移除{}，直到当前事件结束{}。例如，如果你在步骤事件中调用{}instance_destroy(){}，那么Destroy事件将被调用，然后是Clean Up事件，然后{}步骤事件的其余部分将完成运行{}。这意味着你在调用{}instance_destroy(){}之后的任何代码仍然会被运行，如果你已经清理了数据结构或其他一些代码需要的资源，则会成为潜在的错误原因，所以在使用这个事件时必须小心谨慎。{}",
    "{}Open Parent Event{} - Open the inherited event in the parent object.":"{}打开父事件 {}- 在父对象中打开继承的事件。",
    "{}Other{}{}Other{}":"{}其他{}{}其他{}",
    "{}Show Parent Event{} - View the inherited event from the parent in a read-only mode.":"{}显示父事件 {}- 以只读模式查看从父事件继承的事件。",
    "{}Step{}{}Step{}":"{}步{}{}步{}",
    "{}The different events will always contain a DS Map called the \"{}event_data{}\" map, which will contain a number of key/value pairs with data on the touch/click position and movement. For full details on all the available sub-events and how they work, please see the following section:":"{}不同的事件总是包含一个名为\"{}event_data{}\"的DS地图，它将包含一些带有触摸/点击位置和移动数据的键/值对。关于所有可用的子事件以及它们如何工作的全部细节，请参见以下章节。",
    "{}The left {}, right {}&nbsp;and middle {}&nbsp;button events (whether {}normal{}, {}pressed {}or {}released{}) all work on the mask of the instance that has the event. What this means is that {}GameMaker{} will check the position of the mouse in the room when those buttons are used against the collision masks of the instances that have a mouse event. If there is a \"collision\" with the instance {}bounding box{}&nbsp;then the event will be triggered, so make sure that any instance with these events has a sprite with a valid collision mask or that the object has a mask sprite selected in the object properties. As their names imply, these events will be triggered either once when the chosen mouse button is first pressed or released, or continuously each step while the button is maintained.":"{}左边{}，右边{}   和中间{}   按钮事件(无论是{}正常{}的，{}按下{}或{}释放{})都对具有事件的实例的遮罩起作用。这意味着当这些按钮被用于具有鼠标事件的实例的碰撞遮罩时，{}GameMaker{}将检查鼠标在房间中的位置。如果与实例{}边界框{}有\"碰撞\"，则事件将被触发，因此，请确保具有这些事件的任何实例都有一个带有有效碰撞遮罩的精灵，或者对象有一个在对象属性中选择的遮罩精灵。正如它们的名称所暗示的那样，这些事件将在第一次按下或释放所选鼠标按钮时触发一次，或者在按钮保持不变的每一步中连续触发。",
    "{}The left {}, right {}&nbsp;and middle {}&nbsp;button events (whether {}normal{}, {}pressed {}or {}released{}) all work on the mask of the instance that has the event. What this means is that {}GameMaker{} will check the position of the mouse in the room when those buttons are used against the collision masks of the instances that have a mouse event. If there is a \"collision\" with the instance {}bounding box{}&nbsp;then the event will be triggered, so make sure that any instance with these events has a sprite with a valid collision mask or that the object has a mask sprite selected in the object properties. As their names imply, these events will be triggered either once when the chosen mouse button is first pressed or released, or continuously each step while the button is maintained. ":"{}左{}、右{}&nbsp;和中{}&nbsp;按钮事件（无论是{}normal{}、{}pressed {}还是{}released{}）都对拥有该事件的实例的掩码起作用。这意味着，{}GameMaker{}在使用这些按钮时，会对照有鼠标事件的实例的碰撞掩码，检查鼠标在房间里的位置。如果与实例{}碰撞箱{}&nbsp;发生了 \"碰撞\"，那么事件就会被触发，所以要确保任何有这些事件的实例都有一个具有有效碰撞遮罩的精灵，或者该对象在对象属性中选择了一个遮罩精灵。正如它们的名字所暗示的，这些事件将在所选的鼠标按钮首次按下或释放时被触发一次，或者在按钮保持的每一步都被连续触发。",
    "{}These options are:":"{}这些选项是：",
    "{}This event will be called after any event that removes an instance of the object from the room. So, it will be triggered if:{}":"{}这个事件将在任何从房间中移除对象的实例的事件之后被调用。因此，它将被触发，如果：{}",
    "{}This is the list of all the basic events and event categories which an object can respond to, and within each category are sub events to further refine behaviours. For example, if you click on the {}K{}{}ey Press{} {}&nbsp;event category you will then get a further window popping up with the events that allow you to select {}which {}key the object should respond to.":"{}这是一个对象可以响应的所有基本事件和事件类别的列表，每个类别中都有子事件来进一步细化行为。例如，如果你点击{}K{}{}ey Press{} {}&nbsp;事件类别，你就会弹出一个进一步的窗口，让你选择{}对象应该对哪个{}键做出响应。",
    "{}the game ends{}":"{}游戏结束{}",
    "{}the instance is destroyed{}":"{}该实例被销毁{}",
    "{}the room ends{}":"{}进入别的房间{}",
    "{}{}IMPORTANT{}{}&nbsp;{}GameMaker{}&nbsp;won\u0027t perform keyboard and mouse events when&nbsp;{}The Debug Overlay{}&nbsp;is open and has taken over keyboard and/or mouse input.&nbsp;{}Simulating Keypresses{}&nbsp;will also not execute events. You can, however, still use the&nbsp;{}Keyboard Input{}&nbsp;and&nbsp;{}Mouse Input{}&nbsp;functions in the Step event, for example, to check for input. You can also still perform an event\u0027s code using the {}{}event_perform{}{}&nbsp;function and its relatives.":"{}{}重要{}{} 当{6}调试覆盖层{7}打开并接管键盘和/或鼠标输入时，{}GameMaker{}不会执行键盘和鼠标事件。{}模拟按键{}也不会执行事件。但是，您仍然可以在Step事件中使用{}键盘输入{}和{}鼠标输入{}功能，例如，检查输入。您还可以使用{}{}event_perform{}{}功能及其类似的。",
    "{}{}NOTE{}{}&nbsp;First, all instances run their {}Begin Step{} event. Then, all instances run their {}Step{} event. After that, all instances run their {}End Step{} event.":"{}{}注意{}{}首先，所有实例运行其{}开始步骤{}事件。然后，所有实例运行其{}步骤{}事件。之后，所有实例运行其{}结束步骤{}事件。",
    "{}{}NOTE{}{}&nbsp;On mobile or touch-screen devices the left mouse button {}&nbsp;can also be used to check for a finger tab on a touch screen, and the right mouse button {}&nbsp;is triggered by a double tap on the screen (this behaviour can be changed using code).":"{}{}注意{}{}在移动的或触摸屏设备上，鼠标左键{}也可用于检查触摸屏上的手指标签，鼠标右键{}由双击屏幕触发(可使用代码更改此行为)。"
}