{
    "As mentioned previously, a persistent object will only run its&nbsp;{}Create Event{}&nbsp;{}once{}, but it will also&nbsp;have its {}Game Start{}, {}Game End{}, {}Room Start{} and {}Room End{} events triggered at the appropriate times. However if you restart the game (with, for example, the {}game_restart(){} function) {}all persistent objects will be removed and only exist when created again by the game{}.{} {} Also note that if you {}deactivate {}a persistent object, it will no longer pass from one room to another unless re-activated before the {}Room End{} event is triggered. Re-activation {}requires a full game step to occur{}, so using the actual {}Room End{} event for this does not work, as it doesn\u0027t give the game a full step to reactivate the object, so you need to keep this in mind when using deactivation along with persistent objects and plan your code accordingly. ":"如前所述，持久对象只会运行其 {}创建事件{} {}一次{}，但它也会在适当的时间触发其{}游戏开始{}、{}游戏结束{}、{}房间开始{}和{}房间结束{}事件。但是，如果您重新启动游戏(例如，使用{}game_restart(){}函数){}所有持久对象将被移除，仅当游戏重新创建时才会存在。{}{}{}还请注意，如果您{}停用{}持久对象，它将不再从一个房间传递到另一个房间，除非在触发{}房间结束{}事件之前重新激活。重新激活{}需要执行完整的游戏步骤{}，因此使用实际的{}房间结束{}事件不起作用，因为它不会为游戏提供重新激活对象的完整步骤，因此在将停用与持久对象一起使用时，您需要记住这一点，并相应地规划您的代码。",
    "Beneath the sprite assignment area you have a button for choosing a specific {}Collision Mask{}. By default an object will generate collision properties based off of the sprite assigned to it, but there are cases whereby you may want collisions to be based off a different shape from a different sprite. For example, you may have a top down game where the main sprite has a rectangular collision mask, but to make collisions smoother a circular mask may be better. In these cases you can click the Collision Mask button and select another sprite resource, so now instances of the object will {}draw {}the assigned sprite, but base {}collisions {}off of the mask sprite. You can find out more information about collision masks from the page on the {}Sprite Editor{}.":"在精灵分配区下面有一个按钮，可以选择一个特定的{}碰撞遮罩{}。默认情况下，一个物体会根据分配给它的精灵产生碰撞属性，但在某些情况下，你可能希望 碰撞是基于不同精灵的不同形状。例如，你可能有一个自上而下的游戏，主精灵有一个长方形的碰撞掩码，但为了使碰撞更平滑，圆形掩码可能更好。在这种情况下 你可以点击碰撞遮罩按钮并选择另一个精灵资源，所以现在对象的实例将{}绘制{}指定的精灵，但基于{}碰撞{}的遮罩精灵。你可以在碰撞的页面上找到更多关于碰撞 遮罩的更多信息，请参见{}精灵编辑器{}页面。",
    "Here you are presented with the following options for your object:{}{}":"这里你会看到你的对象有以下选项：{}{}",
    "Here you can give your object a name. This name should never contain spaces nor unauthorized characters (only alpha-numeric characters and the underbar \"_\" are allowed) and should be short but memorable so that you can easily identify resources later when you may have many of them. For example many people use a prefix or a suffix to identify the differences between resources, like \"{}obj_Ship{}\" or \"{}Ship_obj{}\".":"在这里你可以给你的对象一个名字。这个名字不应包含空格或未经授权的字符（只允许使用字母数字字符和下划线\"_\"），而且应该简短但易于记忆，以便以后当你可能有很多资源时，你可以很容易地识别它们。 当你可能有许多资源时，你可以很容易地识别它们。例如，许多人使用前缀或后缀来识别资源之间的差异，如\"{}obj_Ship{}\"或\"{}Ship_obj{}\"。",
    "Next you can choose the sprite for the object should you wish it to have one. Click with the left mouse button {}&nbsp;on the sprite box and the {}Asset Explorer{} will appear with a list of all the available sprites from the Asset Browser:":"接下来你可以选择对象的精灵，如果你希望它有一个。用鼠标左键{}&nbsp;点击精灵框，{}资源资源管理器{}将出现资源浏览器的所有可用精灵列表。",
    "Object Events":"对象事件",
    "Object Variables":"对象变量",
    "Parent Objects":"父对象",
    "Physics Objects":"物理物体",
    "The Object Editor":"对象编辑器",
    "The last part of the Object Editor is taken up with the different object&nbsp;{}Options{}, each of which is discussed on its on page, linked below:":"对象编辑器的最后一部分是不同的对象&nbsp;{}选项{}，每个选项都在其页面上讨论，链接如下。",
    "To clarify this, think of a game made with {}GameMaker{}. All the characters, monsters, balls, walls, etc... are all objects you create in the {}Asset Browser{}. You then drag the {}object {}into a room in the {}Room Editor{} to create an {}instance {}copied from the basic object template. The instance in the room can then be changed in the editor itself or through code, so that it can be scaled, or coloured, or have other details modified from the \"base\" object. So when we talk about something affecting or changing an {}instance{}, we mean it affects that {}one particular copy of an object in a room{}. Only that single instance is being affected while all the rest are not. But, when we talk about affecting or changing an {}object{}, we mean that we are modifying the object in the Asset Browser and anything we do to it will be reflected in all the instances created from that point on too. So, the object is the template for the instance, and the instance is what we place in a room to make our game.":"为了说清楚这一点，想想一个用{}GameMaker{}制作的游戏。所有的角色、怪物、球、墙等等......都是你在{}资源浏览器{}中创建的对象。然后你在{}房间编辑器{}中把{4}对象{5}拖入房间，创建一个从基本对象模板复制的{}实例{}。然后，房间里的实例可以在编辑器本身或通过代码进行更改，这样它就可以被缩放，或着色，或从 \"基本 \"对象中修改其他细节。因此，当我们谈论影响或改变一个{}实例{}的东西时，我们的意思是它会影响{}房间里的一个特定对象的副本{}。只有那个单一的实例受到影响，而其他的都没有受到影响。但是，当我们谈论影响或改变一个{}对象{}时，我们的意思是，我们正在修改资源浏览器中的对象，我们对它所做的任何事情都将反映在从这一点开始创建的所有实例上。所以，对象是实例的模板，而实例就是我们放在房间里做游戏的东西。",
    "To create an object in your game, you can right click {}&nbsp;on the Asset Browser and click the {}Create Object{} option. This will open the window pictured at the top of this page with the following sections:":"要在你的游戏中创建一个对象，你可以在资源浏览器上右击{}&nbsp;，然后点击{}创建对象{}选项。这将打开本页面顶部的窗口，其中有以下几个部分。",
    "When you create an instance with persistence enabled in a room, it will be assigned a layer or a depth (depending on which function you used to create the instance of the object). When the room is changed, and if the following room does not have a layer with the same name or depth as the one assigned, then{} a new layer will be created for the instance that is persisting across the rooms{}. If you gave a named layer when the instance was created, then the new layer will also be named the same as original layer, while if you assigned a depth to the instance then the new layer will be named \"{}_layer_XXX{}\", where \"{}XXX{}\" is a hex value used to give the layer a unique name. These layers will be removed from the room on {}Room End{}.{} {} Another thing to note about layers and persistent instances is that if you have assigned the instance a named layer on creation, and there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with the same name regardless of the depth of the layer.{} {} Finally, if a persisted instance moves to a room with a layer at the {}same{} depth as the instance was created on, it will {}not {}be assigned to this layer, but instead a new layer will be created at the same depth (following the naming convention explained above). ":"当您在房间中创建启用了持久化的实例时，会为其分配一个层或深度(具体取决于您创建对象实例时使用的函数)。当房间更改时，如果下面的房间没有与分配的名称或深度相同的层，则会{}为跨房间持久化的实例创建一个新层{}。如果在创建实例时指定了一个命名的层，则新层的名称也将与原始层相同，而如果为实例指定了深度，则新层将被命名为\"{}_layer_XXX{}\"，其中\"{}XXX{}\"是用于为层指定唯一名称的十六进制值。这些层将从{}房间结束{}上的房间中移除。{}{}有关层和持久化实例的另一点需要注意的是，如果您在创建时为实例分配了命名层，并且后续房间中有另一个同名层，则持久化实例将被分配到同名的层，而不考虑层的深度。{}{}最后，如果持久化实例移动到与创建实例的深度{}相同{}的层所在的房间，则{}不会{}将其分配给该层。但是，将在相同深度创建一个新的层(遵循上面解释的命名约定)。",
    "{}Collision Mask{}{}Collision Mask{}":"{}碰撞遮罩{}{}碰撞遮罩{}",
    "{}Details{}{}Details{}":"{}详情{}{}详情{}",
    "{}Managed{}: Whether this object should be managed when using&nbsp;Rollback Multiplayer.&nbsp;A managed object\u0027s state can be {}rolled back{} and predictions can be run on it. This feature is currently in beta versions only.":"{}托管{}：使用回滚多人时是否管理该对象。托管对象的状态可以{}回滚{}，并可以对其运行预测。该功能目前仅在测试版中提供。",
    "{}Managed{}: Whether this object should be managed when using&nbsp;{}Rollback Multiplayer.{}&nbsp;A managed object\u0027s state can be {}rolled back{} and predictions can be run on it. This feature is currently in beta versions only.{} See&nbsp;{}Managed Objects{}.{}":"{}托管{}：使用{}回滚多人{}时是否管理该对象。托管对象的状态可以{}回滚{}，并可以对其运行预测。该功能目前仅在测试版中提供。{}请参阅{}托管对象{}{}",
    "{}Objects are the resource that we use to control aspects of a game and to do specific things. Most of the time they have a sprite associated with them so that you see them in the game rooms, but sometimes they are used as a \"behind the scenes\" controller to do things related to the user or for timing, etc... They can be given behaviours and they can react to certain events as well as to each other, and most of the things you see in a game are based on objects and their interactions. Now, we say \"based on\" because you don\u0027t actually place objects directly into the game rooms, but rather you place {}instances{} of these objects which are basically copies (or clones if you prefer) of the object resource. This is a very important thing to remember as instances and objects {}are not the same thing{} and each have their own set of functions that can affect them.":"{}对象是我们用来控制游戏的各个方面和做特定事情的资源。大多数时候，它们有一个与之相关的精灵，以便你在游戏室中看到它们，但有时它们被用作 \"幕后 \"控制器，以做与用户有关的事情或用于计时，等等。它们可以被赋予行为，它们可以对某些事件作出反应，也可以对彼此作出反应，你在游戏中看到的大多数东西都是基于物体和它们的相互作用。现在，我们说 \"基于\"，是因为你实际上并没有直接将物体放入游戏房间，而是将这些物体的{}实例{}放入游戏房间，它们基本上是物体资源的副本（或克隆，如果你愿意）。这是一件非常重要的事情，因为实例和对象{}不是同一种东西{}，它们各自有自己的一套可以影响它们的功能，所以要记住这一点。",
    "{}Persistence And Events{}{}Persistence And Events{}":"{}持久性和事件{}{}持久性和事件{}",
    "{}Persistence And Room Layers{}{}Persistence And Room Layers{}":"{}持久性和房间层{}{}持久性和房间层{}",
    "{}Persistent{}: A persistent object is one that does not go away when the room is changed, but rather it \"persists\" and is carried over into the new room. It will only disappear when you explicitly destroy it, either with a destroy action or in code. This means that if you place a persistent object in one room, it will still be available in all subsequent rooms and will continue to perform any actions assigned to the events in its object properties, {}except {}the {}Create Event{}, which is only fired {}once {}when it is created initially and not when you change to a new room. This is handy for when you have, for example, a main character that moves from room to room and you want to maintain the variables within the instance the same, but you should take great care to create and destroy persistent objects correctly as you can easily get errors creeping into your project by mistake.":"{}持久{}：持久对象是指当房间被改变时，它不会消失，而是 \"持久化 \"并被带入新的房间。它只有在你明确地销毁它时才会消失，无论是用销毁动作还是在代码中。这意味着，如果你把一个持久化的对象放在一个房间里，它仍然可以在所有后续的房间里使用，并将继续执行分配给其对象属性中的事件的任何动作，{}除了{}{}创建事件{}，它只在最初创建时被触发{}一次{}，而不是当你改变到一个新房间时重新触发。当你有一个从一个房间移动到另一个房间的主角，并且你想保持实例内的变量不变时，这很方便，但你应该非常小心地正确创建和销毁持久化对象，因为你很容易让你的项目中出现错误。",
    "{}Properties{}{}Properties{}":"{}属性{}{}属性{}",
    "{}Solid{}:&nbsp;When you flag an instance as being solid, you are telling {}GameMaker{} that it should try to resolve any collisions before triggering a {}Collision Event{}. This is a very basic functionality, and in reality all it does is move the instance back to the position it was in the moment before a collision was detected before performing any code or GML Visual that is in the Collision Event itself, and as such is of limited use.":"{}实体{}: 当你把一个实例标记为实体时，你是在告诉{}GameMaker{}，它应该在触发{}碰撞事件{}之前尝试解决任何碰撞。这是一个非常基本的功能，实际上它所做的只是在执行碰撞事件本身的任何代码或GML 可视化之前，将实例移回检测到碰撞前的位置，因此用途有限。",
    "{}The Object Editor{}":"{}对象编辑器{}",
    "{}Uses Physics{}: When you check the Uses Physics box you are telling {}GameMaker{} that this object should be part of a physics world (as set in the {}{}{}Room Editor{}. Checking this will also open a further chained window where you can define the physical properties of all instances of this object. More information on this can be found in the section on {}Physics Objects{}.":"{}使用物理{}：当您选中使用物理框时，您就是在告诉{}GameMaker{}该对象应该是物理世界的一部分(在{}{}{}房间编辑器{}中设置)。选中此选项还将打开另一个链接窗口，您可以在其中定义此对象的所有实例的物理属性。有关这方面的更多信息，请参阅{}物理对象{}一节。",
    "{}Visible{}: Visible indicates whether instances of this object are visible when the room starts. Normally most instances are visible but sometimes it is useful to have invisible ones - for example, you can use them for way-points to control a moving monster, or to keep track values and perform certain timed actions. Invisible objects will still react to events and if they have a sprite or a mask assigned to them, they will also react should other instances collide with them... they just cannot be seen and do {}not {}perform their {}Draw Event{}. By default, the visible flag is checked.{}{}":"{}可见{}：可见表示房间启动时该对象的实例是否可见。通常情况下，大多数实例都是可见的，但有时不可见的实例也很有用--例如，你可以用它们作为控制移动中的怪物的路标，或者保持跟踪值并执行某些定时的动作。不可见的对象仍然会对事件做出反应，如果它们有一个精灵或面具分配给它们，如果其他实例与它们发生碰撞，它们也会做出反应......它们只是不能被看到，也{}不会{}执行它们的{}绘制事件{}。默认情况下，可见标志被选中。{}{}",
    "{}You can then select the one you want to use for the object. With a sprite assigned to the object you can click the {}Edit Sprite{} button {}&nbsp;to change the {}sprite properties{}, or - if you do not have a sprite for the object but wish to create one - you can click the {}Add Sprite{} button {}&nbsp;to create a new sprite asset and assign that. You can also edit the sprite asset image that has been assigned by clicking the {}Edit Image{} button {}&nbsp;to open the {}Image Editor{}.":"{}然后你可以选择你想为该对象使用的精灵。在为对象分配了精灵后，你可以点击{}编辑精灵{}按钮{}&nbsp;来改变{}精灵属性{}，或者--如果你没有对象的精灵，但希望创建一个--你可以点击{} 添加精灵{}按钮{}&nbsp;来创建一个新的精灵资源并分配给它。你也可以通过点击{}编辑图像{}按钮{}来编辑已经分配的精灵资源图像并打开{}图像编辑器{}。"
}