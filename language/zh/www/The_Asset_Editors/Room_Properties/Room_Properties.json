{
    "A camera view is defined by two different sets of values, the camera view itself and the port on the screen where this view is to be drawn. This can sometimes cause confusion so let\u0027s explain this a bit before explaining how we define each of them:":"摄像机视图由两组不同的值定义，摄像机视图本身和屏幕上绘制该视图的端口。这有时会导致混淆，所以在解释如何定义它们之前，让我们先解释一下：",
    "A room has to have a size and this is defined by the values that you input for its width and height in pixels.":"房间必须有大小，这是由您为其宽度和高度输入的值(以像素为单位)定义的。",
    "After that you have the option to {}Clear Display Buffer{}. This option, when checked, pre-fills the {}display buffer{} with a colour before drawing anything else for a particular frame. If you know that your views are going to be covering the whole screen at all times or that you have a fullscreen, opaque background being drawn, then you can un-check this, which saves a redraw and so helps optimise your game.":"之后，您可以选择{}清除显示缓冲区{}。如果选中此选项，则在为特定帧绘制任何其他内容之前，会使用颜色预先填充{}显示缓冲区{}。如果你知道你的视窗将一直覆盖整个屏幕，或者你有一个全屏的，不透明的背景被绘制，那么你可以取消选中这个选项，这样可以节省重画，从而帮助优化你的游戏。",
    "Before you can use the built in physics functions in your games, you must tell {}GameMaker{} that the room is a physics room. To do this, you must tick the option to {}Enable Physics {}at the top of the {}Room Physics{}&nbsp;section (you can also toggle the inheritance of this section independently of the rest of the room settings). Once you have done that you can then continue on to set up the physics world properties, which are some basic properties that you must have pre-defined before your room will allow physics instances to work as such. For a more precise control over the world you can use code (see the {}Physics Functions{}&nbsp;for more information).":"在您的游戏中使用内置物理功能之前，您必须告诉 {}GameMaker{} 该房间是一个物理室。为此，您必须勾选 {} 房间物理 {} 部分顶部的 {} 启用物理 {} 选项 (您也可以独立于其他房间设置切换此部分的继承)。完成此操作后，您可以继续设置物理世界属性，这些属性是一些基本属性，您必须先预定义这些属性，然后您的房间才能允许物理实例按此方式工作。为了更精确地控制世界，你可以使用代码 (有关更多信息，请参阅 {} 物理函数 {})。",
    "Camera and View Port Properties":"相机和视口属性",
    "Cameras And Viewports":"摄影机和视口",
    "Cameras also have the {}Object Following {}option. This is for when you want the camera to \"follow\" (i.e. maintain the view focused on) a certain object. To do this you must click {}&nbsp;on the menu icon and select an object from the list that pops up (if there are multiple instances of this object in the room, only one of them is followed by the camera). The camera will now keep track of the x and y position of that instance to follow it.":"相机还具有 {} 对象跟随 {} 选项。这适用于当您希望相机 \" 跟随 \"( 即保持视图聚焦) 某个对象时。为此，您必须点击菜单图标上的 {}，然后从弹出的列表中选择一个对象 (如果房间中有该对象的多个实例，则摄像机仅跟踪其中一个)。相机现在将跟踪该实例的 x 和 y 位置以跟随它。",
    "Cameras, Views and View Ports":"相机、视图和视口",
    "Clear Display Buffer":"清除显示缓冲区",
    "Finally you can indicate the {}horizontal{}&nbsp;and {}vertical speed {}at which the camera moves when the character has reached the buffer zone, and this has a default value of -1. This default value is basically \"instantaneous\" and means that the moment the follow instance is outside the horizontal border or vertical border buffer zone, the view will skip to its current position. Now, this is not always what you want and so you can set the vertical and horizontal scrolling speed for the camera by setting the values to something other than -1. Note that a value of 0 will cause the view to not move at all, and any other positive value is how many pixels it will move in any frame, so setting the horizontal speed to 5 will have the view follow the object at 5 pixels per frame horizontally.":"最后，您可以指示角色到达缓冲区时摄影机移动的{}水平{}和{}垂直速度{}，其默认值为-1。这个缺省值基本上是\"瞬时\"的，意味着当下面的实例超出水平边框或垂直边框缓冲区时，视图将跳到其当前位置。现在，这并不总是您想要的，因此您可以通过将值设置为-1以外的值来设置相机的垂直和水平滚动速度。请注意，值为0将导致视图完全不移动，任何其他正值都是它将在任何帧中移动的像素数，因此将水平速度设置为5将使视图以每帧5像素的水平方向跟随对象。",
    "Finally you can indicate the&nbsp;{}horizontal{}&nbsp;and {}vertical speed {}at which the camera moves when the character has reached the buffer zone, and this has a default value of -1. This default value is basically \"instantaneous\" and means that the moment the follow instance is outside the horizontal border or vertical border buffer zone, the view will move. Now, this is not always what you want and so you can set the vertical and horizontal scrolling speed for the camera by setting the values to something other than -1. Note that a value of 0 will cause the view to not move at all, and any other positive value is how many pixels it will move in any frame, so setting the horizontal speed to 5 will have the view follow the object at 5 pixels per frame horizontally.":"最后，您可以指定角色到达缓冲区时相机移动的 {} 水平 {} 和 {} 垂直速度 {}，默认值为 -1。这个默认值基本上是 \" 瞬时 \" 的，意味着当跟随实例超出水平边界或垂直边界缓冲区时，视图就会移动。现在，这并不总是您想要的，因此您可以通过将值设置为 -1 以外的值来设置相机的垂直和水平滚动速度。请注意，值为 0 将导致视图根本不移动，任何其他正值都是它将在任何帧中移动多少像素，因此将水平速度设置为 5 将使视图以每帧 5 像素的速度跟随对象水平框架。",
    "Finally you must set the ratio of{} Pixels To Meters{} for {}GameMaker{} to use as a base for all its physics calculations. This is because the physics functions work on real-world measurements, which is why we must set this value, and you\u0027ll want to adjust this setting until the average pixel size of the objects you are using translates roughly into simulated physics objects of an appropriate size.":"最后，您必须为 {}GameMaker{} 设置 {} 像素与米{}的比率，以用作其所有物理计算的基础。这是因为物理函数适用于真实世界的测量，这就是我们必须设置此值的原因，您需要调整此设置，直到您正在使用的对象的平均像素大小大致转换为适当大小的模拟物理对象。",
    "For clearing views, please see {}Clear Viewport Background{}.":"有关清除视图，请参阅{}清除视窗背景{}。",
    "However if you have multiple views that, when on-screen leave open spaces, or your background has transparent parts - you can check this so any empty areas&nbsp;are filled in with the draw colour of your choice.&nbsp;Currently this colour can only be set through code using {}{}window_set_colour(){}{}.":"但是，如果您有多个视图，当屏幕上留有空白处，或者您的背景有透明部分时-您可以选中此选项，以便使用您选择的绘制颜色填充任何空白区域。 目前，此颜色只能通过代码使用{}{}window_set_color(){}{}进行设置。",
    "Instance Creation Order":"实例创建顺序",
    "It should be noted that enabling physics in a room means that all physics enabled instances in the room&nbsp;{}must use the physics functions and variables to move{}. Basically, you have \"traditional\" movement, where you can set the X/Y position of an instance or set its speed and direction, and then you have the \"physics\" movement, which requires physical forces and impulses to move around. These systems are {}mutually exlusive{}, and you cannot move a physics instance using non-physics functions and you cannot move a non-physics instance using the physics functions.":"需要注意的是，在房间中启用物理意味着房间中所有启用物理的实例都{}必须使用物理函数和变量来移动{}。基本上，你有\"传统的\"移动，你可以设置一个实例的X/Y位置或设置它的速度和方向，然后你就有了\"物理\"移动，它需要物理力和脉冲来四处移动。这些系统是{}互不相关的{}，您不能使用非物理函数移动物理实例，也不能使用物理函数移动非物理实例。",
    "Normally, when you leave a room and return to the same room later, that room is reset to its initial settings. This is usually fine for most games but it may not be what you want in, for example, an RPG or any non-linear game, where you want to come and go between rooms and have them be the way you left it the last time. Checking the box labelled {}Persistent {}will do exactly that. The room status will be remembered and when you return to it later, it will be exactly the same as you left it, with it only being reset to the start state when the game is restarted. Note that there is {}one {}exception to this - if you marked certain objects as being persistent, instances of this object will {}not {}stay in the room but move to the next room.":"通常，当您离开房间并稍后返回同一房间时，该房间将被重置为其初始设置。这通常适用于大多数游戏，但它可能不是你想要的，例如，RPG或任何非线性游戏，在这些游戏中，你想在房间之间来回穿梭，让它们保持上次离开时的样子。选中标记为{}持续{}的框就可以做到这一点。房间状态将被记住，当您稍后返回它时，它将与您离开它时完全相同，只有在游戏重新开始时才会重新设置为开始状态。请注意，这有{}一个{}例外--如果您将某些对象标记为永久对象，则此对象的实例将{}不会{}留在房间中，而会移动到下一个房间。",
    "Object Following":"物体跟随",
    "Persistent":"持续",
    "Please realise that the overall screen area is {}always defined as a rectangular area{}, so your ports, even when offset, will form a rectangle, with any empty spaces being filled in by the window colour of the {}display buffer{}, meaning that in these circumstances you should always have {}Clear Display Buffer{} checked or else you will get odd artefacts drawn in the spaces between ports. The image below illustrates this, where there are two offset view ports visible, yet they make a square window, and \"underneath\" there are lines being drawn to the display buffer:":"请注意，整个屏幕区域{}始终定义为矩形区域{}，因此您的端口即使在偏移时也会形成一个矩形，任何空白区域都将由{}显示缓冲区{}的窗口颜色填充，这意味着在这些情况下，您应该始终选中{}清除显示缓冲区{}，否则您将在端口之间的空间中绘制奇怪的人工制品。下图说明了这一点，其中有两个可见的偏移视图口，但它们形成了一个正方形窗口，并且在其下面绘制了到显示缓冲区的线：",
    "Room Physics":"房间物理",
    "Room Properties":"房间属性",
    "The camera view is always defined as a rectangular area in the room, where you specify the position of the top-left corner, the width and the height of this area. Then you must specify where this area is shown in the window on the screen by defining the view port, where again you specify the position of the top-left corner and the size (note that anything other than 0,0 for the top left corner can give strange results). You can have more than one port and they can overlap, in which case they are drawn in the indicated order one on top of the other.":"摄像机视图始终定义为房间中的一个矩形区域，您可以在其中指定左上角的位置、该区域的宽度和高度。然后，您必须通过定义视区来指定此区域在屏幕窗口中的显示位置，并再次在其中指定左上角的位置和大小 (请注意，左上角不是 0，0 的任何值都可能产生奇怪的结果)。您可以有多个端口，并且它们可以重叠，在这种情况下，它们将按指定的顺序一个在另一个的上方绘制。",
    "The final button in the Room Properties permits you to open the {}Instance Creation Order{} window:":"房间属性中的最后一个按钮允许您打开{}实例创建顺序{}窗口：",
    "The next set of properties for the room that you can define are those relating to the room&nbsp;{}Camera{}&nbsp;and&nbsp;{}Viewports{}.&nbsp;Camera views give a mechanism for drawing different parts of your room at different places on the screen, or for drawing just a part of your room to cover the whole screen. For example, in most platform games, the camera view follows the main character, as, if you could see the whole level on the screen, your character would be too small to see and there would be no surprises for the player. Camera views can also be used in multi-player games or co-op games, as they permit you to create a split-screen setup in which in one part of the screen you see one player and in another part you see the other player. This can all be easily achieved in {}GameMaker{} using camera views.":"您可以为房间定义的下一组属性是与房间{}相机{}和{}视口{}. 相机视图相关的属性，这些属性提供了一种机制，用于在屏幕上的不同位置绘制房间的不同部分，或仅绘制房间的一部分以覆盖整个屏幕。例如，在大多数平台游戏中，相机视图跟随主要角色，因为如果你可以在屏幕上看到整个关卡，你的角色会太小而看不到，对玩家来说不会有任何惊喜。摄像机视图也可以用于多人游戏或合作游戏，因为它们允许您创建一个分屏设置，在屏幕的一个部分可以看到一个玩家，在另一个部分可以看到另一个玩家。这一切都可以在使用摄像头视图的{}GameMaker{}中轻松实现。",
    "The normal behaviour for a camera is to only move when the instance being followed gets too close to a \"buffer\" zone that makes an invisible boundary around the edge of the view. This zone can be defined by you using the {}Horizontal Border {}and {}Vertical Border {}values, so - for example - setting these values to 64 will mean that the view will not start to move and follow the character until it reaches 64 pixels from the edge of the view.":"摄影机的正常行为是，只有当被跟踪的实例太靠近在视图边缘形成不可见边界的\"缓冲区\"时才移动。您可以使用{}水平边框{}和{}垂直边框{}值来定义该区域，因此，例如，将这些值设置为64将意味着，在距离视图边缘达到64像素之前，视图不会开始移动和跟随字符。",
    "The normal behaviour for a camera is to only move when the instance being followed gets too close to a \"buffer\" zone that makes an invisible boundary around the edge of the view. This zone can be defined by you using the {}Horizontal Border {}and {}Vertical Border {}values, so - for example - setting these values to 64 will mean that the view will not start to move and follow the character until it reaches 64 pixels from the edge of the view. The exact point that is checked against this buffer zone is the point at the&nbsp;{}x{} and&nbsp;{}y{} position for the instance being followed, and it does not make use of its {}mask{}.":"相机的正常行为是仅在所跟踪的实例太靠近 \" 缓冲区 \" 区域 (该区域在视图边缘周围形成不可见边界) 时才移动。您可以使用 {} 水平边框 {} 和 {} 垂直边框 {} 值来定义该区域，因此，例如，将这些值设置为 64 将意味着视图不会开始移动并跟随角色，直到角色移动为止。距离视图边缘达到 64 像素。针对此缓冲区检查的确切点是所跟踪实例的 {}x{} 和 {}y{} 位置处的点，并且不使用其 {} 掩码 {}。",
    "Width, Height &amp; Creation Code":"宽度、高度和创建代码",
    "Width, Height &amp; Other Options":"宽度、高度和其他选项",
    "You can then add the&nbsp;{}Creation Code{}, should you require it. Creation code is added from the button at the bottom (along with the inherit toggle to say whether the room should inherit it\u0027s creation code or not), and if you click it you will open a code or visual&nbsp;editor. This editor allows you to input functions/actions and code that will be run at the {}start {}of the room, after the create event of all instances but before their room start event (for more information on event order, please see {}here{}). This code will run every time you enter the room, unless the room is flagged as persistent, in which case it will only be run once when the room is first entered, but not on subsequent visits to the room.":"然后，如果需要，您可以添加 {}创建代码{}。创建代码是从底部的按钮添加的(与继承切换一起，表示房间是否应该继承它的创建代码)，如果您单击它，您将打开一个代码或可视化编辑器。通过该编辑器，您可以输入在房间开始时、所有实例的创建事件之后、房间{}开始{}事件之前运行的函数/动作和代码(有关事件顺序的更多信息，请参阅{}此处{})。此代码将在您每次进入房间时运行，除非房间被标记为持久的，在这种情况下，它将只在第一次进入房间时运行一次，而不是在以后访问房间时运行。",
    "You can then add the&nbsp;{}{}{}Room Creation Code{}, should you require it. Creation code is added from the button at the bottom (along with the inherit toggle to say whether the room should inherit it\u0027s creation code or not), and if you click it you will open a code or visual&nbsp;editor. This editor allows you to input functions/actions and code that will be run at the {}start {}of the room, after the create event of all instances but before their room start event (for more information on event order, please see {}here{}). This code will run every time you enter the room, unless the room is flagged as persistent, in which case it will only be run once when the room is first entered, but not on subsequent visits to the room.":"然后，如果需要，您可以添加{}{}{}房间创建代码{}。创建代码是从底部的按钮添加的(与继承切换一起，表示房间是否应该继承它的创建代码)，如果您单击它，您将打开一个代码或可视化编辑器。通过该编辑器，您可以输入在房间开始时、所有实例的创建事件之后、房间{}开始{}事件之前运行的函数/动作和代码(有关事件顺序的更多信息，请参阅{}此处{})。此代码将在您每次进入房间时运行，除非房间被标记为持久的，在这种情况下，它将只在第一次进入房间时运行一次，而不是在以后访问房间时运行。",
    "You can then add the&nbsp;{}{}{}Room Creation Code{}, should you require it. Creation code is added from the button at the bottom (along with the inherit toggle to say whether the room should inherit its creation code or not), and if you click it you will open a code or visual&nbsp;editor. This editor allows you to input functions/actions and code that will be run at the {}start {}of the room, after the create event of all instances but before their room start event (for more information on event order, please see {}here{}). This code will run every time you enter the room, unless the room is flagged as persistent, in which case it will only be run once when the room is first entered, but not on subsequent visits to the room.":"然后，您可以根据需要添加 {}{}{} 房间创建代码 {}。创建代码是从底部的按钮添加的 (以及继承切换来说明房间是否应该继承其创建代码)，如果单击它，您将打开一个代码或可视化编辑器。此编辑器允许您输入将在房间的 {} 开始 {}、所有实例的创建事件之后但其房间开始事件之前运行的函数 / 操作和代码 (有关事件顺序的更多信息，请参阅 {} 这里 {})。此代码将在您每次进入房间时运行，除非该房间被标记为持久，在这种情况下，它只会在第一次进入房间时运行一次，但不会在后续访问该房间时运行。",
    "{}At the top of the view&nbsp;properties there is a box labeled {}Enable Viewports{}. This {}must be flagged{} before any of the camera views can be used in your game.":"{} 视图属性顶部有一个标记为 {} 启用视口 {} 的框。在您的游戏中使用任何摄像头视图之前，{} 必须标记 {}。",
    "{}At the top of the view&nbsp;properties you can toggle the view inheritance on or off, then there is a box labeled {}Enable Viewports{}. This {}must be flagged{} before any of the camera views can be used in your game.":"{}在视图属性的顶部，您可以打开或关闭视图继承，然后会有一个标记为{}启用视窗{}的框。必须先标记此{}，然后才能在游戏中使用任何相机视图。",
    "{}Cameras also have the {}Object Following {}option. This is for when you want the camera to \"follow\" (ie: maintain the view focused on) a certain object. To do this you must click {}&nbsp;on the menu icon and select an object from the list that pops up (if there are multiple instances of this object in the room, only one of them is followed by the camera).":"{}相机也有{}对象跟随{}选项。这适用于当你想让相机“跟随”(即：保持聚焦于)某个对象的时候。为此，您必须单击菜单图标上的{} ；并从弹出的列表中选择一个对象(如果房间中有该对象的多个实例，则摄像机只跟在其中一个实例后面)。",
    "{}NOTE{}&nbsp;If you are using automatic aspect ratio correction (as set in the {}Game Options{}), then you should {}always {}have this checked otherwise you can get odd effects over the \"letterbox\" that your game is drawn in. If you do not use this option then you can un-check this and get a small boost to your games performance (especially noticeable on Android and other mobile platforms).":"{}注意{}：如果您使用的是自动宽高比校正(如在{}游戏选项{}中设置的)，则应{}始终{}选中此选项，否则您可能会在游戏所在的\"信箱\"上获得奇怪的效果。如果你不使用这个选项，那么你可以取消选中这个选项，并对你的游戏性能进行小幅提升(特别是在Android和其他移动平台上尤其明显)。",
    "{}NOTE{}&nbsp;Instances in a room are created in a certain {}order{}, and their Create events are also executed as they are created one-by-one. This means that you must be careful when reading variables from other instances in the Create event, as that other instance may not have run its Create event yet!{} {} For example: let\u0027s say {}ObjectA{} is created before {}ObjectB{}, and you have the following code in those objects\u0027 Create events:{} {} {}ObjectA {}Create -&nbsp;{}myValue = objectB.myValue;{}{} {}ObjectB {}Create -&nbsp;{}myValue = 10;{}{} {} ObjectA is created first and its Create event runs, which then crashes the game:{} {} {}{}\"Variable objectB.myValue(100003, -2147483648) not set before reading it.\"{}{}{} {} That\u0027s simply because ObjectB has not even been created yet, so any variables initialised in its Create event do not yet exist. This is why you must take caution when referencing other instances&nbsp;like this in the Create event, including any code run inside {}{}with(){}{} blocks. ":"{}NOTE{} 房间中的实例是按照一定的 {} 顺序 {} 创建的，其创建事件也是在逐个创建的过程中执行的。这意味着在从创建事件中的其他实例读取变量时必须小心，因为其他实例可能还没有运行其创建事件！{}{} 例如：假设在 {}ObjectB{} 之前创建了 {}ObjectA{}，并且在这些对象的创建事件中有以下代码：{}{}{}ObjectA {}Create -{}myValue=objectB.myValue;{}{}{}ObjectB {}Create -{}myValue=10;{}{}{} 首先创建对象 A，然后运行它的创建事件，这会使游戏崩溃：{}{}{}{}\" 在读取变量 objectB.myValue(100003, -2147483648) 之前未进行设置。\"。{}{}{}{} 这很简单，因为 ObjectB 甚至还没有创建，所以在它的创建事件中初始化的任何变量都不存在。这就是为什么在创建事件中引用其他实例时必须格外小心，包括在 {}{}with(){}{} 块内运行的任何代码。",
    "{}NOTE{}&nbsp;You can toggle inheritance on or off for the three main viewport settings, and then you can toggle inheritance on or off for each individual camera view.":"{}注意{}：您可以打开或关闭三个主要视区设置的继承，然后打开或关闭每个单独相机视图的继承。",
    "{}Room Properties{}":"{}房间属性{}",
    "{}So, for example, this means that you can have a 640x480 camera view into your room, and then set the port to 320x240, which will display the view scaled down to that sized port on the screen, and you can also do the same and set the view to a smaller value and the port to larger making the image scale up to fit the port size and be shown on the screen larger than it is. In this way you can maintain a screen (port) size while changing the camera view to display more or less of the room in the same area of the screen.":"{} 例如，这意味着您可以在房间中设置 640x480 摄像头视图，然后将端口设置为 320x240，这将在屏幕上显示缩小到该大小的端口的视图，您也可以执行相同的操作，将视图设置为较小的值，并将端口设置为较大，以使图像缩放到适合端口大小，并在屏幕上显示得更大。这样，您可以在更改相机视图的同时保持屏幕 (端口) 大小，以在屏幕的同一区域显示或多或少的房间。",
    "{}The Camera{}: A point within the room that will be used to set how the room is displayed on screen (this is an abstract point in the room editor and its position is set automatically based on the view and view port settings)":"{}摄像头{}：房间内的一个点，用于设置房间在屏幕上的显示方式(这是房间编辑器中的一个抽象点，它的位置是根据查看和查看端口设置自动设置的)",
    "{}The Room Properties section is where you can set the inheritance toggle for the settings,&nbsp;change options such as persistency, the room\u0027s size and manage viewports. This is visible when you select a room asset in the {}Asset Browser{}.":"{}在房间属性部分，您可以设置设置的继承切换，以及更改持久性、房间大小和管理视区等选项。当您在{}资源浏览器{}中选择房间资源时，这是可见的。",
    "{}The View Port{}: The area of the physical screen where the camera view will be displayed":"{}视口{}：显示摄像头视图的物理屏幕区域",
    "{}The View{}: What the camera sees, based on the position, projection and rotation of the camera":"{}视图{}：基于摄像头的位置、投影和旋转，摄像头看到的内容",
    "{}The next thing you must do is set up the {}Gravity {}of the world. The strength and direction of this is calculated as a {}vector{} of the x/y position that you set around a (0, 0) point. So, an x of 0 and a y of 1 will set the gravity direction as being {}down {}with a force of 1 meter per second (for a more detailed explanation see - {}The Physics World{}).":"{}你必须做的下一件事就是设置这个世界的{}重力{}。其强度和方向计算为围绕(0，0)点设置的x/y位置的{}向量{}。因此，x为0，y为1，将重力方向设置为{}向下{}，力为每秒1米(有关更详细的解释，请参阅{}物理世界{})。",
    "{}The&nbsp;{}Room Properties{} section is where you can set the inheritance toggle for the settings,&nbsp;change options such as persistency, the room\u0027s size and manage viewports. This is shown in&nbsp;{}The Inspector{} when you select a room asset in {}The Asset Browser{}.":"{} 在 {} 房间属性 {} 部分，您可以设置设置的继承切换、更改持久性、房间大小等选项以及管理视口。当您在 {} 资产浏览器 {} 中选择房间资产时，这会显示在 {} 检查器 {} 中。",
    "{}The&nbsp;{}Room Properties{} section is where you can set the inheritance toggle for the settings,&nbsp;change options such as persistency, the room\u0027s size and manage viewports. This is visible when you select a room asset in {}The Asset Browser{}.":"{}在{}房间属性{}部分，您可以设置设置的继承切换，更改选项(如持久性、房间大小)和管理视口。当您在{}资源浏览器{}中选择房间资源时，此部分可见。",
    "{}This window lists all the instances in the room in the order that they will be created (from top to bottom). Should you require a specific instance to be created before any other, you can simply click {}&nbsp;and drag it to the position your require. Note that instances will be created in the order given from top to bottom of the list.":"{}此窗口按照创建的顺序(从上到下)列出房间中的所有实例。如果您需要在创建任何其他实例之前创建特定实例，只需单击{} 并将其拖动到您需要的位置即可。请注意，实例将按照列表从上到下的顺序创建。",
    "{}{}The next checkbox is the one that says {}Clear Viewport Background{}, which is similar to the {}Clear Display Buffer{} option given above but for viewports specifically. When enabled, it clears the {}application surface{} with the window colour before drawing each frame. This ensures that you don\u0027t see any unintended graphics through transparent areas in your background, such as the contents of any previous frames. It\u0027s important to enable this option (along with \"{}Enable Viewports{}\") if your background contains any transparency.":"{}{}下一个复选框显示{}清除视区背景{}，这类似于上面给出的{}清除显示缓冲区{}选项，只是专门针对视区。启用后，它会在绘制每个帧之前用窗口颜色清除{}应用程序表面{}。这可确保您不会通过背景中的透明区域看到任何意外的图形，例如任何先前帧的内容。如果您的背景包含任何透明度，启用此选项(以及\"{}启用视窗{}\")是很重要的。"
}