{
    "An object instance\u0027s depth set through&nbsp;its&nbsp;{}{}depth{}{}&nbsp;variable.":"",
    "As a result, the depth test (set to {}{}cmpfunc_lessequal{}{}) passes for all pixels covered by the rectangle and it is fully drawn. Since z-writing is enabled, the depth value for those pixels is replaced with the new value {}0.53125{}. In the third step the depth is set to 2000, written to the depth buffer as {}0.5 + 2000/32000{} = {}0.5625{}, and a circle is drawn at that depth. There are now two possible situations for the depth test:":"因此，矩形覆盖的所有像素的深度测试 (设置为 {}{}cmpfunc_lessequal{}{}) 均通过，并且已完全绘制。由于启用了 z 写入，这些像素的深度值将替换为新值 {}0.53125{}。在第三步中，深度设置为 2000，以 {}0.5 + 2000/32000{}={}0.5625{} 的形式写入深度缓冲区，并在该深度绘制一个圆。现在深度测试有两种可能的情况：",
    "By default, the depth buffer is {}enabled{} in&nbsp;{}GameMaker{},&nbsp;which means that every surface is {}created{} with a depth buffer. This also applies to the&nbsp;{}{}application_surface{}{}, which is the surface that\u0027s drawn to by default.":"默认情况下，深度缓冲区在 {}GameMaker{} 中 {} 启用 {}，这意味着每个表面都是使用深度缓冲区 {} 创建 {} 的。这也适用于 {}{}application_surface{}{}，它是默认绘制的表面。",
    "Clear the depth buffer to a value of 1 using&nbsp;{}{}draw_clear_depth{}{}. 1 is the maximum depth value and corresponds to zfar, so that any object that\u0027s closer than zfar will always pass the {}{}cmpfunc_lessequal{}{}&nbsp;test. {}draw_clear_depth(1);{} ":"使用 {}{}draw_clear_depth{}{} 将深度缓冲区的值清除为 1。 1 是最大深度值，对应于 zfar，因此任何比 zfar 更近的对象都将始终通过 {}{}cmpfunc_lessequal{}{} 测试。{}draw_clear_depth(1);{}",
    "Clear the stencil buffer to a certain value using&nbsp;{}{}draw_clear_stencil{}{}.":"使用 {}{}draw_clear_stencil{}{} 将模板缓冲区清除为特定值。",
    "Copy the contents of the depth buffer to a regular buffer with&nbsp;{}{}buffer_get_surface_depth{}{}&nbsp;or update the contents of the depth buffer with data stored in a regular buffer with&nbsp;{}{}buffer_set_surface_depth{}{}.":"使用 {}{}buffer_get_surface_depth{}{} 将深度缓冲区的内容复制到常规缓冲区，或者使用 {}{}buffer_set_surface_depth{}{} 使用存储在常规缓冲区中的数据更新深度缓冲区的内容。",
    "Decrements the stencil buffer value, clamping at 0.":"减少模板缓冲区值，固定为 0。",
    "Decrements the stencil buffer value, wrapping to the maximum value at 0.":"递减模板缓冲区值，回绕到最大值 0。",
    "Depth vs. Depth Buffer Depth":"深度与深度缓冲区深度",
    "Draw sprites, text, particles, 3D models, etc. Note that if you draw to the&nbsp;{}{}application_surface{}{}, the depth used is the depth of the layer that a visual element is on ({}{}layer_get_depth{}{}), the instance\u0027s&nbsp;{}{}depth{}{}&nbsp;or the depth value that you set manually using&nbsp;{}{}gpu_set_depth{}{}.":"绘制精灵、文本、粒子、3D 模型等。请注意，如果您绘制到 {}{}application_surface{}{}，则使用的深度是视觉元素所在图层的深度 ({}{}layer_get_depth{}{})、实例的 {}{} 深度 {}{} 或您使用 {}{}gpu_set_depth{}{} 手动设置的深度值。",
    "Draw to the surface. Before drawing, you can change the stencil reference value to use with&nbsp;{}{}gpu_set_stencil_ref{}{}. For example, to draw a rectangle of 50x50 pixels using a reference value of 10:&nbsp; {}gpu_set_stencil_ref(10);{} draw_rectangle(0, 0, 49, 49, false);{} ":"绘制到表面。在绘制之前，您可以更改要与 {}{}gpu_set_stencil_ref{}{} 一起使用的模板参考值。例如，要使用参考值 10 绘制 50x50 像素的矩形：{}gpu_set_stencil_ref(10);{}draw_rectangle(0, 0, 49, 49, false);{}",
    "Enable depth testing with {}{}gpu_set_ztestenable{}{}. Possibly also restore other GPU settings to their default values (commented out) in case you changed them (e.g. the default z-test comparison function):&nbsp; {}// surface_depth_disable(false);{} // gpu_set_zwriteenable(true);{} gpu_set_ztestenable(true);{} // gpu_set_zfunc({}cmpfunc_lessequal{});{} ":"使用 {}{}gpu_set_ztestenable{}{} 启用深度测试。如果您更改了其他 GPU 设置 (例如默认的 z 测试比较函数)，也可能将其恢复为默认值 (已注释掉)：{}// surface_depth_disable(false);{}// gpu_set_zwriteenable(true);{}gpu_set_ztestenable(true);{}// gpu_set_zfunc({}cmpfunc_lessequal{});{}",
    "Enable the stencil test using&nbsp;{}{}gpu_set_stencil_enable{}{}, set the stencil comparison function using&nbsp;{}{}gpu_set_stencil_func{}{}&nbsp;(default {}{}cmpfunc_always{}{}) and set the pass and fail operations using&nbsp;{}{}gpu_set_stencil_pass{}{}&nbsp;and&nbsp;{}{}gpu_set_stencil_fail{}{}. By default, both operations are set to {}{}stencilop_keep{}{}.":"使用 {}{}gpu_set_stencil_enable{}{} 启用模板测试，使用 {}{}gpu_set_stencil_func{}{} 设置模板比较函数 (默认为 {}{}cmpfunc_always{}{})，并使用设置通过和失败操作 {}{}gpu_set_stencil_pass{}{} 和 {}{}gpu_set_stencil_fail{}{}。默认情况下，这两个操作均设置为 {}{}stencilop_keep{}{}。",
    "For the default orthographic camera the values can be converted as follows:&nbsp;":"对于默认正交相机，可以按如下方式转换值：",
    "Functions":"函数",
    "If a pixel passes the depth test, it is passed to the stencil test (when enabled). If all tests pass, the pixel is finally drawn.":"如果像素通过深度测试，则会传递到模板测试 (启用时)。如果所有测试都通过，则最终绘制像素。",
    "In the image above, a red rectangle (not filled) is drawn with a stencil reference value of 4. The sprite you see is then drawn using a value of 2. 2 is greater than 0 but less than 4, so the sprite\u0027s pixels that overlap the red rectangle are discarded.":"在上图中，使用模板参考值 4 绘制了一个红色矩形 (未填充)。然后使用值 2 绘制了您看到的精灵。2 大于 0 但小于 4，因此精灵的像素重叠的红色矩形被丢弃。",
    "Increments the stencil buffer value, clamping at the maximum value.":"增加模板缓冲区值，限制在最大值。",
    "Increments the stencil buffer value, wrapping to 0 at the maximum value.":"增加模板缓冲区值，在最大值处回绕到 0。",
    "Keeps the current value in the stencil buffer.":"将当前值保留在模板缓冲区中。",
    "Like the depth test, the stencil test is performed on every pixel that\u0027s drawn to a surface. It\u0027s disabled by default and can be enabled with&nbsp;{}{}gpu_set_stencil_enable{}{}. The comparison is one of the values under the&nbsp;{}{}Comparison Function Constant{}{}. The test itself compares a stencil reference value to the current value in the stencil buffer:&nbsp;":"与深度测试一样，模板测试是对绘制到表面的每个像素执行的。它默认处于禁用状态，可以通过 {}{}gpu_set_stencil_enable{}{} 启用。比较是 {}{} 比较函数常量 {}{} 下的值之一。测试本身将模板参考值与模板缓冲区中的当前值进行比较：",
    "Like the surfaces they belong to, the depth and stencil buffer are also stored in video memory ({}VRAM{}).":"与它们所属的表面一样，深度和模板缓冲区也存储在视频内存 ({}VRAM{}) 中。",
    "Optionally use the depth buffer in a subsequent draw pass, e.g. by passing the surface which it belongs to as the second parameter to&nbsp;{}{}surface_set_target{}{}&nbsp;or by using the depth buffer\u0027s texture in a shader to sample the depth values. The depth buffer\u0027s texture can be retrieved with&nbsp;{}{}surface_get_texture_depth{}{}. The depth values are stored in the red colour channel.":"可以选择在后续绘制过程中使用深度缓冲区，例如通过将其所属的表面作为第二个参数传递给 {}{}surface_set_target{}{} 或通过在着色器中使用深度缓冲区的纹理来采样深度值。可以使用 {}{}surface_get_texture_depth{}{} 检索深度缓冲区的纹理。深度值存储在红色通道中。",
    "Other functions for setting/getting values related to the depth/stencil buffers are listed on&nbsp;{}GPU Control{}.":"{}GPU 控制 {} 中列出了用于设置 / 获取与深度 / 模板缓冲区相关的值的其他函数。",
    "Performs a bitwise inversion on the current stencil buffer value.":"对当前模板缓冲区值执行按位反转。",
    "Perspective Projection":"透视投影",
    "Replaces the value in the buffer to the new stencil reference value.":"将缓冲区中的值替换为新的模板参考值。",
    "See the code example on the&nbsp;{}{}surface_get_texture_depth{}{}&nbsp;function page for a complete example.":"有关完整示例，请参阅 {}{}surface_get_texture_depth{}{} 函数页面上的代码示例。",
    "Sets the stencil buffer value to 0.":"将模板缓冲区值设置为 0。",
    "The Depth Buffer":"深度缓冲区",
    "The Depth Test":"深度测试",
    "The Stencil Buffer":"模板缓冲区",
    "The Stencil Test":"模板测试",
    "The depth and stencil buffer always exist together, i.e.: if a surface has a depth buffer, it also has a stencil buffer, if it has no depth buffer, it also has no stencil buffer.":"深度和模板缓冲区总是一起存在，即：如果一个表面有深度缓冲区，它也有一个模板缓冲区，如果它没有深度缓冲区，它也没有模板缓冲区。",
    "The depth and stencil buffer are two data buffers that are used for advanced graphical effects in both 2D and 3D games, which include&nbsp;shadow mapping, deferred rendering, volumetric rendering, ambient occlusion and many more.":"深度和模板缓冲区是两个数据缓冲区，用于 2D 和 3D 游戏中的高级图形效果，其中包括阴影贴图、延迟渲染、体积渲染、环境光遮挡等等。",
    "The depth buffer can be displayed as a grayscale image, where {}white{} (a value of 1) indicates the pixel is as far away as it can be (at the far plane) and {}black{} (a value of 0) indicates the closest pixel (at znear).":"深度缓冲区可以显示为灰度图像，其中 {} 白色 {}( 值为 1) 表示像素尽可能远 (在远平面)，{} 黑色 {}( 值为 1)0) 表示最近的像素 (在 znear 处)。",
    "The depth buffer stores the values after all transformations have been applied.&nbsp;{}{}draw_clear_depth{}{}&nbsp;can be used to reset all values in the depth buffer to any value between 0 (znear) and 1 (zfar).":"深度缓冲区存储应用所有变换后的值。{}{}draw_clear_depth{}{} 可用于将深度缓冲区中的所有值重置为 0(znear) 和 1(zfar) 之间的任何值。",
    "The depth buffer, also called z-buffer, is a graphics buffer created with the same dimensions as the surface that it\u0027s created for. It stores a 24-bit depth value for every pixel of the surface, which holds the distance away from the surface.":"深度缓冲区也称为 z 缓冲区，是一种图形缓冲区，其创建尺寸与其创建的表面相同。它为表面的每个像素存储一个 24 位深度值，该值保存距表面的距离。",
    "The depth buffer, which stores a depth value for every pixel of a surface (i.e. render target). This depth value is the fraction of the distance between the near plane and the far plane. A value of 0 corresponds to znear, a value of 1 corresponds to zfar. The value depends on the&nbsp;{}camera{}&nbsp;currently in use and its type of {}projection{} ({}perspective{} or {}orthographic{}).":"深度缓冲区，存储表面 (即渲染目标) 每个像素的深度值。该深度值是近平面和远平面之间距离的分数。值 0 对应于 znear，值 1 对应于 zfar。该值取决于当前使用的 {} 相机 {} 及其 {} 投影 {} 类型 ({} 透视 {} 或 {} 正交 {})。",
    "The depth test is a test using the depth buffer that can be performed on the pixels that you draw to. It is disabled by default and can be enabled with&nbsp;{}{}gpu_set_ztestenable{}{}.":"深度测试是使用深度缓冲区的测试，可以对您绘制的像素执行。它默认处于禁用状态，可以通过 {}{}gpu_set_ztestenable{}{} 启用。",
    "The depth value assigned to anything that\u0027s drawn, either automatically by&nbsp;{}GameMaker{}&nbsp;or manually using code. This can be:&nbsp; {} {}The layer depth of layers in&nbsp;{}The Room Editor{}.{} {}An object instance\u0027s depth set through&nbsp;its&nbsp;{}{}depth{}{}&nbsp;variable.{} {}The depth value you set manually in&nbsp;{}GML Code{}&nbsp;using&nbsp;{}{}gpu_set_depth{}{}.{} {} This depth is the z coordinate of the vertex that&nbsp;{}GameMaker{}&nbsp;writes to the vertex buffer, {}before{} any transformations have taken place on the vertex. (For any geometry drawn by&nbsp;{}GameMaker{}, this is the value stored in&nbsp;{}in_Position.z{}). {} {} ":"分配给任何绘制内容的深度值，由 {}GameMaker{} 自动分配或使用代码手动分配。 \n\n这可以是：{}{}{} 房间编辑器 {} 中各层的层深度。\n\n{}{} 对象实例的深度通过其 {}{}depth{}{} 变量设置。\n\n{}{} 您使用 {}{}gpu_set_depth{}{} 在 {14}GML 代码 {15} 中手动设置的深度值。\n\n{}{} 该深度是 {}GameMaker{} 写入顶点缓冲区的顶点的 z 坐标，\n\n 在顶点上发生任何转换{}之前{}。 \n\n(对于 {}GameMaker{} 绘制的任何几何图形，这是存储在 {}in_Position.z{} 中的值)。{}{}",
    "The following function can be used in the fragment shader to convert non-linear depth values to linear ones:&nbsp;":"片段着色器中可以使用以下函数将非线性深度值转换为线性深度值：",
    "The following functions can be used to clear the depth and stencil buffers:&nbsp;":"以下函数可用于清除深度和模板缓冲区：",
    "The following gives a general overview on how to use the depth buffer and the depth test:&nbsp;":"下面概述了如何使用深度缓冲区和深度测试：",
    "The following is an overview of how to use the stencil buffer:&nbsp;":"以下是如何使用模板缓冲区的概述：",
    "The layer depth of layers in&nbsp;{}The Room Editor{}.":"",
    "The light blue pixels are drawn since their depth is less than the maximum depth at zfar. Since z-writing is enabled, the depth value for those pixels is replaced with the new value {}0.5625{}. The pixels shown in white, however, aren\u0027t drawn as the depth value of {}0.5625{} is greater than {}0.53125{}, not less than or equal to {}0.53125{} ({}{}cmpfunc_lessequal{}{}). The depth values for those pixels remain unchanged, i.e. remain at {}0.53125{}.":"绘制浅蓝色像素是因为它们的深度小于 zfar 处的最大深度。由于启用了 z 写入，这些像素的深度值将替换为新值 {}0.5625{}。不过，由于 {}0.5625{} 的深度值大于 {}0.53125{}，且不小于或等于 {}0.53125{}({}{}cmpfunc_lessequal{})，因此不会绘制以白色显示的像素 {})。这些像素的深度值保持不变，即保持为 {}0.53125{}。",
    "The ratio of the projection\u0027s&nbsp;{}zfar / znear{} should be passed to the shader as a uniform variable and then passed to the function.":"投影的 {}zfar / znear{} 比率应作为统一变量传递给着色器，然后传递给函数。",
    "The stencil buffer, like the depth buffer, is a graphics buffer stored in video memory, created with the same dimensions as the surface it\u0027s created for. It stores an 8-bit integer stencil value for every pixel of a render target, allowing for 256 possible values, ranging from 0 to 255.":"与深度缓冲区一样，模板缓冲区是存储在视频内存中的图形缓冲区，其创建尺寸与其创建的表面相同。它为渲染目标的每个像素存储一个 8 位整数模板值，允许 256 个可能的值，范围从 0 到 255。",
    "The stencil test is more flexible than the depth test as it allows you to set the operation to perform when the test passes and when it fails. This operation is set using&nbsp;{}{}gpu_set_stencil_pass{}{}&nbsp;and&nbsp;{}{}gpu_set_stencil_fail{}{}&nbsp;respectively, to one of the following constants:":"模板测试比深度测试更灵活，因为它允许您设置测试通过和失败时要执行的操作。此操作分别使用 {}{}gpu_set_stencil_pass{}{} 和 {}{}gpu_set_stencil_fail{}{} 设置为以下常量之一：",
    "There are two different uses of the term depth in {}GameMaker{}:&nbsp;":"在 {}GameMaker{} 中，术语深度有两种不同的用法：",
    "They store, for every pixel, a 24-bit&nbsp;{}depth{}&nbsp;value and an 8-bit&nbsp;{}stencil{} value respectively.&nbsp;They are created for every&nbsp;{}{}Surface{}{}&nbsp;when the depth buffer is enabled. By default, surfaces are created with a depth buffer (and a stencil buffer), {}z-writing{} is enabled, {}z-testing{} is disabled and the {}stencil test{} is disabled.":"它们分别为每个像素存储一个 24 位 {} 深度 {} 值和一个 8 位 {} 模板 {} 值。当深度缓冲区启用时，它们会为每个 {}{} 表面 {}{} 创建。默认情况下，表面是使用深度缓冲区 (和模板缓冲区) 创建的，启用 {}z-writing{}，禁用 {}z-testing{} 并禁用 {}stencil test{}。",
    "Using the Depth Buffer":"使用深度缓冲区",
    "Using the Stencil Buffer":"使用模板缓冲区",
    "Using the depth test allows you to draw things in a random order, while still making sure that objects are sorted correctly according to their distance from the viewpoint that you\u0027re looking from.":"使用深度测试可以让您以随机顺序绘制事物，同时仍然确保对象根据距您所观察的视点的距离正确排序。",
    "When enabled, the GPU performs a test on all pixels affected by the current draw command (e.g. a {}draw_*{} function). This test is set to&nbsp;{}{}cmpfunc_lessequal{}{}&nbsp;by default, but you can change it to another comparison using {}{}gpu_set_zfunc{}{}.":"启用后，GPU 会对受当前绘制命令 (例如 {}draw_*{} 函数) 影响的所有像素执行测试。该测试默认设置为 {}{}cmpfunc_lessequal{}{}，但您可以使用 {}{}gpu_set_zfunc{}{} 将其更改为其他比较。",
    "When using a perspective projection ({}{}matrix_build_projection_perspective{}{}&nbsp;/&nbsp;{}{}matrix_build_projection_perspective_fov{}{}) the values stored in the depth buffer are not linear and the conversion formula for an orthographic projection cannot be used.":"使用透视投影 ({}{}matrix_build_projection_perspective{}{}/{}{}matrix_build_projection_perspective_fov{}{}) 时，深度缓冲区中存储的值不是线性的，并且无法使用正交投影的转换公式。",
    "When z-testing is enabled, every time you draw something to a surface that has a depth buffer, the depth value of the new pixel is compared to the value at the corresponding pixel in the depth buffer. For example:&nbsp;":"启用 z 测试后，每次在具有深度缓冲区的表面上绘制某些内容时，都会将新像素的深度值与深度缓冲区中相应像素的值进行比较。例如：",
    "the comparison of the depth of the pixels of the circle that do overlap with the rectangle (in white)":"与矩形重叠的圆圈像素深度的比较 (白色)",
    "the comparison of the depth of the pixels of the circle that don\u0027t overlap with the rectangle to zfar (in light blue)":"与矩形不重叠的圆的像素深度与 zfar 的比较 (浅蓝色)",
    "{}In the first step the background is cleared to a grey colour and the depth buffer is cleared to 1, which corresponds to zfar. In the second step the depth is set to 1000 (note that this is the GM depth and not the 0-1 buffer depth), written to the depth buffer as {}0.5 + 1000/32000{} = {}0.53125{}, which is in front of (i.e. {}less than{}) zfar (at 1).":"{} 在第一步中，背景被清除为灰色，深度缓冲区被清除为 1，对应于 zfar。在第二步中，深度设置为 1000( 请注意，这是 GM 深度，而不是 0-1 缓冲区深度)，以 {}0.5 + 1000/32000{}={}0.53125{} 的形式写入深度缓冲区，它位于 (即 {} 小于 {})zfar(1 处) 之前。",
    "{}The Depth And Stencil Buffer{}":"{} 深度和模板缓冲区 {}",
    "{}depth_of_pixel_being_written&nbsp;cmp_func&nbsp;value_at_pixel_in_depth_buffer{}":"",
    "{}{}IMPORTANT{}{} If your game is 2D and relies only on the drawing order of the layers as you defined them in&nbsp;{}The Room Editor{}&nbsp;(or the {}depth order{} of your instances), then you don\u0027t need to enable the depth test. The depth buffer itself can be disabled as well in this case using&nbsp;{}{}surface_depth_disable{}{}.":"{}{} 重要{}{} 如果您的游戏是 2D 游戏并且仅依赖于您在 {} 房间编辑器 {} 中定义的图层绘制顺序 (或实例的 {} 深度顺序 {})，那么你不需要启用深度测试。在这种情况下，也可以使用 {}{}surface_depth_disable{}{} 禁用深度缓冲区本身。",
    "{}{}NOTE{}{}&nbsp;Automatic depth buffer and stencil buffer generation can be turned off&nbsp;using&nbsp;{}{}surface_depth_disable{}{}.":"{}{} 注意{}{} 可以使用 {}{}surface_depth_disable{}{} 关闭自动深度缓冲区和模板缓冲区生成。",
    "{}{}NOTE{}{}&nbsp;Both sides of the comparison are binary AND-ed {}&amp;{}&nbsp;with a read bitmask, which defaults to all ones ({}0b11111111{}). You can set this mask, if needed, using&nbsp;{}{}gpu_set_stencil_read_mask{}{}. The comparison then changes to:&nbsp;{}{}(ref&nbsp;&amp;&nbsp;read_mask)&nbsp;cmp_func&nbsp;(stencil&nbsp;&amp;&nbsp;read_mask){}{}.":"{}{} 注意{}{} 比较的双方都是带有读取位掩码的二进制 AND 运算 {}&amp;{}，默认为全 1({}0b11111111{})。如果需要，您可以使用 {}{}gpu_set_stencil_read_mask{}{} 设置此掩码。然后比较变为：{}{}(ref &amp; read_mask) cmp_func(stencil &amp; read_mask){}{}。",
    "{}{}NOTE{}{}&nbsp;You can also set the operation to perform in case the stencil test passes but the depth test fails using&nbsp;{}{}gpu_set_stencil_depth_fail{}{}.":"{}{} 注意{}{} 您还可以使用 {}{}gpu_set_stencil_depth_fail{}{} 设置在模板测试通过但深度测试失败时要执行的操作。",
    "{}{}NOTE{}{}&nbsp;Z-writing must be enabled in order for the depth value to be overwritten if the depth test passes. This is enabled by default. See&nbsp;{}{}gpu_set_zwriteenable{}{}.":"{}{} 注意{}{} 必须启用 Z 写入，以便在深度测试通过时覆盖深度值。默认情况下启用此功能。请参阅 {}{}gpu_set_zwriteenable{}{}。"
}