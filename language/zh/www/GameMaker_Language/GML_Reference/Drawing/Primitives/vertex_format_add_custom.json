{
    "A single floating point value":"单个浮点值",
    "Blend weights are usually stored in an array and then accessed using blend indices, but you can see here that instead of defining {}in_BlendIndices{} as an {}ivec4{} attribute, it\u0027s a {}vec4{}, then cast to an {}ivec4{} in the code. This is then used to index the array created using the {}gm_Matrix{} (you can only access an array using an {}INT{} value - not a float).":"混合权重通常存储在数组中，然后使用混合索引进行访问，但您可以在此看到，它不是将{}in_BlendIndices{}定义为{}ivec 4{}属性，而是将其转换为代码中的{}ivec 4{}。然后，这将用于为使用{}gm_Matrix{}创建的数组编制索引(您只能使用{}Int{}值而不能使用浮点数访问数组)。",
    "Four component unsigned byte values (from 0 to 255)":"四个分量无符号字节值(从0到255)",
    "Four component values (r, g, b, a)":"四个分量值(r、g、b、a)",
    "Four floating point values":"四个浮点值",
    "GLSL ES does {}not{} support integer attributes, so passing in {}ivec4{}\u0027s does not work (this type is usually used when passing in {}vertex_usage_blendindices{}). What you need to do is pass in texture coordinates and then in the shader, convert them to {}ivec4{} like this:":"GLSL ES {}{}不支持整数属性，因此传入{}ivec 4{}不起作用(通常在传入{}vertex_usage_blendindices{}时使用此类型)。需要做的是传入纹理坐标，然后在着色器中，将它们转换为{}ivec 4{}，如下所示：",
    "In general you should use {}vertex_usage_textcoord{} for all extra parameters where possible, as types like {}vertex_usage_blendweight{} and {}vertex_usage_tangent{} are close to deprecated in most shader languages, and probably won\u0027t convert properly. Instead use {}vec{}, {}vec2{}, {}vec3{} or {}vec4{} types {}vertex_usage_textcoord{} and everything should work fine.":"通常，应尽可能对所有额外参数使用{}vertex_usage_textcoord{}，因为在大多数着色器语言中，类型(如{}vertex_usage_blendweight{}和{}vertex_usage_tangent{})接近不推荐使用的类型，并且可能无法正确转换。而是使用{}个向量{}、{}个vec 2{}、{}个vec 3{}或{}个vec 4{}类型{}个vertex_usage_textcoord{}，一切都应该正常。",
    "The above code will create a new vertex format with just texture and 3 custom floating point values for position. It is then stores the format id in the variable \"my_format\".":"上述代码将创建一个新的顶点格式，只有纹理和3个用于定位的自定义浮点值。然后将格式ID存储在变量\"my_format\"中。",
    "The data type that this custom vertex data will hold (see the {}{}type constants{}{} listed above).":"此自定义顶点数据将保留的数据类型(请参阅上面列出的{}{}类型常量{}{})。",
    "The use that the data will get(see the {}{}usage constants{}{} listed above).":"数据将获得的用途(请参阅上面列出的{}{}使用常量{}{})。",
    "The {}vertex_format_add_custom(){} function only supports {}vertex_usage_position{}, {}vertex_usage_colour{}, {}vertex_usage_normal{} and {}vertex_usage_textcoord{} when using GLSL shaders. These will map to the shader attributes {}in_Position{}, {}in_Colour[0 - ...]{}, {}in_Normal{} respectively (anything that is not one of these three attributes - eg: texture coordinates - can be mapped to any attribute you define).":"{}vertex_format_add_custom(){}函数在使用Glsl着色器时仅支持{}vertex_usage_position{}、{}vertex_usage_colour{}、{}vertex_usage_normal{}和{}vertex_usage_textcoord{}。这些属性将分别映射到着色器属性{}in_Position{}、{}in_Colour[ 0-...]{}、{}in_Normal{}(不属于这三个属性之一的任何属性-例如：纹理坐标-可以映射到您定义的任何属性)。",
    "This function permits you to use a custom data type for specific vertex format attributes as part of the new vertex format being created. The available values to use are defined by the data type constant that you choose, listed below:":"此函数允许您将特定顶点格式属性的自定义数据类型用作正在创建的新顶点格式的一部分。可用的值由您选择的数据类型常量定义，如下所示：",
    "Three floating point values":"三个浮点值",
    "Two floating point values":"两个浮点值",
    "UV coordinates (u, v)":"UV坐标(u， v)",
    "Vertex Data Type Constant":"顶点数据类型常量",
    "Vertex Usage Type Constant":"顶点使用类型常量",
    "binormal values":"二元值",
    "colour values (r, g, b, a)":"颜色值(r，g，b，a)",
    "fog values":"雾值",
    "position values (x, y, z)":"位置值(x、y、z)",
    "sampler index":"取样指数",
    "tangent values":"切线值",
    "the blendweight of the input matrix (for skeletal animation, for example)":"输入矩阵的混合权重(例如，对于骨骼动画)",
    "the indices of the matrices to use (for skeletal animation, for example)":"矩阵的索引(例如骨骼动画)",
    "vertex depth buffer value":"顶点深度缓冲区值",
    "vertex normal values (nx, ny, nz)":"顶点法线值(nx, ny, nz)",
    "{}\n    The use that these constants will be put too also needs to be defined so that the values can be \"bound\" properly within the shader being created. This is necessary due to the fact that DX and OpenGL have different requirements so if you don\u0027t bind them properly, they won\u0027t come through right in the shader. The available usage constants that you can choose are listed below and those you use will depend on the specifics of the shader being created:":"{}\n还需要定义这些常量的用法，以便可以在要创建的着色器中正确\"绑定\"这些值。这是必要的，因为Dx和OpenGL有不同的要求，所以如果没有正确绑定它们，它们将不会直接在着色器中显示。下面列出了您可以选择的可用使用常量，您使用的常量将取决于正在创建的着色器的具体信息：",
    "{}\n    There are some important things to note when using custom formats like these:":"{}\n在使用这些自定义格式时，需要注意一些重要事项："
}