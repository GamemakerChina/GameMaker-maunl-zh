{
    "Finally, in the Draw GUI event the depth texture of the&nbsp;{}{}application_surface{}{}&nbsp;is retrieved with a call to&nbsp;{}{}surface_get_texture_depth{}{}&nbsp;and stored in a temporary variable {}_texture{}. The depth texture is then drawn in the top-right corner of the window on top of the application surface. It is displayed on a textured primitive drawn using the&nbsp;{}Primitive Functions{}, using a shader {}sh_display_depth{}&nbsp;that uses the fragment shader code and the&nbsp;{}LinearizeDepth()&nbsp;{}function provided on this page.":"最后，在 Draw GUI 事件中，通过调用 {4}{5}surface_get_texture_depth{6}{7} 检索 {}{}application_surface{}{} 的深度纹理，并将其存储在临时变量 {}_texture{} 中。然后，在应用程序表面顶部窗口的右上角绘制深度纹理。它显示在使用 {}Primitive Functions{}、使用片段着色器代码的着色器 {}sh_display_depth{} 和本页提供的 {}LinearizeDepth(){} 函数绘制的纹理图元上。",
    "Fragment Shader":"片段着色器",
    "In the Create event, the {}znear{} and {}zfar{} values of the perspective projection are initialised, as well as the ratio {}zfar / znear{}. The shader uniform is also retrieved. After that, views are enabled and {}view[0]{} is made visible. This view\u0027s camera is then assigned a projection and view matrix.":"在 Create 事件中，透视投影的 {}znear{} 和 {}zfar{} 值以及比率 {}zfar / znear{} 被初始化。着色器制服也被检索。之后，视图将启用并且 {}view[0]{} 可见。然后为该视图的相机分配一个投影和视图矩阵。",
    "In the Draw event a few shapes are then drawn at various depth values. Depth testing is first enabled with a call to&nbsp;{}{}gpu_set_ztestenable{}{}, then the shapes are drawn. Before each shape is drawn its depth is set with a call to the&nbsp;{}{}gpu_set_depth{}{}&nbsp;function. Drawing is done on the&nbsp;{}{}application_surface{}{}, since this is the draw target that&nbsp;{}GameMaker{}&nbsp;uses by default. At the end of the Draw event, z-testing is disabled again.":"在绘制事件中，然后以不同的深度值绘制一些形状。首先通过调用 {}{}gpu_set_ztestenable{}{} 启用深度测试，然后绘制形状。在绘制每个形状之前，通过调用 {}{}gpu_set_depth{}{} 函数来设置其深度。绘制是在 {}{}application_surface{}{} 上完成的，因为这是 {}GameMaker{} 默认使用的绘制目标。在 Draw 事件结束时，z 测试再次被禁用。",
    "In the code above the calculated depth value is assigned to all three colour channels (R, G and B) to output a greyscale image.":"在上面的代码中，计算出的深度值被分配给所有三个颜色通道 (R、G 和 B) 以输出灰度图像。",
    "In the shader you can then use this function as follows:&nbsp;":"在着色器中，您可以按如下方式使用此函数：",
    "The above code shows an extended example on how to use the depth buffer with a perspective projection. A few shapes are drawn to the application surface, the application surface\u0027s depth texture is then retrieved and the depth texture drawn on top of the application surface.":"上面的代码显示了有关如何将深度缓冲区与透视投影结合使用的扩展示例。将一些形状绘制到应用程序表面，然后检索应用程序表面的深度纹理并将深度纹理绘制在应用程序表面的顶部。",
    "The depth value is stored in the red channel and can be accessed in a shader as follows:&nbsp;":"深度值存储在红色通道中，可以在着色器中访问，如下所示：",
    "The surface of which to get the depth texture":"要获取深度纹理的表面",
    "The texture can then be passed to&nbsp;{}{}texture_set_stage{}{}&nbsp;for use in&nbsp;{}Shaders{}.":"然后可以将纹理传递到 {}{}texture_set_stage{}{} 以在 {} 着色器 {} 中使用。",
    "This function returns the depth texture of the given surface or -1 if no depth texture exists.":"此函数返回给定表面的深度纹理，如果不存在深度纹理，则返回 -1。",
    "Vertex Shader":"顶点着色器",
    "When you write to the depth buffer with a {}perspective{} {}projection{}&nbsp;set, the depth values stored in the texture will not be linear and you need to convert the values to linear ones in a custom shader, using the following shader function:&nbsp;":"当您使用 {} 透视 {}{} 投影 {} 集写入深度缓冲区时，存储在纹理中的深度值将不是线性的，您需要在自定义着色器中使用以下方法将这些值转换为线性值着色器功能："
}