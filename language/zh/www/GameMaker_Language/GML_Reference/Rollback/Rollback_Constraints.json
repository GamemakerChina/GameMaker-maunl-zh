{
    "A variable inside a managed instance, containing a reference to another managed instance, will be set to {}undefined{} if the referenced instance is destroyed.":"如果被引用的实例被销毁，则托管实例中包含对另一个托管实例的引用的变量将被设置为 {}undefined{}。",
    "Also make sure that you don\u0027t use&nbsp;{}{}delta_time{}{}, as it is highly dependent on the system running the game and cannot be synchronised between players.":"另外，请确保不要使用 {}{}delta_time{}{}，因为它高度依赖于运行游戏的系统，并且不能在玩家之间同步。",
    "An instance ID stored in a managed instance must point to a managed instance.":"存储在托管实例中的实例 ID 必须指向托管实例。",
    "An {}instance_destroy(){} call can easily be run by a wrong prediction, which means that the destruction of the instance will soon be rolled back when the correct data from the responsible player is received.":"错误的预测很容易导致调用 {}instance_destroy(){}，这意味着当收到负责玩家的正确数据时，实例的销毁很快就会回滚。",
    "Browser Support":"浏览器支持",
    "Changing the room will cause the game to run its synchronisation process again.":"更改房间将导致游戏再次运行其同步过程。",
    "Create a Multiplayer Game":"创建一个多人游戏",
    "Data for managed objects will {}not {}automatically be carried over when a room is changed. You can carry it over manually by using global variables, a persistent object, or by saving the local player\u0027s information to a file.":"更改房间时，管理对象的数据{}不会{}自动结转。您可以通过使用全局变量、持久化对象或将本地玩家的信息保存到文件中来手动传递。",
    "Defining Inputs":"定义输入",
    "Destroy event":"销毁事件",
    "Do not use variables/functions like {}{}current_time{}{} or {}{}get_timer(){}{} to affect game logic. A managed variable called&nbsp;{}{}rollback_current_frame{}{}&nbsp;has been provided which can be used instead. It returns the number of frames that have passed since the multiplayer game began.":"请勿使用 {}{}current_time{}{} 或 {}{}get_timer(){}{} 等变量 / 函数影响游戏逻辑。已经提供了可替代使用的托管变量 {}{}rollback_current_frame{}{} 来调用。它返回自多人游戏开始以来经过的帧的数量。",
    "Draw Event State":"绘制事件状态",
    "Draw events use a separate RNG state. This means that random functions called in a Draw event will not affect the regular RNG state for other events, and may not be the same between different players.":"绘制事件使用单独的 RNG 状态。这意味着在抽签事件中调用的随机函数不会影响其他事件的常规 RNG 状态，并且不同玩家之间的 RNG 状态可能不同。",
    "Due to this, the Destroy event of an instance is only called when it\u0027s confirmed that it was supposed to be destroyed. This means there may be a slight lag in the instance being destroyed on a player\u0027s screen, and its Destroy event being called.":"因此，只有在确认应该销毁实例时，才会调用实例的销毁事件。这意味着在玩家的屏幕上销毁实例以及调用其销毁事件时可能会有轻微的延迟。",
    "Event Order":"事件顺序",
    "For example, if your managed {}obj_workstation{} instance has a reference to an {}obj_anvil{} instance, {}obj_anvil{} must be a managed object.":"例如，如果您的托管 {}obj_workstation{} 实例引用了一个 {}obj_anvil{} 实例，则 {}obj_anvil{} 必须是托管对象。",
    "Further Reading":"延伸阅读",
    "Global State":"全局状态",
    "If a managed instance has a reference to a non-managed instance, it will result in inconsistencies between client states, as changes to that non-managed instance can\u0027t be managed and rolled back.":"如果托管实例引用了非托管实例，则将导致客户端状态之间的不一致，因为无法管理和回滚对该非托管实例的更改。",
    "If you want something to happen on a client\u0027s screen on the same frame as an instance being destroyed, it\u0027s recommended to create a custom function and calling it along with {}instance_destroy(){}.":"如果您希望在客户端屏幕上与被销毁的实例在同一帧上发生某些事情，建议您创建一个自定义函数并与 {}instance_destroy(){} 一起调用它。",
    "Instance References":"实例引用",
    "Lost Instance References":"丢失的实例引用",
    "Random Numbers":"随机数",
    "Random number generation (RNG) state is managed between players, so it\u0027s completely safe to use random functions&nbsp;(e.g. {}random(){}, {}choose(){}, etc.) for game logic. The Rollback system will ensure that each player gets the same random number at the same point in the game.":"随机数生成 (RNG) 状态是在玩家之间管理的，所以使用随机函数是完全安全的 (例如，{}random(){}，{}choose(){} 等)。为了游戏逻辑。回滚系统将确保每个玩家在游戏中的同一时间点获得相同的随机数字。",
    "Read the following pages for more information on the Rollback system:":"有关回滚系统的更多信息，请阅读以下页面：",
    "Rollback Constraints":"回滚约束",
    "Rollback Events":"回滚事件",
    "Rollback Multiplayer makes use of the WebTransport API, which {}may not be supported on all browsers{}. At the moment, Safari, Firefox and Internet Explorer are unsupported on desktop. Chrome, Firefox, and Safari on mobile are also unsupported.":"回滚多人游戏使用的是 WebTransport API，{}并不是所有浏览器都支持该接口{}。目前，桌面端不支持 Safari、Firefox 和 Internet Explorer。手机上的 Chrome、Firefox 和 Safari 也不受支持。",
    "Rollback Multiplayer manages the \"state\" of your game between clients, which includes managed instances and their variables. Such managed parts of your game are able to be rolled back in case of a wrong prediction by the Rollback system.":"回滚多人游戏管理您的游戏在客户端之间的\"状态\"，其中包括托管实例及其变量。在回滚系统预测错误的情况下，您的游戏的此类托管部分能够回滚。",
    "Rollback Start":"回滚开始",
    "Rollback System":"回滚系统",
    "Room End":"房间结束",
    "Room Start":"房间开始",
    "Rooms":"房间",
    "Seeds":"种子",
    "State Before Rollback Start":"回滚开始前的状态",
    "State Management":"状态管理",
    "The Rollback system has some constraints that you should be aware of. Breaking any of these constraints will result in {}Sync Test{} throwing an error to let you know what\u0027s wrong.":"回滚系统有一些您应该知道的限制。违反这些约束中的任何一个都将导致{}同步测试{}引发错误，让您知道问题出在哪里。",
    "The managed RNG state only starts when {}Rollback Start{} is called, which is when the multiplayer game starts. You can change the seed before that point, which will not have any affect past the starting point.":"托管 RNG 状态仅在调用{}回滚开始{}时开始，也就是多人游戏开始时。您可以在该点之前更改种子，这不会对起点之后产生任何影响。",
    "The player is returned to the same state on {}leaving a game{}, meaning the use of&nbsp;{}{}rollback_game_running{}{}&nbsp;is necessary to ensure that any game logic only runs while the game is connected.":"玩家在{}离开游戏{}时返回到相同的状态，这意味着需要使用 {}{}rollback_game_running{}{} 来确保任何游戏逻辑只在游戏连接时运行。",
    "The {}Destroy{} event of an instance normally runs as soon as it\u0027s destroyed, for example, after&nbsp;{}{}instance_destroy(){}{} is called. However, the event may not run immediately in a multiplayer game.":"实例的{}销毁{}事件通常在销毁后立即运行，例如，在调用 {}{}instance_destroy(){}{} 之后。然而，在多人游戏中，该事件可能不会立即运行。",
    "There are some restrictions with managing your game\u0027s state that you should follow to ensure proper synchronisation between players.":"管理你的游戏状态有一些限制，你应该遵守，以确保玩家之间的适当同步。",
    "This also applies to the {}Clean Up{} event running on an instance being destroyed.":"这也适用于在被销毁的实例上运行的{}清除{}事件。",
    "This means that if a variable in a {}persistent{}&nbsp;managed instance contains a reference to a {}non-persistent{} managed instance, that variable will be set to {}undefined{} when the room changes, as the non-persistent instance would stop existing.":"这意味着，如果{}持久化{}托管实例中的变量包含对{}非持久化{}托管实例的引用，则当空间改变时，该变量将被设置为 {}undefined{}，因为非持久化实例将停止存在。",
    "Time Variables":"时间变量",
    "Using these options you can save the player\u0027s information before a room ends, and apply it back when the player instance is created in a new room.":"使用这些选项，您可以在房间结束前保存玩家的信息，并在新房间中创建玩家实例时将其应用回来。",
    "When a multiplayer game starts, the following events will run in the given order:":"当多人游戏开始时，以下事件将按给定顺序运行：",
    "When you change the room in the middle of a multiplayer game, the following events will run in the given order:":"当您在多人游戏中更换房间时，以下事件将按给定顺序运行：",
    "When you create or destroy a managed instance, or modify any properties/variables in a managed instance, you are updating the state of your game. This state is {}not{} sent to other players, as only {}input{} is shared for all clients.":"当您创建或销毁托管实例，或修改托管实例中的任何属性/变量时，您正在更新游戏的状态。此状态{}不会{}发送给其他玩家，因为所有客户端只共享{}输入{}。",
    "You can change rooms while a multiplayer game is active, as long as all the players are connected.":"只要所有玩家都处于连接状态，您就可以在多人游戏处于活动状态时更换房间。",
    "You can run any creation or set-up code for your managed instances before that point, as long as it\u0027s done in exactly the same manner for all clients. To know if the game has started, use&nbsp;{}{}rollback_game_running{}{}.":"在此之前，您可以为托管实例运行任何创建或设置代码，只要所有客户端都以完全相同的方式完成即可。要了解游戏是否已开始，请使用 {}{}rollback_game_running{}{}。",
    "You can use the time between your start/join call and the&nbsp;{}Rollback Start{}&nbsp;event to display a loading screen for the players waiting.":"您可以使用您的开始/加入调用和{}回滚开始{}事件之间的时间来为等待的玩家显示加载屏幕。",
    "You can\u0027t use {}{}randomise(){}{} or&nbsp;{}{}random_set_seed(){}{} to change the RNG seed, as it\u0027s managed by the Rollback system.":"由于 RNG 种子由回滚系统管理，因此不能使用 {}{}randomise(){}{} 或；{}{}random_set_seed(){}{} 更改 RNG 种子。",
    "You cannot change the state in a Draw event, and its purpose must remain to only draw graphics based on the state set in previous events. All managed objects become read-only during a Draw event, so you cannot change any variables in them, and you cannot create or destroy instances of managed objects.":"您不能更改绘制事件中的状态，其目的必须保持为仅根据以前事件中设置的状态绘制图形。所有托管对象在绘制事件期间都变为只读，因此不能更改其中的任何变量，也不能创建或销毁托管对象的实例。",
    "You cannot have global variables affecting your game state, as they are not synchronised between players. All required variables should be within managed objects.":"你不能让全局变量影响你的游戏状态，因为它们在玩家之间不同步。所有必需的变量都应位于托管对象内。",
    "You must ensure that each player starts at the same game state. This means that everything about your game and its managed instances must be the same for all players when the&nbsp;{}Rollback Start{}&nbsp;event triggers, which is when the game actually starts.":"您必须确保每个玩家在相同的游戏状态下开始。这意味着当{}回滚开始{}事件触发时，即游戏实际开始时，您的游戏及其托管实例的所有内容对于所有玩家都必须相同。",
    "{}Alarm events{} are safe to use in managed objects.":"在托管对象中使用{}计时器事件{}是安全的。",
    "{}Clean Up{} events for&nbsp;{}defined players {}":"{}清理{}{}已定义玩家的{}事件",
    "{}Create{} events for {}defined players{}":"{}创建{}{}已定义玩家的{}事件",
    "{}rollback_event_param.first_start{}&nbsp;will be {}false{}":"{}rollback_event_param.first_start{} 将返回 {}false{}",
    "{}rollback_event_param.first_start{}&nbsp;will be {}true{}":"{}rollback_event_param.first_start{} 将返回 {}true{}"
}