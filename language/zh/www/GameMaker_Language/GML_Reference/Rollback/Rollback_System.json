{
    "\"{}Input{}\" is what Rollback communicates between all players, not the state.":"\"{}输入{}\"回滚是指所有玩家之间进行的回滚，而不是状态。",
    "A different approach to multiplayer is \"state replication\", which continually synchronises the state of the game between clients, ensuring they are always doing the same thing.":"另一种多人游戏的方法是\"状态复制\"，它持续同步客户端之间的游戏状态，确保它们总是在做相同的事情。",
    "After following the&nbsp;{}Create a Multiplayer Game{}&nbsp;tutorial, you may have some questions about how the Rollback system works. This page aims to expand on it.":"学习完{}创建一个多人游戏{}教程后，您可能会对回滚系统的工作原理有一些疑问。本页面旨在对其进行扩展。",
    "All objects that are part of your gameplay, like the player, manager/controller objects, item pickups, projectiles, etc. must be marked as managed.":"游戏中的所有对象，如玩家、管理员/控制器对象、物品拾取器、投射物等，都必须标记为托管。",
    "As previously mentioned, Rollback {}only communicates input{} between players.":"如前所述，回滚{}只在玩家之间传递输入{}。",
    "As shown in&nbsp;{}Create a Multiplayer Game{}, you can define a player object with {}{}rollback_define_player(){}{}&nbsp;/&nbsp;{}Define Player (Rollback){}&nbsp;and the system will automatically create instances of it for each connected player. It will also destroy instances for players that disconnect.":"如{}创建一个多人游戏{}中所示，您可以使用 {}{}rollback_define_player(){}{} / {}定义玩家(回滚){}定义一个玩家对象，系统会自动为每个连接的玩家创建该对象的实例。它还将销毁断开连接的玩家的实例。",
    "Auto-start is automatically disabled when player preferences {}are enabled{}.":"当{}启用{}玩家首选项时，自动启动会自动禁用。",
    "Automatic Creation of Player Instances":"自动创建玩家实例",
    "Because input affects state, a wrong input prediction can result in a {}wrong state{}.":"因为输入影响状态，所以错误的输入预测可能导致{}错误的状态{}。",
    "By default, a multiplayer game starts as soon as all players have joined. However you can start it before that point by calling {}{}rollback_start_game(){}{}.":"默认情况下，多人游戏在所有玩家都加入后立即开始。但是，您可以通过调用 {}{}rollback_start_game(){}{} 在该点之前启动它。",
    "Defining A Player Object":"定义玩家对象",
    "Defining Inputs":"定义输入",
    "Determinism":"确定性",
    "Developing Multiplayer Effectively":"有效开发多人游戏",
    "During Sync Test, \"remote\" player instances are given random input values for their {}defined inputs{}, as a simple form of testing. You can disable this using {}{}rollback_use_random_input(){}{}.":"在同步测试期间，作为一种简单的测试形式，\"远程\"玩家实例将获得其 {} 定义的输入 {} 的随机输入值。您可以使用 {}{}rollback_use_random_input(){}{} 禁用它。",
    "Further Reading":"延伸阅读",
    "Here is an example:":"下面是一个例子：",
    "How does it work?":"它如何工作？",
    "However, because all game clients run the same logic on the received input (which is a requirement), {}they all result in the same state{}.":"然而，因为所有游戏客户端对接收到的输入运行相同的逻辑(这是必需的)，所以{}它们都导致相同的状态{}。",
    "However, sometimes the system realises its prediction was wrong. In that case, it {}rolls back{} to the last correct state, and continues the game from that point. This is why it\u0027s called \"{}Rollback multiplayer{}\".":"然而，有时系统会意识到它的预测是错误的。在这种情况下，它将{}回滚{}到最后正确的状态，并从该点继续游戏。这就是为什么它被称为{}回滚多人{}。",
    "If only input is synchronised, then what is&nbsp;{}state{} for?":"如果仅同步输入，则{}状态{}用于什么？",
    "If you\u0027re using&nbsp;{}{}rollback_define_player(){}{}&nbsp;/&nbsp;{}Define Player (Rollback){}, do not destroy the player instances that are created. If you need to show a player as defeated, then change its sprite, or hide it using some other method, but keep the instance alive as it\u0027s managed by GameMaker.":"如果您是使用 {}{}rollback_define_player(){}{} / {}定义玩家(回滚){}，请不要销毁已创建的玩家实例。如果你需要显示一个玩家失败，那么改变它的精灵，或者用其他方法隐藏它，但保持实例的活动状态，因为它是由 GameMaker 管理的。",
    "It\u0027s easy to experience lag when playing online. If you\u0027re playing with someone remotely, it may take a fraction of a second for their input to reach you, but even that can be enough to ruin your game experience.":"在网上玩的时候很容易遇到滞后。如果你正在和某人远程玩游戏，他们的输入可能只需要几秒钟的时间就能到达你那里，但即使这样也足以毁了你的游戏体验。",
    "Keep Player Instances Alive":"保持玩家实例处于活动状态",
    "Managed Objects":"托管对象",
    "Manual Creation of Player Instances":"手动创建玩家实例",
    "Manual vs. Auto Start":"手动开始与自动开始",
    "Note that the managed property of a parent is not applied to its children automatically, so each child object needs to have its managed checkbox set manually.":"请注意，父对象的托管属性不会自动应用于其子对象，因此每个子对象都需要手动设置其托管复选框。",
    "Objects have a \"{}Managed{}\" checkbox, which is enabled for new objects by default:":"对象具有\"{}托管{}\"复选框，默认情况下为新对象启用该复选框：",
    "Player Preferences":"玩家首选项",
    "Player instances created this way have their IDs assigned automatically, in the {}{}player_id{}{}&nbsp;variable. Within each player instance, you can simply call {}{}rollback_get_input(){}{} without any arguments and it gives you the inputs for that particular player.":"以这种方式创建的玩家实例的 ID 将在 {}{}player_id{}{} 变量中自动分配。在每个玩家实例中，您只需调用 {}{}rollback_get_input(){}{} 而不带任何参数，它将为您提供特定玩家的输入。",
    "Random and Mock Input":"随机和模拟输入",
    "Read the following pages for more information on the Rollback system:":"有关回滚系统的更多信息，请阅读以下页面：",
    "Rollback Constraints":"回滚约束",
    "Rollback Events":"回滚事件",
    "Rollback System":"回滚系统",
    "Rollback does not do that -- it only ever sends inputs, but also keeps an eye on the state so it can be rolled back in case of a wrong prediction.":"回滚不会这样做 -- 它只发送输入，而且还会监视状态，以便在预测错误时可以回滚。",
    "Rollback is deterministic. It only shares inputs with other players, and expects all of them to run the same logic on the given input, giving the same results on all clients.":"回滚是确定性的。它只与其他参与者共享输入，并期望所有参与者对给定的输入运行相同的逻辑，在所有客户端上提供相同的结果。",
    "Rollback uses predictions to reduce the effect of lag. Based on previous inputs, it predicts what the other user is going to do next, and shows you the result of that prediction, which is instant.":"回滚使用预测来减少延迟的影响。根据之前的输入，它预测其他用户下一步要做什么，并向您显示预测的结果，这是即时的。",
    "Single Player":"单人游戏",
    "So... what\u0027s the difference?":"所以...有什么关系呢？",
    "Sync Test":"同步测试",
    "Sync Test executes all of your game\u0027s code twice in a frame, so it can check for any synchronisation issues. This means you may see some events happening twice when testing offline, which will not happen when your game is running online.":"同步测试在一帧中执行两次游戏的所有代码，因此它可以检查是否存在任何同步问题。这意味着您可能会在脱机测试时看到一些事件发生两次，而当您的游戏在线运行时不会发生这些事件。",
    "Sync Test is used to test your game offline. If any synchronisation issues pop up, it lets you know by printing the error to the Output Log. You can use Sync Test on Windows,&nbsp;macOS and GX.games.":"同步测试用于离线测试您的游戏。如果出现任何同步问题，它会通过将错误打印到输出日志来通知您。您可以在 Windows、macOS 和 GX.games 上使用同步测试。",
    "Take this approach when you are making a new project that may make use of multiplayer in the future, as it will be tougher to implement multiplayer into your game once it\u0027s already completed without using the Rollback system.":"当你正在制作一个未来可能使用多人游戏的新项目时，请采用这种方法，因为一旦游戏已经完成，在不使用回滚系统的情况下，将更难在游戏中实现多人游戏。",
    "The Rollback system can be used when creating a single-player game. Simply specify {}1{} as the number of players when calling {}{}rollback_create_game(){}{}.":"回滚系统可以在创建单人游戏时使用。只需在调用 {}{}rollback_create_game(){}{} 时指定玩家数量为 {0}1{1} 即可。",
    "The second player is getting random input during Sync Test.":"第二个玩家在同步测试期间得到随机输入。",
    "Then create your own player instances manually, ideally in the {}Rollback Start{} event, and give them player IDs in a custom variable. To get input for a player, call&nbsp;{}{}rollback_get_input(){}{}&nbsp;and specify the ID of the player as an argument. Call {}{}rollback_get_info(){}{} to get those {}variables{} in a struct that would otherwise be assigned to players automatically.":"然后手动创建您自己的玩家实例，最好是在{}回滚开始{}事件中创建，并在自定义变量中为它们提供玩家 ID。为了获得玩家的输入，调用 {}{}rollback_get_input(){}{} 和将玩家的 ID 指定为参数。调用 {}{}rollback_get_info(){}{} 以获取结构中的那些{}变量{}，否则这些变量将自动分配给玩家。",
    "There are two main things that Rollback handles:":"回滚主要处理两件事：",
    "They would only see the same value for a variable if it was derived from a player\u0027s input, or some other managed system, such as alarms and random functions.":"如果变量是从玩家的输入或其他管理系统(如警报和随机函数)派生的，则他们只能看到变量的相同值。",
    "This does not mean that Rollback is synchronising objects and variables between clients. Just because {}variable_a{} is set to {}\"Gurpreet\"{} in one client, it won\u0027t mean other clients will also see the same value.":"这并不意味着回滚正在同步客户端之间的对象和变量。仅仅因为在一个客户端中将 {}variable_a{} 设置为 {}\"Gurpreet\"{}，并不意味着其他客户端也会看到相同的值。",
    "This is the standard way of using the Rollback system, however you can also manage player instances and their inputs manually.":"这是回滚系统的标准使用方式，但您也可以手动管理玩家实例及其输入。",
    "This problem usually does not occur if you program your game as shown in {}Create a Multiplayer Game{}, with all player logic running the same way for all player instances regardless of whether an instance is {}local or not{}. However if you implement a condition to only do something for a particular player, and not for others, that will cause a disruption in the game state.":"如果您按照{}创建一个多人游戏{}中所示的方式对游戏进行编程，并且所有玩家实例的所有玩家逻辑都以相同的方式运行，而不管{}实例是否在本地{}，通常不会出现这个问题。然而，如果您实现了一个条件，只为特定的玩家做一些事情，而不是为其他玩家，这将导致游戏状态的中断。",
    "This way the system will never connect to any servers and your game will essentially be offline, with the ability to be expanded into an online multiplayer game whenever you wish.":"这样，系统将永远不会连接到任何服务器，您的游戏将本质上是离线的，可以随时扩展为在线多人游戏。",
    "This way you can manually manage when and how player instances are created, the IDs assigned to them, and retrieving input for a specific player.":"通过这种方式，您可以手动管理创建玩家实例的时间和方式、分配给它们的 ID 以及检索特定玩家的输入。",
    "To manage player instances manually, don\u0027t call {}{}rollback_define_player(){}{}. This will cause the game to start without any player instances being created.":"如果需要手动管理玩家实例，请不要调用 {}{}rollback_define_player(){}{}。这将导致游戏在不创建任何玩家实例的情况下开始。",
    "What is Rollback?":"什么是回滚？",
    "What is state, then?":"那么，什么是状态呢？",
    "When rollback finds that a prediction was wrong, it replaces the current state with the correct state, and runs inputs and predictions from that point again. This includes all your managed objects and their variables.":"当回滚发现预测错误时，它会用正确的状态替换当前状态，并从该点再次运行输入和预测。这包括您的所有托管对象及其变量。",
    "When the prediction is correct, you don\u0027t experience lag, and your game feels much more responsive.":"当预测正确时，你不会经历滞后，你的游戏感觉更有响应性。",
    "You can also assign temporary mock input to remote players when in Sync Test. See&nbsp;{}Mock Input{}&nbsp;for details.":"在同步测试中，您还可以将临时模拟输入分配给远程玩家。有关详细信息，请参阅{}模拟输入{}。",
    "You can completely disable the auto-start behaviour by calling {}{}rollback_use_manual_start(){}{}. This means the game will wait for you to manually start the game.":"您可以通过调用 {}{}rollback_use_manual_start(){}{} 来完全禁用自动启动行为。这意味着游戏将等待您手动启动游戏。",
    "You can disable this for objects that don\u0027t need to be synchronised between players, such as static world objects, visuals, effects, etc. that don\u0027t affect gameplay in any way.":"对于不需要在玩家之间同步的对象，例如不会以任何方式影响游戏的静态世界对象、视觉效果、特效等，您可以禁用此功能。",
    "You must ensure that all game clients run the {}same logic{} when the {}same input{} is received. If a particular instance was created or moved only for one client, it will not be reflected on the other clients.":"您必须确保当收到{}相同的输入{}时，所有游戏客户端都运行{}相同的逻辑{}。如果特定实例仅为一个客户端创建或移动，则不会反映在其他客户端上。",
    "{}Input{} changes&nbsp;{}state{}, which is the base concept of Rollback multiplayer.":"{}输入{}改变{}状态{}，这是回滚多人游戏的基本概念。",
    "{}Input{}: Each player\u0027s {}inputs{} are sent to other players. If Player 0 presses {}\"fire\"{} in their own client, Rollback will ensure that other clients also see Player 0 press {}\"fire\"{}. {} {} {}Predictions are only run on input.{} ":"{}输入{}：每个玩家的{}输入{}被发送给其他玩家。如果玩家0在自己的客户端按下{}\"fire\"{}，回滚将确保其他客户端也能看到玩家0按下{}\"fire\"{}。{}{}{}预测仅对输入运行。{}",
    "{}Input{}: Player 0 presses {}\"fire\"{}.":"{}输入{}：玩家0按下{}\"fire\"{}。",
    "{}Objects that are marked as managed have the ability to be rolled back and to have predictions run on them, including all of their variables, creation and destruction.":"{}标记为托管的对象能够回滚并对其运行预测，包括它们的所有变量、创建和销毁。",
    "{}State{}: Because Player 0 pressed fire, a projectile is created. That projectile eventually collides with a rock. This results in Player 0 getting a point. {} {} This is essentially your whole game, dependent entirely on input. ":"{}状态{}：因为玩家0按下了火，所以产生了一个弹丸。该抛射物最终会与一块岩石相撞。这会导致玩家0得到一分。{}{}这基本上是你的整个游戏，完全依赖输入。",
    "{}State{}: This includes all managed objects and their variables. These are NOT synchronised between players: changing one variable in one client will not automatically update it in another client. {} {} {}State is only managed for the purpose of being rolled back.{} ":"{}状态{}：包括所有托管对象及其变量。这些在玩家之间是不同步的：更改一个客户端中的一个变量不会自动更新另一个客户端中的变量。{}{}{}管理状态仅用于回滚。{}",
    "{}{}What is a client?{}{} {} {} A \"client\" is a player in your game, and refers to their copy of the game, running on their machine. ":"{}{}什么是客户端？{}{} {}{}客户端是您游戏中的玩家，指的是在他们的计算机上运行的游戏副本。",
    "{}{}rollback_create_game(){}{} takes an argument for Sync Test, which is enabled by default (when the argument is not specified).":"{}{}rollback_create_game(){}{} 接受同步测试的参数，该参数在默认情况下处于启用状态 (未指定参数时)。"
}