{
    "Add the Create event to&nbsp;{}obj_game{}, and write the following code in it:":"将创建事件添加到 {}obj_game{}，并在其中编写以下代码：",
    "Based on each arrow key held, it moves the instance on the corresponding axis, e.g. pressing left reduces the X, pressing up reduces the Y, and so on.":"根据按住的每个箭头键，它会在相应的轴上移动实例，例如，向左按会减少 X，向上按会减少 Y，依此类推。",
    "Based on that, we are changing the initial X position of the player. The Y position is the same for both.":"在此基础上，我们将更改玩家的初始 X 位置。两者的 Y 位置是相同的。",
    "Before we test, let\u0027s ensure the players are created at specific locations, instead of spawning at the top-left corner of the room.":"在我们测试之前，让我们确保玩家是在特定的位置创建的，而不是在房间的左上角生成。",
    "By default, the system starts in {}Sync Test{} mode, which is how you test your game offline. To enable online functionality, the second argument of {}{}rollback_create_game(){}{} needs to be set to {}false{}&nbsp;(which disables Sync Test).":"默认情况下，系统在{}同步测试{}模式下启动，这是您离线测试游戏的方式。若要启用在线功能，需要将 {}{}rollback_create_game(){}{} 的第二个参数设置为 {}false{}( 这将禁用同步测试)。",
    "Call {}{}rollback_leave_game(){}{} to make a player leave the room. Read the {}function page{} for detailed information on its use.":"调用 {}{}rollback_leave_game(){}{} 可以让玩家离开房间。有关其使用的详细信息，请阅读{}功能页{}。",
    "Create a Multiplayer Game":"创建一个多人游戏",
    "Create two objects:":"创建两个对象：",
    "Defining Inputs":"定义输入",
    "During your test you will see debug messages in the top-left corner of your game, giving you info on the state of your game. You can disable this by calling {}{}rollback_display_events(false){}{}.":"在测试期间，您将在游戏的左上角看到调试消息，为您提供有关游戏状态的信息。您可以通过调用 {}{}rollback_display_events(false){}{} 来禁用它。",
    "For example, if you\u0027re spawning enemy instances using an alarm, only start that alarm once the {}Rollback Start{} event triggers.":"例如，如果您正在使用警报生成敌人实例，请仅在{}回滚开始{}事件触发时启动该警报。",
    "Further Reading":"延伸阅读",
    "Game Logic":"游戏逻辑",
    "Go ahead and place {}obj_game{} into a room. {}Don\u0027t{} place {}obj_player{}, as it will be created automatically.":"继续并将 {}obj_game{} 放置到房间中。{} 不要{}放置 {}obj_player{}，因为它会自动创建。",
    "However it still allows you to run any other code before the game starts, meaning you must take care to only start your core game logic once all players have joined.":"然而，它仍然允许您在游戏开始之前运行任何其他代码，这意味着您必须注意，只有在所有玩家都加入后才能启动您的核心游戏逻辑。",
    "If the game could not be joined, it returns {}false{}. When the returned value is {}false{}, we call {}{}rollback_create_game(){}{} to host our own game. There we specify that the game should allow a maximum of 2 players.":"如果游戏无法加入，则返回 {}false{}。当返回值为 {}false{} 时，我们调用 {}{}rollback_create_game(){}{} 来托管我们自己的游戏。在那里，我们指定游戏应该允许最多 2 名玩家。",
    "In the Create event of your player object, write this:":"在您的玩家对象的创建事件中，编写以下内容：",
    "In your player object, call {}{}rollback_get_input(){}{} to get a struct containing all of the default inputs, which are as follows:":"在您的玩家对象中，调用 {}{}rollback_get_input(){}{} 获取一个包含所有默认输入的结构，如下所示：",
    "Input is managed by the Rollback system and automatically synchronised between players.":"输入由回滚系统管理，并在玩家之间自动同步。",
    "Inviting Players":"邀请玩家",
    "It first defines the player object to use, and attempts to join a game using&nbsp;{}{}rollback_join_game(){}{}. This function returns {}true{} if the system found a game to join (meaning you are on the correct URL).":"它首先定义要使用的玩家对象，然后尝试使用 {}{}rollback_join_game(){}{} 加入游戏。如果系统找到要加入的游戏 (表示您在正确的 URL 上)，此函数将返回 {}true{}。",
    "Leaving a Room":"离开房间",
    "Major Events":"游戏中的重大事件",
    "Major events in your game, such as a player winning and ending the level, should be done when all players are synchronised. Otherwise, a wrong prediction might wrongly make a player win, which would appear odd when it eventually rolls back.":"游戏中的重大事件，如一名玩家赢得和结束关卡，应该在所有玩家同步时完成。否则，一个错误的预测可能会错误地让一名玩家获胜，当它最终回滚时，这会显得奇怪。",
    "Moving Players":"移动玩家",
    "Now run the game, and you will see both players, where you can control the first one:":"现在运行游戏，你会看到两个玩家，在那里你可以控制第一个：",
    "Now set up the player with the following code in its Create and Step events:":"现在，在其创建和步事件中使用以下代码设置玩家：",
    "Once both game instances have connected and synchronised, you will be able to control each player through its browser window:":"一旦两个游戏实例连接并同步，您将能够通过其浏览器窗口控制每个玩家：",
    "Online Connection":"在线连接",
    "Player Locations":"玩家位置",
    "Player Preferences":"玩家首选项",
    "Project Set-Up":"项目设置",
    "Read the following pages to learn all about the Rollback system:":"请阅读以下页面以了解有关回滚系统的所有信息：",
    "Rollback Constraints":"回滚约束",
    "Rollback Events":"回滚事件",
    "Rollback System":"回滚系统",
    "Run the game through the {}GX.games{} target. When the Rollback system begins, it creates a new \"room\": not a GameMaker room asset, but a {}virtual room{} in which the players will play together.":"通过 {}GX.games{} 目标运行游戏。当回滚系统开始时，它会创建一个新的\"房间\"：不是一个 GameMaker 房间资产，而是一个虚拟房间，玩家将在其中一起游戏。",
    "See the example on {}{}rollback_sync_on_frame(){}{} for doing this properly.":"有关正确操作的信息，请参阅 {}{}rollback_sync_on_frame(){}{} 上的示例。",
    "Sign into&nbsp;{}GX.games{}&nbsp;and set a region in your {}profile settings{}.":"登录 {}GX.games{}，然后在您的{}个人资料设置{}中设置区域。",
    "Since our game has two players, our first player will have the ID {}0{}, and the second player will have the ID {}1{}.":"因为我们的游戏有两个玩家，所以第一个玩家的 ID 为 {}0{}，第二个玩家的 ID 为 {}1{}。",
    "Start a new project, and create a sprite for your player object. You can import an image or just create a filled square.":"开始一个新项目，并为您的球员对象创建一个精灵。您可以导入图像或只创建一个实心正方形。",
    "Starting the Game":"开始游戏",
    "The Rollback system will automatically create player instances when all players have joined, as long as you\u0027re using {}{}rollback_define_player(){}{}.":"回滚系统会在所有玩家都加入后自动创建播放器实例，只要您使用的是 {}{}rollback_define_player(){}{}。",
    "The code above will create two instances of {}obj_player{} at the top-left corner of the room, but they will not yet be controllable.":"上面的代码将在房间的左上角创建 {}obj_player{} 的两个实例，但它们还不是可控制的。",
    "The second player is moving erratically on its own, which is a feature of the Rollback system. It automatically provides random values every frame for all defined inputs, as a basic form of test for your game.":"第二个玩家自己不规律地移动，这是回滚系统的一个特征。它自动为所有定义的输入提供每一帧的随机值，作为游戏的基本测试形式。",
    "This page will take you through the detailed steps for creating your first multiplayer game.{} {} For information on the Rollback system, read&nbsp;{}Rollback System{}.{} {} For details on all Rollback functions, read&nbsp;{}Rollback Functions{}. ":"本页将带您完成创建第一款多人游戏的详细步骤。{}{}有关回滚系统的信息，请阅读{}回滚系统{}。{}{}有关所有回滚功能的详细信息，请阅读{}回滚功能{}。",
    "This sets up a variable with the speed of the player, and in the Step event, gets the input struct.":"这将使用玩家的速度设置一个变量，并在步事件中获取输入结构。",
    "To define your own inputs, see&nbsp;{}Defining Inputs{}.":"要定义您自己的输入，请参阅{}定义输入{}。",
    "When your game starts, you will not see the player instances immediately. Instead, the system will wait for all players to join before starting the game.":"当游戏开始时，您不会立即看到玩家实例。取而代之的是，系统将等待所有玩家加入后再开始游戏。",
    "While waiting, you will see a \"{}Copy Share Url{}\" button below your game. Scroll down if you don\u0027t see the button.":"在等待期间，您将在游戏下方看到一个\"{}复制共享 URL{}\"按钮。如果没有看到按钮，请向下滚动。",
    "You can add chat to your game using {}{}rollback_chat(){}{}.":"您可以使用 {}{}rollback_chat(){}{} 将聊天添加到游戏中。",
    "You can disable automatic random movement by calling {}{}rollback_use_random_input(false){}{}, or {}set up your own \"mock\" input{} for the other player.":"您可以通过调用 {}{}rollback_use_random_input(false){}{} 禁用自动随机移动，或者{}为其他玩家设置您自己的模拟输入{}。",
    "You need to have both browser windows visible at the same time, otherwise the player whose window is hidden will time out and your game will end.":"你需要让两个浏览器窗口同时可见，否则隐藏窗口的玩家将超时，你的游戏将结束。",
    "Your basic multiplayer example is complete, and it\u0027s ready to be taken to the internet.":"您的基本多人游戏示例已经完成，可以将其放到互联网上了。",
    "Your first multiplayer game is now complete!":"你的第一个多人游戏现在完成了！",
    "{}NOTE{} At the moment, you can only create games for up to 4 players.":"{}注意{} 目前，您最多只能创建 4 个玩家的游戏。",
    "{}NOTE{}&nbsp;If you\u0027re using GML Visual, use the corresponding {}Rollback Actions{}.":"{}注意{} 如果您使用的是GML可视化，请使用相应的{}回滚操作{}。",
    "{}TIP{}&nbsp;You can start the game before players have joined by calling {}{}rollback_start_game(){}{}. If you call {}{}rollback_use_manual_start(){}{} then the game will wait for you to start it manually even after all players have joined.":"{}提示{} 您可以在玩家加入之前通过调用 {}{}rollback_start_game(){}{} 开始游戏。如果您调用 {}{}rollback_use_manual_start(){}{}，则游戏将等待您手动启动，即使所有玩家都已加入。",
    "{}This will copy a link to your game, which you can paste into another browser window to join as the second player.":"{}这将复制一个指向您的游戏的链接，您可以将该链接粘贴到另一个浏览器窗口以作为第二个玩家加入。",
    "{}You can open both windows side-by-side by dragging and resizing them.":"{}您可以通过拖动和调整大小来并排打开这两个窗口。",
    "{}obj_game{}: This will manage your multiplayer game.":"{}obj_game{}: 这将管理您的多人游戏。",
    "{}obj_player{}: This will be your actual player object. Each connected player will have their own instance of this object that they can control.{} {} Assign your player sprite to the player object. ":"{}obj_player{}: 这将是您的实际玩家对象。每个连接的玩家都将拥有他们可以控制的该对象的自己的实例。{}{}将您的玩家精灵分配给玩家对象。",
    "{}{}player_id{}{}&nbsp;is a built-in instance variable that stores the ID of the player instance.":"{}{}player_id{}{} 是一个内置的实例变量，存储播放器实例的ID。"
}