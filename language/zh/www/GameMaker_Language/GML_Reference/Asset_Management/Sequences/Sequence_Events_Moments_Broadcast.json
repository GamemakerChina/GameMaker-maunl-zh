{
    "A sequence {}moment{} is a unique code action that is fired on one or more specified frames as the sequence plays. These code moments are - like with events (explained above) - simply predefined {}method variables{} that are triggered on the given frame. For example, say you want a sequence to create a \"bullet\" instance on a specific frame of the animation - first you\u0027d need to create the function that is to be used for this action, something like this:":"序列{}时刻{}是在播放序列时在一个或多个指定帧上触发的唯一代码操作。这些代码矩类似于在给定帧上触发的事件(上面解释的)简单预定义的{}方法变量{}。例如，假设您想要在动画的特定帧上创建\"项目符号\"实例的序列首先需要创建用于此操作的函数，如下所示：",
    "All events need to be associated with functions that are defined in a script, so to set up an event a {}method variable{} must be assigned to a property with the correct name that tells the sequence which event should call the function. The syntax for this is as follows:":"所有事件都需要与在脚本中定义的函数相关联，因此要设置事件，必须将{}方法变量{}分配给具有正确名称的属性，该属性告诉事件调用该函数的顺序。其语法如下：",
    "Apart from all the properties listed {}here{} for a sequence struct, you also have the possibility of adding in special \"action\" properties to a sequence. There are three different types of these \"action\" properties that can be added to a sequence object - {}Events{}. {}Moments{} and {}Broadcast Messages{} - and each of these is explained in more detail in the sections below.":"除了{}这里{}为序列结构列出的所有属性之外，还可以在序列中添加特殊的\"动作\"属性。有三种不同类型的这些\"动作\"属性可以添加到序列对象-{}事件{}。{}时刻{}和{}广播消息{}，以下各节将更详细地解释这些属性。",
    "Events, Moments and Broadcast Messages":"事件、时刻和广播消息的序列",
    "In this function all we\u0027re doing is listening for a mouse press and then reversing the playback direction of the sequence that the method has been bound to. You\u0027ll notice that currently you are not able to pass any parameters to the functions which are linked to these properties, and in all cases the {}{}self{}{} variable within the scope of the function is assigned to be the sequence instance.":"在这个函数中，我们所做的就是听鼠标按一下，然后反转方法绑定到的序列的播放方向。您会注意到，当前您无法向链接到这些属性的函数传递任何参数，并且在所有情况下，函数范围内的{}{}self{}{}变量都被指定为序列实例。",
    "Once a broadcast message has been emitted by the sequence, you can parse it using the {}Other{} &gt; {}Broadcast Message{} event in object instances, which is explained in detail {}here{}.":"序列发出广播消息后，您可以使用对象实例中的{}Other{}&gt;{}广播消息{}事件对其进行解析，此处{}将对此进行详细说明{}。",
    "Sequence Events":"序列事件",
    "Sequence objects can have {}events{} added to them, and these events are analogous to the events used by object assets. The events you assign to a sequence object will occur in a specific order, either once at a defined moment in the sequence life-cycle, or every frame that the sequence is running. In this section, we discuss how these events are handled using code, but they can also be added using the {}Sequence Editor{}. Note that that the order of events listed here is not influenced by the {}playhead{} direction, and even if the sequence is playing backwards, the events will still be run in the order given below.":"序列对象可以添加{}事件{}，这些事件类似于对象资源使用的事件。分配给序列对象的事件将以特定顺序发生，或在序列生命周期中定义的时刻发生一次，或序列正在运行的每个帧发生。在本节中，我们讨论如何使用代码处理这些事件，但也可以使用{}序列编辑器{}添加这些事件。 请注意，此处列出的事件顺序不受{}播放头{}方向的影响，即使序列正在反向播放，事件仍将按以下顺序运行。",
    "Sequences can be made to generate {}broadcast messages{}, which simple strings that are added to specific frames along the animation timeline, and when that point in the timeline is reached, then the string will be broadcast out to all object instances that listen for it. You can add these messages in the IDE using the {}Sequence editor{}, but they can also be created and edited using code.":"序列可以生成{}广播消息{}，这些简单字符串沿动画时间线添加到特定帧，当到达时间线中的该点时，该字符串将被广播到监听该消息的所有对象实例。您可以使用{}序列编辑器{}将这些消息添加到 IDE 中，但也可以使用代码创建和编辑这些消息。",
    "The above code will simply set frames 60, 120, and 180 of the \"moment\" track to call the method {}seq_shoot{}. You\u0027ll notice that currently you are not able to pass any parameters to the functions which are used for each moment, and in all cases the {}self{} variable within the scope of the function is assigned to be the sequence instance (you generally don\u0027t need to use {}self{} but under some special cases it may be useful).":"上述代码将简单地设置\"时刻\"轨道的帧60、120和180，以调用方法{}seq_shoot{}。 您会注意到，当前您无法将任何参数传递给用于每个时刻的函数，并且在所有情况下，函数范围内的{}self{}变量都被指定为序列实例(通常不需要使用{}self{}，但在某些特殊情况下，它可能很有用)。",
    "The available events are:{}{}":"可用的事件包括：{}{}",
    "The sequence struct properties for the different events are as follows:{}{}":"不同事件的序列结构属性如下：{}{}",
    "To assign this to a sequence you would then do something like this:":"要将其分配给序列，您需要执行以下操作：",
    "To create a broadcast message on a sequence using GML, you need to add them to a frame in the {}messageEventKeyframes{} property of the sequence struct. This is essentially a \"special\" track that is only used for this purpose and so can only take keyframe data that is associated with the broadcast messages that you want the sequence to have. This track is created in much the same way as you would create any other track, by creating keyframe structs and filling them with keyframe data, where channel 0 is the only channel that you can use and the track type is {}seqtracktype_message{}. Below is an example of how this would be created:":"要使用GML在序列上创建广播消息，需要将它们添加到序列结构的{}messageEventKeyframes{}属性中的帧中。这本质上是一个\"特殊\"轨迹，仅用于此目的，因此只能获取与您希望序列具有的广播消息相关联的关键帧数据。通过创建关键帧结构并用关键帧数据填充关键帧数据，创建此轨迹的方式与创建任何其他轨迹的方法基本相同，其中通道 0 是唯一可以使用的通道，轨迹类型为{}seqtracktype_message{}。 下面是如何创建示例：",
    "To give an example of use, let\u0027s say we want the sequence to reverse direction when a left mouse button click is detected. We would first need to create a script with the function that we want to call, something like this:":"举一个使用的例子，假设我们想要序列在检测到鼠标左键单击时反转方向。我们首先需要创建一个脚本，其中包含我们想要调用的函数，如下所示：",
    "We have now assigned a step event to the sequence {}object{} with a function to detect when a mouse is pressed and then change the playhead direction of the sequence {}instance{} after it has been created in a room.":"现在，我们已经为序列{}对象{}分配了一个步骤事件，该事件具有一个函数，用于检测何时按下鼠标，然后在房间中创建序列{}实例{}后更改其播放头方向。",
    "You would then add this to a frame in the {}momentKeyframes{} property of the sequence struct. This is essentially a \"special\" track that is only used for this purpose and so can only take keyframe data that is associated with moment actions that you want the sequence to have. This track is created in much the same way as you would create any other track, by creating keyframe structs and filling them with keyframe data, where channel 0 is the only channel that you can use and the track type is {}seqtracktype_moment{}. Below is an example of how this would be created, using the function we defined above to fire on the given moments (frames):":"然后，您可以将此添加到序列结构的{}momentKeyframes{}属性中的帧中。这本质上是一个\"特殊\"轨迹，仅用于此目的，因此只能获取与您希望序列具有的瞬间操作相关联的关键帧数据。通过创建关键帧结构并填充关键帧数据(通道 0 是唯一可以使用的通道，轨迹类型为{}seqtracktype_moment{})，创建此轨迹的方式与创建任何其他轨迹的方式基本相同。 下面是如何使用我们上面定义的函数在给定时刻(帧)上激发该值的示例：",
    "You\u0027ll notice that the message text is passed to the keyframe data channel as an array. This is because you can broadcast multiple messages on the same frame, and have different object instances listen for them and react differently depending on the message they are actually expecting.":"您将注意到，消息文本作为数组传递到关键帧数据通道。这是因为您可以在同一帧上广播多条消息，并让不同的对象实例侦听它们，并根据它们实际期望的消息做出不同的反应。",
    "{}Async System{}: triggered the same as any object {}Asynchronous System Event{} handlers. {}{}Important!{} If the sequence is paused then this event will not be triggered.{}":"{}异步系统{}： 触发的对象与任何对象{}异步系统事件{}处理程序相同。{}{}重要！{}如果序列暂停，则不会触发此事件。{}",
    "{}Begin Step{}: triggered just before the object begin-step event. {}Important!{} If the sequence is paused then this event will not be triggered until the next step after the sequence starts playing again.":"{}步开始{}：在对象开始步骤事件之前触发。{}重要！{}如果序列暂停，则在序列再次开始播放后的下一步骤之前，不会触发此事件。",
    "{}Broadcast Messages{}":"{}广播消息{}",
    "{}Broadcast Message{}: triggered during sequence update as a broadcast message keyframe is encountered.":"{}广播消息{}：遇到广播消息关键帧，序列更新时触发。",
    "{}Clean-up{}: this is triggered when a sequence instance is garbage collected.":"{}清除{}：当序列实例被垃圾回收时触发。",
    "{}Create{}: this is triggered when a sequence instance is created on a layer.":"{}创建{}：在层上创建序列实例时触发。",
    "{}Destroy{}: this is triggered when a sequence instance on a layer is destroyed.":"{}销毁{}：当层上的序列实例被破坏时触发。",
    "{}End Step{}: triggered just before the object end-step event. {}Important!{} If the sequence is paused then this event will not be triggered until the next step after the sequence starts playing again.":"{}步结束{}：在对象结束步骤事件之前触发。{}重要！{}如果序列暂停，则在序列再次开始播放后的下一步骤之前，不会触发此事件。",
    "{}Moments{}":"{}时刻{}",
    "{}NOTE{}: It\u0027s worth noting that in the above script the {}self{} identifier can be omitted and is only used to explicitly show the scope of the method variable being used for this example.":"{}注意{}：值得注意的是，在上面的脚本中，{}self{}标识符可以省略，并且仅用于显式显示用于此示例的方法变量的范围。",
    "{}Step{}: triggered just before the usual object step event. {}Important!{} If the sequence is paused then this event will not be triggered until the next step after the sequence starts playing again.":"{}步{}：在通常的对象步骤事件之前触发。{}重要！{}如果序列暂停，则在序列再次开始播放后的下一步骤之前，不会触发此事件。",
    "{}{}{}NOTE{}{}{} It\u0027s worth noting that in the above script the {}self{} identifier can be omitted and is only used to explicitly show the scope of the method variable being used for this example.":"{}{}{} 注意{}{}{} 值得注意的是，在上述脚本中，{}self{} 标识符可以省略，仅用于显式显示本示例中使用的方法变量的范围。"
}