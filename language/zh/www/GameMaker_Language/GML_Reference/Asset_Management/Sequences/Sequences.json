{
    "Before using these functions to create or edit sequences, we recommend that you read the detailed descriptions given below for the struct properties. A general overview of how to create a new sequence would be:":"在使用这些函数创建或编辑序列之前，我们建议您阅读下面给出的结构属性的详细说明。如何创建新序列的一般概述如下：",
    "Before you can add tracks to the sequence object, you need to create them, so you\u0027d now create an array of {}asset{} tracks that have been defined with the function {}{}sequence_track_new(){}{}. Note that in code, there is really no difference between asset tracks and parameter tracks - they are all simply tracks and how they behave will depend on the type of&nbsp;track you create and whether they are assigned as sub-tracks to a top level track or not. So, you would create a track for an asset, and then assign sub-tracks for the different parameters to it and these sub-tracks would act as the {}parameter{} tracks for the asset. The example below creates a single graphics asset track that will be added to the sequence later:":"在将轨迹添加到sequence对象之前，您需要创建它们，因此您现在需要创建一个{}asset{}轨迹的数组，这些轨迹是使用函数{}{}sequence_track_new(){}{}定义的。请注意，在代码中，资源轨迹和参数轨迹之间实际上没有区别-它们都是简单的轨迹，它们的行为方式将取决于您创建的轨迹类型，以及它们是否作为子轨迹分配给顶级轨迹。因此，您可以为资源创建一个轨迹，然后为其分配不同参数的子轨迹，这些子轨迹将充当资源的{}参数{}轨迹。下面的示例创建了一个图形资源轨迹，稍后将添加到序列中：",
    "Create the new sequence object using the function {}{}sequence_create(){}{} and store the sequence object index in a variable. This index gives you access to the sequence object struct.":"使用函数{}{}sequence_create(){}{}创建新的序列对象，并将序列对象索引存储在变量中。此索引允许您访问序列对象结构。",
    "Each asset track needs to have some data to tell the sequence how it will look, or its position , etc... and this is added in the form of {}keyframes{}. At the top level for an asset track, you can set keyframes for various things (listed in the section on the Track Struct, below), but note that as these are asset track keyframes, they won\u0027t be interpolated and will simply change the value they refer to when the given frame is reached. Each keyframe is a struct that is added to an array, and then this array is assigned to the asset track. To create the keyframe struct we would call the function {}{}sequence_keyframe_new(){}{} and to populate the keyframe with the required data, we would use the function {}{}sequence_keyframedata_new(){}{}:":"每个资源轨道需要一些数据来告诉序列其外观、位置等... 并以{}关键帧{}的形式添加。 在资源跟踪的顶层，您可以为各种对象设置关键帧(在下面的\"跟踪结构\"部分列出)，但请注意，由于这些是资源跟踪关键帧，所以它们不会被插值，而只是在达到给定帧时更改它们所引用的值。每个关键帧是添加到数组的结构，然后将该数组分配给资源轨迹。若要创建关键帧结构，我们将调用函数{}{}sequence_keyframe_new(){}{}，并使用函数{}{}sequence_keyframedata_new(){}{}：",
    "Events, Moments and Broadcast Messages":"事件、时刻和广播消息",
    "Finally, as mentioned above, you have the {}sequence data{}, which is another struct. This struct contains {}all{} the data about the sequence. The tracks it contains, the properties those tracks have, the playback speed and much more. The exact details of this structs contents are outlined below, but basically consists of {}asset track{} structs and {}parameter track{} structs which use {}keyframe data{} to actually perform actions while the sequence plays.":"最后，如上所述，有{}序列数据{}，这是另一种结构。此结构包含{}关于序列的所有{}数据。它包含的音轨、这些音轨的属性、播放速度等等。此结构内容的确切细节概述如下，但基本上由{}资源轨道{}结构和{}参数轨道{}结构组成，它们使用{}关键帧数据{}在序列播放时实际执行动作。",
    "Finally, it is possible to add code to sequences that can be triggered as either an&nbsp;{}event{}&nbsp;a&nbsp;{}moment{}&nbsp;or as a&nbsp;{}broadcast message{}. This is explained fully on the following page:":"最后，可以向序列添加代码，这些序列可以作为{}事件{}时刻{}或作为{}广播消息{}触发。 详见下页：",
    "Next you have {}sequence objects{} and {}sequence instances{} much like you have general objects and instances. A sequence {}object{} is the base resource as you created it in the {}Asset Browser{} or using the function {}{}sequence_create(){}{}, and the sequence {}instance{} is the \"copy\" of that sequence object that has been placed in a room as an element on a layer. Think of sequence objects as blueprints and sequence instances as the creation from those blueprints. Sequence objects and instances are {}structs{} and - unlike regular objects - a sequence object struct can be edited at runtime, which will affect all further instances of that sequence when you create them as elements (and any editing done to a sequence object will {}not{} be reset by restarting the game or the room using the {}room_restart(){} or {}game_restart(){} functions). The sequence instance struct contains a few parameters to control playback and things (this is explained in more detail below) as well as the {}sequence data{} struct.":"接下来，您有{}序列对象{}和{}序列实例{}，就像您有一般对象和实例一样。序列{}对象{}是您在{}资源浏览器{}中或使用函数{}{}sequence_create(){}{}创建时的基本资源，序列{}实例{}是该序列对象的\"副本\"，该序列对象作为层上的元素放置在房间中。将序列对象视为蓝图，将序列实例视为这些蓝图的创建。序列对象和实例是{}结构{}，与常规对象不同，序列对象结构可以在运行时被编辑，当您将序列对象创建为元素时，这将影响该序列的所有其他实例(对序列对象所做的任何编辑都不会{}通过使用{}room_restart(){}或{}game_restart(){}函数重新启动游戏或房间来重置{})。序列实例结构包含一些参数来控制回放和东西(下面将更详细地说明)以及{}序列数据{}结构。",
    "Sequence elements are dealt with using the room {}layer functions{}, but for sequence objects, instances and data we have the following functions:":"序列元素使用房间{}层函数{}处理，但对于序列对象、实例和数据，我们具有以下函数：",
    "Sequences":"序列",
    "Sequences are usually created in the IDE using the {}Sequence editor{}, but they can also be created and edited using code. However, before looking at the functions available, it\u0027s important to understand the way that sequences are defined in {}GameMaker{}&nbsp;and the different terms that will be used.":"序列通常使用{}序列编辑器{}在IDE中创建，但也可以使用代码创建和编辑序列。然而，在查看可用函数之前，了解{}GameMaker{}中定义序列的方式以及将使用的不同术语是很重要的。",
    "Set the sequence object top level values like length, play mode, play speed, etc... For example:":"设置序列对象的顶级值，如长度、播放模式、播放速度等。例如：",
    "The above instructions create a very simple sequence object that draws a sprite at the (0, 0) position {}of the sequence{} and then moves it to the bottom-right corner and back in a loop. As mentioned, there are a number of places where you need to access different structs to give or get data about the sequence, and the sections below list all the different properties that these structs contain:":"上面的指令创建一个非常简单的序列对象，该对象在序列{}的(0，0)位置{}绘制一个精灵，然后将其移动到右下角并循环返回。如上所述，需要访问不同结构以给出或获取序列数据的多个位置，以下各节列出了这些结构包含的所有不同属性：",
    "There is also a&nbsp;{}built-in variable{}&nbsp;associated with instances that can be used to determine of the instance has been used in a sequence or not:":"还有一个与实例关联的{}内建变量{}，可用于确定该实例是否在序列中使用：",
    "To start with, at the top level, you have a {}sequence element{}. This is what you place on a layer in a room, either through the Room Editor or in code using the appropriate {}layer functions{}. The layer element has no real properties other than an element ID value, but this ID is required to use the above mentioned layer functions to change the sequence playback or to access the sequence data.":"首先，在顶层，您有一个{}序列元素{}。 这是您通过\"房间编辑器\"或使用适当的{}层函数{}在代码中放置在房间的图层上的内容。 层元素除了元素ID值之外没有实际属性，但是需要该ID来使用上述层函数来改变序列回放或访问序列数据。",
    "We now need to create a parameter track which we\u0027ll assign as a sub-track to the graphics track we just created. This will be done in a similar way as shown above, only now we need to give the track a name that shows its purpose, in this case \"position\" as we\u0027ll be using this track to move the graphics track track over the course of the sequence animation frames:":"我们现在需要创建一个参数轨道，我们将把它作为一个子轨道分配给我们刚刚创建的图形轨道。这将以与上面所示类似的方式完成，只是现在我们需要为轨迹命名，以显示其用途，在本例中为\"位置\"，因为我们将使用此轨迹在序列动画帧的过程中移动图形轨迹轨迹：",
    "With that done, the final thing to do is assign the parameter track as a sub-track to our main graphics asset track that we created at the beginning and then assign these tracks to the sequence which we can then create an instance of in the room:":"完成后，要做的最后一件事是将参数轨迹作为子轨迹分配给我们在开始时创建的主图形资源轨迹，然后将这些轨迹分配给序列，然后我们可以在房间中创建一个实例：",
    "{}IMPORTANT!{}&nbsp;If your sequence has any instances in it, these instances shouldn\u0027t change their&nbsp;{}{}image_xscale{}{}&nbsp;&nbsp;/&nbsp;{}{}image_yscale{}{}&nbsp;/ {}{}image_angle{}{}&nbsp;/&nbsp;{}{}x{}{}&nbsp;/&nbsp;{}{}y{}{} variables as they will be&nbsp;overwritten when the sequence updates each step after starting to be played.":"{}重要{}如果您的序列中包含任何实例，这些实例不应更改其{}{}image_xscale{}{}/{}image_yscale{}/{}{}image_angle{}{}/{}{}x{}{}/{}{}y{}{}变量，因为当序列在开始播放后更新每个步骤时，它们将被覆盖。",
    "{}The Keyframe Data Struct{}":"{}关键帧数据结构{}",
    "{}The Keyframe Struct{}":"{}关键帧结构{}",
    "{}The Sequence Instance Struct{}":"{}序列实例结构{}",
    "{}The Sequence Object Struct{}":"{}序列对象结构{}",
    "{}The Track Struct{}":"{}轨迹结构{}"
}