{
    "An exception to the above rule is when dealing with 32bit colour values. You can pass into the shader up to eight 32bit colour values and they will automatically be converted for you into vec4 values of 0 - 1. However for this you {}must{} use the shader constant name {}in_Colour{}, for a single colour, or {}in_Colour0{}, {}in_Colour1{}, etc... up to {}in_Colour7{} for multiple input values. The following to examples show how this would look in the shader itself:":"上述规则的例外情况是处理32位颜色值时。可以将多达八个 32 位颜色值传递到着色器中，它们将自动转换为 0-1 的 vec4 值。但是，为此，{}必须使用{}着色器常量名称{}in_Colour{}表示单一颜色，或{}in_Colour0{}、{}in_Colour1{}等... 最多{}in_Colour7{}用于多个输入值。下面的示例显示了在着色器本身中的外观：",
    "Note too that if you want to do compressed normals etc... using a 4 byte colour format, then you will also have to use the same \"in_Colour\" format as shown above too.":"也请注意，如果你想做压缩法线等。使用4字节的颜色格式，那么你也必须使用相同的\"_颜色\"格式，如上图所示。",
    "The above code will get the handle of the shader constant \"u_vParams\" ( a {}vec3{}), then set that constant to the given values.":"上面的代码将获得着色器常量\"u_vParams\"(a{}vec3{})的句柄，然后将该常量设置为给定值。",
    "The floating point value (or values) to set the shader constant to.":"要将着色器常量设置为的浮点值。",
    "The handle of the shader constant to set.":"要设置的着色器常量的句柄。",
    "With this function you can set the value (or values) of a shader constant. You must previously have gotten the \"handle\" of the constant using the function {}{}shader_get_uniform(){}{}, and you will have to know what type of constant it is to pass the correct number of floating point values through to it, ie: if you have a {}vec2{} you will need to pass two values to the function.":"使用此函数，可以设置着色器常量的值。您必须之前使用函数{}{}shader_get_uniform(){}{}获得常量的\"句柄\"，并且您必须知道将正确数目的浮点值传递给它的常量类型，即：如果您有一个{}vec2{}，则需要将两个值传递给函数。",
    "{}{}{}NOTE{}: All uniforms must be set {}after{} calling the function {}{}{}shader_set(){}{}{}, and before calling {}{}{}shader_reset(){}{}{}.":"{}{}{}注意{}：在{}调用函数{}{}{}shader_set(){}{}{}后，在调用{}{}{}shader_reset(){}{}{}之前，必须设置所有制服{}。"
}