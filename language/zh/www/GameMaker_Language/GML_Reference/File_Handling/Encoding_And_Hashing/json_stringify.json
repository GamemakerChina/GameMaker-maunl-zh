{
    "Care should be taken when writing any returned&nbsp;JSON&nbsp;string to an {}ini{} file, as the {}ini{} specifications can cause issues when using quotes and escape characters. See the function {}{}ini_write_string(){}{} for more information.":"将任何返回的 JSON 字符串写入 {}ini{} 文件时应小心，因为 {}ini{} 规范在使用引号和转义字符时可能会导致问题。 有关详细信息，请参阅函数 {}{}ini_write_string(){}{}。",
    "If the provided struct contains any circular references, such as references back to the main struct itself (forming an infinite loop) or references to structs within the main struct forming such infinite loops, such references will be converted to {}\"null\"{} upon stringifying.":"如果提供的结构包含任何循环引用，例如回溯到主结构本身的引用 (形成无限循环) 或对形成这种无限循环的主结构内的结构的引用，则此类引用将在字符串化时转换为 {}\"null\"{}。",
    "If you include an int64 in the values to convert to&nbsp;JSON it will write it as an {}int{} if it is in the valid range for an int32, as a {}double{} if it can do so without losing precision or (if neither of those cases is applicable) as a {}string{} with an identifier \"{}@i64@{}\" before it and \"{}$i64${}\" after it. When you come to parse the JSON&nbsp;again {}GameMaker{} will pick these identifiers up and re-convert the value back into an int64. This does mean that if the JSON is intended for a server or some other non-GameMaker target, these values will not be appropriate and so should be avoided.":"如果您在要转换为 JSON 的值中包含一个 int64，如果它在 int32 的有效范围内，它将把它写成 {}int{}，如果它可以在不损失精度的情况下写成 {}double{} 或 (如果这两种情况都不适用) 作为 {} 字符串 {}，其前面有标识符“{}@i64@{}”，后面有“{}$i64${}”。 当您再次解析 JSON 时，{}GameMaker{} 将选取这些标识符并将值重新转换回 int64。 这确实意味着如果 JSON 用于服务器或其他一些非 GameMaker 目标，则这些值将不合适，因此应避免使用。",
    "If you include {}infinity{}, {}-infinity{} or {}NaN{}&nbsp;in the values to convert to JSON, they will be encoded as strings as these values are not part of the JSON standard, and on parsing the resulting JSON they will {}not {}be converted back into their runtime values and&nbsp;will stay as strings. Note that {}NaN{} will be converted into \"nan\" (lowercase) upon stringifying.":"如果您在要转换为 JSON 的值中包含 {}infinity{}、{}-infinity{} 或 {}NaN{}，它们将被编码为字符串，因为这些值不是 JSON 标准的一部分，并且在 在解析生成的 JSON 时，它们 {} 不会 {} 转换回它们的运行时值，并且将保留为字符串。 请注意，{}NaN{} 将在字符串化时转换为“nan”(小写)。",
    "If you include {}{}undefined{}{} in the struct, it will be encoded as {}\"null\"{}, and upon reading that back into GameMaker you will get {}{}pointer_null{}{}.":"如果在结构中包含 {}{}undefined{}{}，它将被编码为 {}\"null\"{}，在读回 GameMaker 时，您将获得 {}{}pointer_null{}{}。",
    "If you include{}&nbsp;{}{}infinity{},{}&nbsp;{}{}-infinity{}{}&nbsp;{}or{}&nbsp;{}{}NaN{}&nbsp;in the values to convert to JSON, they will be encoded as strings as these values are not part of the JSON standard, and on parsing the resulting JSON they will{}&nbsp;{}{}not{}&nbsp;{}{}be converted back into their runtime values and&nbsp;will stay as strings. Note that{}&nbsp;{}{}NaN{}{}&nbsp;{}will be converted into {}\"nan\"{} (lowercase) upon stringifying. {} {}{}On HTML5 however, {}infinity{}{} and {}{}NaN{}{} will be written into the JSON as {}\"@@infinity$$\"{} ({}\"@@-infinity$$\"{} for negative) and {}\"@@nan$$\"{} respectively. These values will be correctly loaded back into memory when the JSON is loaded with {}{}json_parse{}{}.{} {} ":"如果包含{} {}{}infinity{}，{} {}{}-infinity{}{} {}或{} {}{}NaN{} 在要转换为 JSON 的值，它们将被编码为字符串，因为这些值不是 JSON 标准的一部分，并且在解析得到的 JSON 时，它们将{}{}{}不会{}{}{}转换回它们的运行时值，而将保留为字符串。请注意，在字符串注册时，{} {}{}NaN{}{} {}将转换为{}\"nan\"{}(小写)。{}{}{} 然而，在 HTML5 上，{}infinity{}{} 和 {}{}NaN{}{} 将分别作为 {}\"@@infinity$$\"{}({}\"@@-infinity$\"{} 表示否定)和 {}\"@@NaN$$\"{} 写入 JSON。当 JSON 加载了 {}{}json_parse{}{}时，这些值将正确加载到内存中.{}{}",
    "The above code converts the {}_contents{} struct into a JSON string and stores it in a variable. With the {}pretty_print{} parameter set to {}true{}, the struct\u0027s contents are {}pretty printed{} to the string, i.e. indentation and line breaks are inserted to make the resulting string look \"pretty\" and more readable. The string then looks like this:&nbsp;":"上面的代码将 {}_contents{} 结构转换为 JSON 字符串并将其存储在变量中。当 {}pretty_print{} 参数设置为 {}true{} 时，结构的内容将被{}美化输出{}到字符串中，即插入缩进和换行符，以使结果字符串看起来\"漂亮\"且更具可读性。然后，字符串看起来如下所示：",
    "The above code will convert&nbsp;the {}_contents{} struct into a JSON string and store the string in a variable. The returned string would look like this:":"上面的代码会将 {}_contents{} 结构转换为 JSON 字符串并将该字符串存储在一个变量中。 返回的字符串如下所示：",
    "The above code will convert&nbsp;the {}_contents{} struct into a JSON string and stores the string in a variable. The returned string would look like this:":"上面的代码会将 {}_contents{} 结构转换为 JSON 字符串并将该字符串存储在一个变量中。 返回的字符串如下所示：",
    "The function will convert just about any value into a \"valid\" JSON string, however the actual values contained in the string may not be exactly what you expect due to the way that the JSON standard operates:{} {} \"JSON is agnostic about numbers. In any programming language, there can be a variety of number types of various capacities and complements, fixed or floating, binary or decimal. That can make interchange between different programming languages difficult. JSON instead offers only the representation of numbers that humans use: a sequence of digits. All programming languages know how to make sense of digit sequences even if they disagree on internal representations.\"{} {} For more information see the {}ECMA JSON Standard{}. ":"该函数将几乎任何值转换为“有效的”JSON 字符串，但是由于 JSON 标准的操作方式，字符串中包含的实际值可能不是您所期望的 :{}{}“JSON 与数字无关。在任何编程语言中，都可以有各种容量和补数的数字类型，固定的或浮动的，二进制或十进制的。这可能会使不同编程语言之间的交换变得困难。相反，JSON 只提供人类使用的数字表示 : 数字序列。所有的编程语言都知道如何理解数字序列，即使它们在内部表示上存在分歧。“{}{} 更多信息请参见 {}ECMA JSON 标准 {}。",
    "The function will&nbsp;{}not&nbsp;{}&nbsp;convert DS maps, lists or any other data structure into JSON, and will simply store the internal index value for the structure (which is of little use as the index will change between runs of the game), and as such you should not try to stringify any value that may contain references to data structures (for that you have {}{}json_encode(){}{}).":"函数将 {} 不会 {} 将 DS 映射、列表或任何其他数据结构转换为 JSON，并将简单地存储结构的内部索引值 (这没什么用，因为索引会在游戏运行期间发生变化)，因此你不应该尝试字符串化任何可能包含数据结构引用的值 (因为你有 {}{}json_encode(){}{})。",
    "The reference value for a struct or array to convert into a JSON string":"要转换为 JSON 字符串的结构或数组的引用值",
    "When using this function there are some important things to note:":"在使用这个函数时，有一些重要的事情需要注意:",
    "With this function you can convert single or nested structs and arrays into a valid JSON string.":"通过这个函数，您可以将单个或嵌套的结构和数组转换为有效的 JSON 字符串。",
    "With this function you can convert single or nested structs and arrays into a valid JSON string. You supply the initial value to use (an array index or a struct reference) and then the function will \"stringify\" it, converting it into a JSON&nbsp;string (converting GameMaker arrays into JSON arrays,&nbsp;and GameMaker structs into JSON objects).":"通过这个函数，您可以将单个或嵌套的结构和数组转换为有效的 JSON 字符串。你提供使用的初始值 (数组索引或结构引用)，然后函数将其“字符串化 (stringify)”，将其转换为 JSON 字符串 (将 GameMaker 数组转换为 JSON 数组，和 GameMaker 结构转换为 JSON 对象)。",
    "You supply the initial value to use (an array index or a struct reference) and then the function will \"stringify\" it, converting it into a JSON&nbsp;string (converting GameMaker arrays into JSON arrays,&nbsp;and GameMaker structs into JSON objects). You can optionally choose to \"pretty print\" it, meaning the final JSON will be formatted for easy readability.":"你提供使用的初始值 (数组索引或结构引用)，然后函数将其\"字符串化 (stringify)\"，将其转换为 JSON 字符串 (将 GameMaker 数组转换为 JSON 数组，和 GameMaker 结构转换为 JSON 对象)。 您可以选择\"美化输出\"它，这意味着最终的 JSON 将被格式化以便于阅读。",
    "{}{}OPTIONAL{}{}&nbsp;Whether to pretty print the string, i.e. insert indentation and line breaks for readability":"{}{}可选{}{} 是否美化输出字符串，即插入缩进和换行符以提高可读性",
    "{}{}infinity{}{} and {}{}NaN{}{} will be written into the JSON as {}\"@@infinity$$\"{} ({}\"@@-infinity$$\"{} for negative) and {}\"@@nan$$\"{} respectively. These values will be correctly loaded back into memory when the JSON is loaded with {}{}json_parse{}{}.":"{}{}infinity{}{} 和 {}{}NaN{}{} 将分别作为 {}\"@@infinity$$\"{}({}\"@@-infinity$$\"{} 表示负数) 和 {}\"@@nan$$\"{} 写入 JSON。当使用 {}{}json_parse{}{} 加载 JSON 时，这些值将正确加载回内存。"
}