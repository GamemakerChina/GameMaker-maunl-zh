{
    "If you pass the function a struct literal (i.e.: a struct that was created without using a constructor function) then it will simply return the string {}\"struct\"{}.":"如果向函数传递结构文字 (即：不使用构造函数创建的结构)，则它将简单地返回字符串 {}\"struct\"{}。",
    "In this example we must first define the function that will be used as the constructor for our struct. The following function is defined in a script asset:":"在这个例子中，我们必须首先定义将用作我们结构的构造函数。在脚本资源中定义了以下函数:",
    "Note that if you pass the function a struct literal (i.e.: a struct that was created without using a constructor function) then it will simply return the string {}\"struct\"{}.":"请注意，如果你传递函数一个结构文字 (即: 一个没有使用构造函数创建的结构)，那么它将简单地返回字符串{}“struct”{}。",
    "The returned constructor name will include additional text if the constructor function was not created in a script. If it was created inside an object, its name will include the object and the event where it was created. For example, a constructor called {}test_constructor{} created in the Create event of {}Object1{} will be returned as {}\"test_constructor_gml_Object_Object1_Create_0\"{}. To avoid this, create your constructors in a {}script{}.":"如果未在脚本中创建构造函数，则返回的构造函数名称将包含其他文本。如果它是在对象内部创建的，则其名称将包括该对象和创建该对象的事件。例如，在{}Object1{}的创建事件中创建的名为{}test_constructor{}的构造函数将返回为{}“test_constructor_gml_Object_Object1_Create_0”{}。为了避免这种情况，请在{}脚本{}中创建构造函数。",
    "The struct reference to use.":"要使用的struct引用。",
    "This function can also be used to check if a struct reference is a&nbsp;{}{}weak reference{}{}&nbsp;or not, in which case the function will return the string {}\"weakref\"{} instead of the name of the function that created the struct. For more information, see the function {}{}weak_ref_create(){}{}.":"该函数还可以用来检查struct引用是否是{}{}弱引用{}{}，在这种情况下，函数将返回字符串{}“weakref”{}，而不是创建结构的函数的名称。有关更多信息，请参见函数{}{}weak_ref_create(){}{}。",
    "This function can be used to get the name of the {}constructor function{} that was used to create a struct. The struct itself should have been created using the {}{}{}{} {}{}new{}{} operator along with the constructor itself. You supply the variable with the struct reference to check and the function will return either a string with the constructor name or {}undefined{}.":"此函数可用于获取用于创建结构的{}构造函数{}的名称。结构本身应该是使用{}{}{}{} {}{}new{}{} 运算符以及构造函数本身创建的。您为变量提供要检查的struct引用，该函数将返回具有构造函数名称的字符串或 {}undefined{}。",
    "This function can then be used along with the {}new{} operator to create a struct and populate it with the variables set to the values of the arguments used in the function:":"然后可以将此函数与{}new{}运算符一起使用，以创建一个结构，并使用设置为函数中使用的参数值的变量来填充它:",
    "This will print the string {}\"init_struct\"{} to the output log, which is the name of the constructor function as defined in its script.":"这会将字符串{}“init_struct”{}打印到输出日志中，该日志是其脚本中定义的构造函数的名称。",
    "Usage Notes":"用法说明",
    "We can then get the name of the constructor function that was used like this:":"然后，我们可以得到这样使用的构造函数的名称:",
    "{}{}TIP{}{}&nbsp;It\u0027s recommended to use&nbsp;{}{}is_instanceof{}{}&nbsp;to check the constructor of a struct, as it additionally allows you to check using parent constructors (i.e. constructors that the struct\u0027s constructor may have inherited from).&nbsp;{}{}is_instanceof{}{}&nbsp;also allows you to check using the constructor function reference directly instead of strings.":"{}{}提示{}{} 建议使用 {}{}is_instanceof{}{} 检查结构的构造函数，因为它还允许您使用父构造函数 (即结构的构造函数可能继承自的构造函数) 进行检查。{}{}is_instanceof{}{} 还允许您直接使用构造函数引用而不是字符串进行检查。"
}