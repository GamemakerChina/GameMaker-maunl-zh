{
    "If there are multiple packets being returned to your game, the callback \"status\" key will return 1, in which case the DS map&nbsp;will have the following additional keys:":"如果有多个数据包返回到您的游戏，回调“status”键将返回 1，在这种情况下，DS 地图将具有以下附加键：",
    "The above code will first check the id of the DS map that has been created, then check the \"status\" of the callback. If the value is equal to 0 (signalling success) the result from the callback will then be stored in a variable for future use, otherwise the variable will be set to a default value (in this case \"null\").":"上面的代码会首先检查已经创建的DS地图的id，然后检查回调的“状态”。 如果该值等于 0(表示成功)，则回调的结果将存储在一个变量中以供将来使用，否则该变量将设置为默认值(在本例中为“null”)。",
    "The above code will pass the string held in the variable \"name\" to the given server as well as retrieve the data from that URL, triggering an Async Event which will contain the async_load&nbsp;DS map (the async_load map index will be stored in the variable \"get\" so you can check for the correct callback). The Async Event triggered would be the {}HTTP{} sub-event, and in that event you would have the following:":"上面的代码会将保存在变量“name”中的字符串传递给给定的服务器，并从该 URL 检索数据，触发一个包含 async_load&nbsp;DS 映射的异步事件(async_load 映射索引将存储在 变量“get”，以便您可以检查正确的回调)。 触发的异步事件将是 {}HTTP{} 子事件，在那种情况下，您将拥有以下内容：",
    "The web address of the server that you wish to get information from":"您希望从中获取信息的服务器的 Web 地址",
    "The {}http_get(){} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}http_get(){} 函数可以从任何事件调用，并且由于它是异步的，回调几乎可以是即时的，也可能需要几秒钟。 调用函数很简单，看起来像这样：",
    "This function will generate multiple \"call backs\" which are picked up by any {}HTTP Events{}. These will generate a {}{}DS Map{}{} (more commonly known as a \"dictionary\") that is exclusive to this event and is stored in the special variable {}{}async_load{}{}. This DS map will contain different values depending on whether there is data being returned or not. For example, if you have requested a file, the event will trigger multiple times as each packet of data is received so that you can show a progress bar, for example. The general structure for the DS map will be as follows:":"此函数将生成多个“回调”，这些回调由任何 {}HTTP 事件{}获取。 这些将生成专用于该事件并存储在特殊变量 {}{}async_load{}{} 中的 {}{}DS map{}{}(通常称为“字典”)。 根据是否有数据返回，此 DS 映射将包含不同的值。 例如，如果您请求了一个文件，该事件将在收到每个数据包时触发多次，以便您可以显示进度条等。 DS 映射的一般结构如下：",
    "With this function, you connect to the specified URL in order to retrieve information. As this is an asynchronous function, {}GameMaker{} will not block while waiting for a reply, but will keep on running unless it gets callback information. This information will be in the form of a string and will trigger an {}Async Event{} in any instance that has one defined in their object properties. You should also note that HTTP request parameters (the bits sometimes \"tacked on\" to the end of a URL when you submit a form on a web page) are perfectly acceptable when using this function, for example:":"使用此函数，您可以连接到指定的 URL 以检索信息。 由于这是一个异步函数，{}GameMaker{} 在等待回复时不会阻塞，而是会继续运行，除非它获得回调信息。 此信息将采用字符串形式，并会在对象属性中定义的任何实例中触发{}异步事件{}。 您还应注意，在使用此函数时，HTTP 请求参数(当您在网页上提交表单时，这些位有时会“附加”到 URL 的末尾)是完全可以接受的，例如：",
    "will pass the string held in the variable \"name\" to the server as well a retrieve the data from that URL. So, essentially, any time a simple, short piece of data needs to be passed from the client to the server, this would be reasonable choice as the function to use.":"会将保存在变量“name”中的字符串传递给服务器，并从该 URL 检索数据。 因此，本质上，任何时候需要将一段简单、简短的数据从客户端传递到服务器时，这都是合理的选择作为要使用的函数。",
    "{}\"contentLength\": {}This is the size of file that the web server has said you should expect to receive (may be -1 if the server does not return this data).":"{}\"contentLength\"：{}这是网络服务器表示您应该预期收到的文件大小(如果服务器不返回此数据，则可能为 -1)。",
    "{}\"sizeDownloaded\": {}The size of the data that has already been downloaded.":"{}\"sizeDownload\": {}已下载的数据的大小。",
    "{}NOTE{}: You should be aware that due to XSS protection in browsers, requests to and attempts to load resources from across domains are blocked and may appear to return blank results. Please see the section on {}Cross Domain Issues{} for further details.":"{}注意{}：您应该知道，由于浏览器中的 XSS 保护，从跨域加载资源的请求和尝试会被阻止，并且可能会返回空白结果。 有关更多详细信息，请参阅{}跨域问题{}部分。",
    "{}http_status: {}The raw http status code (if available). This returns the standard web status code for most browsers, eg: 304 for \"Not Modified\" or 204 for \"No Content\", etc...":"{}http_status：{}原始 http 状态代码(如果可用)。 这将返回大多数浏览器的标准 Web 状态代码，例如：304 未修改(Not Modified) ，204无内容(No Content),等等...",
    "{}id: {}The ID which was returned from the command. If you fire off a series of {}http_{} requests then you need to know which one you are getting the reply to, and so you would use this value to compare to the value you stored when you originally sent the request to find the right one.":"{}id：{}从命令返回的 ID。 如果您发出一系列 {}http_{} 请求，那么您需要知道您收到的是哪个请求的回复，因此您将使用此值与您最初发送请求时存储的值进行比较，以找到 正确的那一个。",
    "{}result: {}The data received (string only).":"{}result 结果: {}收到的数据(仅字符串)。",
    "{}status: {}Returns a value of less than 0 for an error, 0 for complete and 1 for receiving packets (see below for more details).":"{}status 状态：{}返回小于 0 的值表示错误，0 表示完成，1 表示接收数据包(详情请见下文)。",
    "{}url: {}The complete URL you requested.":"{}url: {}请求的完整 URL。"
}