{
    "After you have set up your layout, you must call&nbsp;{}{}flexpanel_calculate_layout{}{}&nbsp;with the dimensions where you intend to use the layout.":"设置布局后，您必须使用您打算使用布局的尺寸调用 {}{}flexpanel_calculate_layout{}{}。",
    "Both of these examples use the data from&nbsp;{}{}flexpanel_node_layout_get_position{}{}&nbsp;in&nbsp;{}{}draw_rectangle{}{}&nbsp;to draw a node\u0027s rectangular area from {}left{}, {}top{} to {}left + width{}, {}top + height{}.":"这两个示例都使用来自{}{}flexpanel_node_layout_get_position{}{}的数据在{}{}draw_rectangle{}{}中从中绘制节点的矩形区域{}左{}、{}顶部{}到{}左+宽度{}、{}顶部+高度{}。",
    "By setting up nodes inside nodes (inside nodes...), you can create a layout tree. Each node can have properties that define how large it is, how it should be positioned in relation to the nodes in its container, how its own child nodes should behave, and so on.":"通过在节点内部设置节点 (节点内部 ...)，您可以创建布局树。每个节点都可以具有定义其大小、相对于其容器中的节点应如何定位、其自己的子节点应如何表现等的属性。",
    "Containing Block":"包含块",
    "Creating a layout is as simple as calling&nbsp;{}{}flexpanel_create_node{}{}&nbsp;and passing it a struct or a JSON string. That struct/JSON should define the properties of the root node and all nodes nested under the root node. The structure of that struct/JSON is {}outlined on this page{}.":"创建布局就像调用 {}{}flexpanel_create_node{}{} 并向其传递一个结构体或 JSON 字符串一样简单。该 struct/JSON 应该定义根节点以及嵌套在根节点下的所有节点的属性。{} 本页概述了该结构体 /JSON 的结构 {}。",
    "Each node has styling properties, which define its position, size and behaviour within its container. You can specify these styling properties in the struct/JSON that you pass while creating a node, which are all listed here:&nbsp;{}Styling Properties{}.":"每个节点都有样式属性，这些属性定义其在其容器内的位置、大小和行为。您可以在创建节点时传递的 struct/JSON 中指定这些样式属性，这些属性均在此处列出：{} 样式属性 {}。",
    "Flex Panel Functions":"柔性面板功能",
    "Flex Panel Preview":"柔性面板预览",
    "Flex Panel Struct Members":"柔性面板结构成员",
    "For information on how a Containing Block is chosen for a node and how it affects the node, see: {}Containing block{}":"有关如何为节点选择包含块以及它如何影响节点的信息，请参阅：{} 包含块 {}",
    "Here, children are inserted using a {}repeat{} loop so that the same information does not have to be duplicated and written into the struct literal.":"此处，使用 {}repeat{} 循环插入子项，以便不必复制相同的信息并将其写入结构体文字中。",
    "How To Create Layouts":"如何创建布局",
    "Layout Examples":"布局示例",
    "Overview":"概述",
    "Some of the&nbsp;{}Styling Properties{}&nbsp;depend on a node\u0027s Containing Block, which may not be the same as its direct parent. For example, a node with a {}positionType{} of {}relative{} will position itself within its direct parent, however an {}absolute{} node will position itself to its Containing Block.":"某些 {} 样式属性 {} 取决于节点的包含块，该包含块可能与其直接父级不同。例如，{}positionType{} 为 {}relative{} 的节点会将自身定位在其直接父级中，而 {}absolute{} 节点会将自身定位在其包含块中。",
    "The first child is centred because of its parent\u0027s {}Justify Content{}&nbsp;and {}Align Items{} properties (which handle the main axis and cross axis alignment, respectively).":"第一个子项居中是因为其父项具有 {}Justify Content{} 和 {}Align Items{} 属性 (分别处理主轴和横轴对齐)。",
    "The second child has its&nbsp;{}Position Type{}&nbsp;set to {}\"absolute\"{}, which allows it to be positioned along the bottom-right corner independently.":"第二个子项的 {} 位置类型 {} 设置为 {}\"absolute\"{}，这样它就可以沿着右下角独立定位。",
    "The {}\"column\"{}&nbsp;{}Flex Direction{}&nbsp;of the parent allows its children to be laid out vertically (forming the main axis), and the {}\"flex-end\"{}&nbsp;{}Align Items{}&nbsp;property aligns the children to the end of its cross axis (i.e. to the right).":"父级的 {}\"column\"{}{}Flex Direction{} 允许其子级垂直布局 (形成主轴)，而 {}\"flex-end\"{}{}Align Items{} 属性将子项对齐到其横轴的末端 (即向右)。",
    "The {}Flex Shrink{} property in the children ensures they shrink if they overflow the bounds of its parents.":"子级中的 {}Flex Shrink{} 属性可确保它们在超出父级边界时收缩。",
    "The&nbsp;{}Flex Panel{}&nbsp;functionality uses the {}Yoga{} library.":"{}柔性面板{} 功能使用 {}Yoga{} 库。",
    "Then you can call&nbsp;{}{}flexpanel_node_layout_get_position{}{}&nbsp;on the node you want information for, which will return a struct with its positional data.":"然后，您可以在需要其信息的节点上调用 {}{}flexpanel_node_layout_get_position{}{}，这将返回一个包含其位置数据的结构体。",
    "This is the code used to generate the layout on the left:":"这是用于生成左侧布局的代码：",
    "This is the code used to generate the layout on the right:":"这是用于生成右侧布局的代码：",
    "This section contains the following pages:":"本节包含以下页面：",
    "This section details the usage of the&nbsp;{}Flex Panel{}&nbsp;runtime functions, which help you create UI layouts by handling all the logical calculations concerning where UI boxes are placed and how they behave.":"本部分详细介绍了 {}Flex Panel{} 运行时函数的用法，这些函数通过处理有关 UI 框放置位置及其行为方式的所有逻辑计算来帮助您创建 UI 布局。",
    "Using Layout Data":"使用布局数据",
    "You can also set and get these styling properties after creating a node using the&nbsp;{}Styling Functions{}.":"您还可以在使用 {} 样式函数 {} 创建节点后设置和获取这些样式属性。",
    "You can specify as many options in that struct/JSON as you like, or you can call the function without passing a struct/JSON, which will create an empty node. You can later set properties on the node and insert/remove children by calling the&nbsp;{}Flex Panel Functions{}.":"您可以在该 struct/JSON 中指定任意多个选项，也可以在不传递 struct/JSON 的情况下调用该函数，这将创建一个空节点。您稍后可以通过调用 {}柔性面板函数 {} 来设置节点属性并插入 / 删除子节点。",
    "You can use that positional data in any way you want, e.g. creating UI object instances for each node or drawing them as rectangles.":"您可以按照您想要的任何方式使用该位置数据，例如为每个节点创建 UI 对象实例或将它们绘制为矩形。",
    "You can use these functions to set up layouts consisting of {}nodes{}. Each node is a rectangular area and may contain other nodes, making a node a {}container{}.":"您可以使用这些函数来设置由 {} 节点 {} 组成的布局。每个节点都是一个矩形区域，并且可能包含其他节点，从而使节点成为 {} 容器 {}。",
    "{}A layout tree can then be {}calculated according to a given canvas size{}, and the final positions and sizes of the nodes {}can be used{} anywhere you like (e.g. setting up your UI systems). There is no rendering or asset support in these functions and how you make use of this data is entirely up to you.":"{} 然后可以 {} 根据给定的画布尺寸计算 {} 布局树，并且节点的最终位置和尺寸 {} 可以 {} 在您喜欢的任何地方使用 (例如设置您的 UI 系统)。这些函数没有渲染或资源支持，如何使用这些数据完全取决于您。",
    "{}Flex Panels{}":"{} 柔性面板 (Flex Panel){}",
    "{}Layout Code{}{}Layout Code{}":"{} 布局代码 {}{} 布局代码 {}",
    "{}Open the section below to see the code used to generate both of the layouts shown above:":"{} 打开下面的部分查看用于生成上面显示的两种布局的代码：",
    "{}The Debug Overlay{}&nbsp;contains a window for testing layouts in real-time using the same JSON&nbsp;data that you would pass into&nbsp;{}{}flexpanel_create_node{}{}.":"{} 调试覆盖层 {} 包含一个窗口，用于使用您将传递到 {}{}flexpanel_create_node{}{} 中的相同 JSON 数据来实时测试布局。",
    "{}You can use this to test your JSON&nbsp;data and edit layouts before using the data in your game code. This JSON code can also be used as a struct literal in your code.":"{} 您可以使用它来测试 JSON 数据并编辑布局，然后再在游戏代码中使用数据。此 JSON 代码也可以用作代码中的结构文字。"
}