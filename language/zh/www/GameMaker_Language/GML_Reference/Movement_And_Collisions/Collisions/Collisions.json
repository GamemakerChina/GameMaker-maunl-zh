{
    "\"{}Disable Source Sprite Export{}\" needs to be unchecked in your Tile Set\u0027s {}editor{} for tile collisions to work.":"需要在图块集的 {} 编辑器 {} 中取消选中 \"{}禁用源精灵导出{}\"，图块碰撞才能发挥作用。",
    "A function like {}{}instance_place{}{} or {}{}collision_circle{}{} (and other equivalents) may return 0 if a collision was found with a Tile Map having the ID 0. This means you should not use the return value as a boolean condition. Instead, check whether the return value is not {}noone{}, meaning a collision was found.":"如果发现与 ID 为 0 的图块地图发生碰撞，类似 {}{}instance_place{}{} 或 {}{}collision_circle{}{}( 以及其他等效函数) 的函数可能会返回 0。这意味着您不应使用作为布尔条件的返回值。相反，请检查返回值是否不是 {}noone{}，这意味着发现了冲突。",
    "Advanced Collision Checking":"高级碰撞检查",
    "All of the above functions are related to collision checking {}instances{}, and as such rely on the collision mask that is defined for the instance. However, there are many moments when you require to check for \"collisions\" with a point or an area, especially when your instance does not have a sprite assigned, or when you are working with the mouse etc... Therefore {}GameMaker{} also provides the following functions to help you in these situations:":"以上所有函数都与碰撞检查{}实例{}相关，因此依赖于为该实例定义的碰撞遮罩。但是，有许多时刻需要检查与点或区域的\"碰撞\"，尤其是当您的实例没有指定精灵时，或者当您正在使用鼠标等时...因此{}GameMaker{}还提供以下函数来帮助您解决这些问题：",
    "Assign a {}parent{} to those objects, and check against that single parent":"为这些对象分配一个 {} 父对象 {}，并检查该单父对象",
    "Bounding Boxes":"边界框",
    "Collision Checking Without A Mask":"不带遮罩的碰撞检查",
    "Collisions":"碰撞",
    "Collisions With Multiple Objects":"与多个物体的碰撞",
    "Collisions With Objects":"与物体碰撞",
    "Collisions With Tile Maps":"与平铺地图的碰撞",
    "Collisions against Tile Maps are checked using the collision mask of the sprite used for the Tile Set, which can be modified in {}The Sprite Editor{}.":"使用用于图块集的精灵的碰撞遮罩来检查图块地图的碰撞，可以在 {} 精灵编辑器 {} 中修改该碰撞遮罩。",
    "For example, if you\u0027re a rectangle trying to collide with a bounding box covering the area from&nbsp;{}(0.0, 0.0){}&nbsp;to {}(16.0, 16.0){}, the edge of your mask has to touch the area between&nbsp;&nbsp;{}(0.5, 0.5){}&nbsp;and&nbsp;{}(15.5, 15.5){}&nbsp;for a collision to be counted.":"例如，如果您是一个尝试与覆盖从 {}(0.0, 0.0){} 到 {}(16.0, 16.0){} 区域的边界框碰撞的矩形，则遮罩的边缘必须接触该区域介于 {}(0.5, 0.5){} 和 {}(15.5, 15.5){} 之间，以便对碰撞进行计数。",
    "For two instances to be in collision, their bounding boxes have to overlap. At a pixel level, an overlap is counted when the centre of that pixel is covered.":"为了使两个实例发生碰撞，它们的边界框必须重叠。在像素级别，当该像素的中心被覆盖时，就会计算重叠。",
    "How To Check Collisions":"如何检查碰撞",
    "In addition to objects, you can also pass a&nbsp;{}{}Tile Map Element ID{}{}&nbsp;to a collision function. This will check for collisions with that Tile Map.":"除了对象之外，您还可以将 {}{}Tile Map Element ID{}{} 传递给碰撞函数。这将检查与该图块地图的碰撞。",
    "Keep in mind:":"记住：",
    "Or, pass an {}array{} containing the objects you want to check against":"或者，传递一个包含您要检查的对象的 {} 数组 {}",
    "Physics Collisions":"物理碰撞",
    "Some instances will use a rectangular bounding box for checking collisions (unless a different mask shape is selected).":"某些实例将使用矩形边界框来检查碰撞 (除非选择了不同的遮罩形状)。",
    "Step Event":"步骤事件",
    "The basic functions will return either the ID of an instance found to be colliding, or the special keyword&nbsp;{}noone{}&nbsp;when there is no collision, while the&nbsp;{}list{}&nbsp;functions will return the number of instances that are in collision and populate a pre-made DS list with their IDs. Note that if there are multiple collisions with the areas defined by these functions and instances of the given object, only&nbsp;{}one{}&nbsp;instance ID is returned, and it can be&nbsp;{}any one of the instances in the collision{}.":"基本函数将返回发现有碰撞的实例的Id，或者在没有碰撞时返回特殊关键字{}noone{}，而{}列表{}函数将返回碰撞的实例数，并用它们的Id填充预制的D列表。请注意，如果与给定对象的这些函数和实例定义的区域存在多个碰撞，则仅返回{}一个{}实例Id，并且它可以是碰撞{}中的任何一个实例。",
    "The following functions can be used for this (as well as other functions detailed in the sections relating to {}{}Moving Around{}{} and {}{}Instances{}{}). These collision functions all work slightly differently but they maintain three common arguments which we will explain here:":"为此，可以使用以下函数 (以及与 {}{} 移动 {}{} 和 {}{} 实例 {}{} 相关的部分中详细介绍的其他函数)。这些碰撞函数的工作方式都略有不同，但它们保留了三个共同的参数，我们将在这里进行解释：",
    "The following functions deal with the various ways in which you can have an instance check for collisions with another instance:":"以下函数处理各种方法，通过这些方法可以使实例检查是否与另一个实例发生碰撞：",
    "The following functions exist that deal with advanced collisions.":"存在以下处理高级碰撞的函数。",
    "The following routines can be used for this (as well as other functions detailed in the sections relating to {}Moving Around{} and {}Instances{}). These collision functions all work slightly differently but they maintain three common arguments which we will explain here:":"以下例程可用于此(以及与{}移动{}和{}实例{}相关的章节中详细说明的其他函数)。这些碰撞函数的工作方式略有不同，但它们保留了三个常见参数，我们将在此处进行说明：",
    "The simplest way to check for collisions against objects is to use {}{}place_meeting{}{}.":"检查对象碰撞的最简单方法是使用 {}{}place_meeting{}{}。",
    "The {}{}place_meeting{}{} function only returns {}true{} or {}false{}. If you need to access the instance that was found in collision, use&nbsp;{}{}instance_place{}{}, which returns an instance handle.":"{}{}place_meeting{}{} 函数仅返回 {}true{} 或 {}false{}。如果您需要访问在碰撞中找到的实例，请使用 {}{}instance_place{}{}，它会返回实例句柄。",
    "These bounding boxes use an inclusive system, i.e. they include the bottom-most and right-most edges. This means that the bounding box for a&nbsp;16x16&nbsp;collision mask is generated from {}(0.0, 0.0){}&nbsp;to {}(16.0, 16.0){} (relative).":"这些边界框使用包含系统，即它们包括最底部和最右侧的边缘。这意味着 16x16 碰撞掩码的边界框是从 {}(0.0, 0.0){} 到 {}(16.0, 16.0){}( 相对) 生成的。",
    "This checks for collisions against instances of {}obj_rock{} only. If there is no rock at {}x + 4{}, it changes the X position to move the instance there.":"这仅检查与 {}obj_rock{} 实例的碰撞。如果 {}x + 4{} 处没有岩石，它会更改 X 位置以将实例移动到那里。",
    "This checks for collisions against instances of&nbsp;{}obj_rock{} and {}obj_bush{} in the same function call.":"这会检查同一函数调用中 {}obj_rock{} 和 {}obj_bush{} 实例的冲突。",
    "Use&nbsp;{}{}layer_tilemap_get_id{}{}&nbsp;to get the Tile Map ID for a layer, and then pass that ID into a collision function.":"使用 {}{}layer_tilemap_get_id{}{} 获取图层的图块地图 ID，然后将该 ID 传递给碰撞函数。",
    "Using the second method of passing an array, your code would look like this:":"使用传递数组的第二种方法，您的代码将如下所示：",
    "When planning motions or deciding on certain actions, it is often important to see whether there are collisions with other objects at certain places within the game world, and often choosing the right collision for the job is the most important task of all. {}GameMaker{} has a number of built in functions to help you deal with collisions correctly and in accordance with the needs of your project.":"在规划动作或决定某些动作时，往往需要看到游戏世界中某些地方是否存在与其他对象的碰撞，而往往为工作选择正确的碰撞是所有工作中最重要的任务。{}GameMaker{}具有许多内置函数，可帮助您根据项目的需要正确处理碰撞。",
    "When planning motions or deciding on certain actions, it is often important to see whether there are collisions with other objects at certain places within the game world, and often choosing the right collision function for the job is the most important task of all. {}GameMaker{} has a number of built-in functions to help you deal with collisions correctly and in accordance with the needs of your project.":"在规划运动或决定某些动作时，查看游戏世界中某些位置是否与其他对象发生碰撞通常很重要，并且通常为工作选择正确的碰撞函数是最重要的任务。{}GameMaker{} 具有许多内置函数，可以帮助您根据项目的需要正确处理碰撞。",
    "When using the built-in physics, the above collision functions are not guaranteed to work for physics enabled instances. This is mainly due to the fact that these instances no longer use the majority of the regular built in variables (instead, physics enabled instances have their {}own set of variables{}) and neither do they use the collision mask or bounding box, as they use {}fixtures{} instead. However there is a special function for testing collisions with physics enabled that checks for overlapping fixtures:":"使用内置物理时，不能保证上述碰撞函数适用于启用物理的实例。这主要是由于这些实例不再使用大多数常规内置变量(相反，启用了物理的实例具有自己的{}组变量{})，也不使用碰撞遮罩或边界框，因为它们改用了{}设备{}。但是，有一个特殊函数可用于在启用了物理函数的情况下测试碰撞，该函数可检查重叠的设备：",
    "You can check for collisions against multiple objects, in two ways:":"您可以通过两种方式检查多个对象的碰撞：",
    "You can combine objects and Tile Maps when passing an array to a collision function.":"将数组传递给碰撞函数时，您可以组合对象和图块贴图。",
    "{}Simple Collision Checking{}":"{}简单的碰撞检查{}",
    "{}notme{}: You may need to check for collisions with an object that has the same index as the object that runs the code, so to prevent the code finding a collision with itself, you can set this to {}true{}. If you are specifically looking for the instance of the object running the code, or it\u0027s not important, it can be left as {}false{}.":"{}注意{}:您可能需要检查与运行代码的对象具有相同索引的对象是否碰撞，以防止代码发现与自身碰撞，您可以将此设置为{}true{}。如果您正在专门查找运行代码的对象的实例，或者这并不重要，则可以将其保留为{}false{}。",
    "{}obj{}: This is where we specify the object that the function has to check for a collision with. It can be an instance id, an object type, or the special GM keyword {}all{}. It is also worth noting that if the object type chosen is the designated {}parent{} of other objects, then all {}children{} of that object will be included in this check too.{}{}":"{}obj{}:这是指定函数必须检查是否与其碰撞的对象的位置。它可以是实例ID、对象类型或特殊的Gm关键字{}all{}。另请注意，如果选择的对象类型是其他对象的指定{}父对象{}，则该对象的所有{}子对象{}也将包括在此检查中。{}{}",
    "{}prec{}: This can be either {}true{} or {}false{} and relates to the precision of the collision checking. If set to {}true{}, then precise collisions are to be calculated (but only if the object being checked for has \"precise\" marked for its collision detection in its mask properties) which is a slightly more complex task for the CPU and so should be used with caution. If {}false{} then collisions will be calculated based on the bounding box of the object to be checked for.{}{}":"{}prec{}:这可以是{}true{}或{}false{}，并且与碰撞检查的精度有关。如果设置为{}true{}，则要计算精确的碰撞(但前提是要检查的对象在其遮罩属性中具有为其碰撞检测标记的\"精度\")，这对于Cpu来说是一个稍微复杂的任务，因此应谨慎使用。如果{}为假{}，则将根据要检查的对象的边界框计算碰撞。{}{}",
    "{}{}NOTE{}{}&nbsp;Collision functions used to use integer values in previous versions of GameMaker, however they now use floating point values meaning that collision functions will no longer round non-integer arguments. For more information, please read {}Collision Compatibility Mode{}.":"{}{}注意{}{}碰撞函数在GameMaker的以前版本中用于使用整数值，但现在它们使用浮点值，这意味着碰撞函数将不再舍入非整数参数。有关详细信息，请阅读{}碰撞兼容模式{}。",
    "{}{}TIP{}{}&nbsp;It is recommended to use the parenting method for multiple collision checks, as you can use the same parent in multiple function calls, without having to keep track of an array.":"{}{} 提示{}{} 建议使用父级方法进行多次冲突检查，因为您可以在多个函数调用中使用相同的父级，而无需跟踪数组。"
}