{
    "Note that instead of an object index you can supply an instance {}{}id{}{} to check for a specific instance, or the {}instance keywords{} {}all{}, or {}other{} (depending on the event and current code scope).":"请注意，您可以不提供对象索引，而提供实例{}{}id{}{}来检查特定实例，或{}实例关键字{}{}all{}或{}other{}(取决于事件和当前代码范围)。",
    "The object to check for instance collisions.":"检查实例碰撞的对象。",
    "The x coordinate of the left side of the ellipse to check.":"要检查的椭圆左侧的x坐标。",
    "The x coordinate of the right side of the ellipse to check.":"要检查的椭圆右侧的x坐标。",
    "The y coordinate of the bottom side of the ellipse to check.":"要检查的椭圆底侧的y坐标。",
    "The y coordinate of the top side of the ellipse to check.":"要检查的椭圆顶侧的y坐标。",
    "This will check an elliptical zone within the bounds of 50x, 50y and 200x, 100y for the object \"obj_Player\". If there is a collision with that object, then it will create an instance of \"obj_Splash\" at the x/y coordinates of obj_Player.":"这将检查对象\"obj_Player\"在50 x、50 y和200 x、100 y范围内的椭圆区域。如果与该对象发生碰撞，则会在obj_Player的x/y坐标处创建\"obj_Splash\"的实例。",
    "Whether the calling instance, if relevant, should be excluded ({}true{}) or not ({}false{}).":"是否应排除调用实例(如果相关)({}true{})或({}false{})。",
    "Whether the check is based on precise collisions ({}true{}, which is slower) or its bounding box in general ({}false{}, faster).":"检查是基于精确碰撞({}true{}，速度较慢)还是基于其边界框({}false{}，速度较快)。",
    "{}Collision_ellipse{} uses the first four arguments (x1,y1,x2,y2) to define the width and height of an ellipse within the current room and then checks to see if {}any{} object that is defined by the \"obj\" argument is in collision with that area. This collision can be checked as precise or not, and you may also choose to check for the instance running the code itself or not. Consider this image:":"{}collision_ellipse{} 使用前四个参数 (x1,y1,x2,y2) 定义当前房间内椭圆的宽度和高度，然后检查 {}\"obj\" 参数定义的任何 {} 对象是否与该区域碰撞。可以精确或不精确地检查此碰撞，也可以选择是否检查运行代码本身的实例。请考虑以下图像：",
    "{}Here, the instance in the middle is using a collision ellipse to check for ball objects. Now, the blue ones do {}not{} have a precise bounding box and as you can see, even if the sprite is not actually touching the ellipse, the collision can still happen (even if you set the precise option in the function to true) as the bounding box of that sprite over-laps the elliptical area defined by collision_circle. On the other hand, the green balls will only be considered in collision if the actual sprite over-laps the defined ellipse. Remember, for precise collisions to be considered {}both{} the object sprite and the collision function must have precise marked as on. It should also be noted that the return value of the function can be the id of {}any one{} of the instances considered to be in collision.":"{}此处，中间的实例使用碰撞椭圆检查球对象。现在，蓝色的{}没有{}精确的边界框，如您所见，即使精灵没有实际接触到椭圆，碰撞仍然可能发生(即使您将函数中的精确选项设置为true)，因为该精灵的边界框与Collision_circle定义的椭圆区域重叠。另一方面，只有当实际的精灵与定义的椭圆重叠时，才会考虑碰撞中的绿色球。请记住，要{}同{}时考虑对象sprite和碰撞函数的精确碰撞，必须将其精确标记为on。还应注意，函数的返回值可以是被认为处于碰撞中的{}任何一个{}实例的ID。"
}