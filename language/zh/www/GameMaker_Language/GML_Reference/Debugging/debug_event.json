{
    "\"{}BreakOnError{}\" - This option is for {}Windows YYC{} builds only, and means that projects will {}not{} display the usual code error screen if the runtime detects an error, but instead just carry on and crash. This allows you to see the stack trace within Visual Studio if debugging.":"\"{}BreakOnError{}\" - 此选项仅适用于 {}Windows YYC{} 构建，这意味着如果运行时检测到错误，项目将 {} 不会 {} 显示常见的代码错误屏幕，而是继续运行并崩溃。这使您可以在调试时查看 Visual Studio 中的堆栈跟踪。",
    "\"{}BreakOnError{}\" - This option is for {}Windows YYC{} builds only, and means that projects will {}not{} display the usual code error screen if the runtime detects an error, but instead just carry on and crash. This allows you to see the stacktrace within Visual Studio if debugging.":"\"{}BreakOnError{}\"-此选项仅用于{}Windows YYC{}构建，这意味着如果运行时检测到错误，项目将不会{}显示通常的代码错误屏幕，而只是继续并崩溃。如果调试，这允许您在Visual Studio中查看stacktrace。",
    "\"{}DumpMemory{}\" - Gives information on the current memory usage.":"\"{}DumpMemory{}\"-提供有关当前内存使用情况的信息。",
    "\"{}DumpMemory{}\" - Gives information on the current memory usage. Also returns a struct (info given below).":"\"{}DumpMemory{}\" - 提供有关当前内存使用情况的信息。还返回一个结构(信息如下所示)。",
    "\"{}OutputDebugOff{}\" - Disables the behaviour described above.":"\"{}OutputDebugOff{}\" - 禁用上述行为。",
    "\"{}OutputDebugOn{}\" - This enables a call to {}OutputDebugString{} for the {}Windows{} target, which means that all debug output - everything you see in the Output window - can be viewed by Visual Studio or by 3rd party apps.":"\"{}OutputDebugOn{}\" - 这启用了对 {}Windows{} 目标的 {}OutputDebugString{} 的调用，这意味着所有调试输出-您在输出窗口中看到的所有内容-都可以通过 Visual Studio 或第三方应用程序查看。",
    "\"{}ResourceCounts{}\" - Lists all the currently active resources, such as Data Structures, Time Sources, Surfaces, etc.":"\"{}ResourceCounts{}\"-列出所有当前活跃的资源，例如数据结构、时间源、表面等。",
    "\"{}ResourceCounts{}\" - Lists all the currently active resources, such as Data Structures, Time Sources, Surfaces, etc. Also returns a struct (info given below).":"\"{}ResourceCounts{}\" - 列出所有当前活动的资源，如数据结构、时间源、表面等。还返回一个结构(信息如下所示)。",
    "Each resource is represented with three properties:":"每个资源都用三个属性表示：",
    "The above code checks to see if a surface exists and if it does not, a debug event is triggered in the graph view of the debugger (the game must have been run in Debug Mode for this to be visible) and the surface is recreated.":"上面的代码检查表面是否存在，如果不存在，则在调试器的图形视图中触发调试事件(游戏必须在调试模式下运行才能显示)，并重新创建表面。",
    "The above code checks to see if an surface exists and if it does not, a debug event is triggered in the graph view of the debugger (the game must have been run in Debug Mode for this to be visible) and the surface is recreated.":"上面的代码检查表面是否存在，如果不存在，则在调试器的图形视图中触发调试事件(游戏必须在调试模式下运行才能可见)，并重新创建表面。",
    "The custom debug event string to use.":"要使用的自定义调试事件字符串。",
    "The function will also take five reserved strings to help perform debugging using external applications like Visual Studio. These strings are:":"该函数还将接受五个保留字符串，以帮助使用外部应用程序(如Visual Studio)执行调试。这些字符串是：",
    "The members of the struct will differ based on the platform, however all platforms will at least have the following values in the struct (in bytes):":"结构的成员将根据平台的不同而有所不同，但是所有平台在结构中至少具有以下值(以字节为单位)：",
    "The struct has the following members:":"该结构具有以下成员：",
    "The way these values are measured is different on each platform.":"在每个平台上测量这些值的方式是不同的。",
    "This function generates a custom debug event that will be shown in the Graph View of the debugger when a game is being run in {}Debug Mode{}. If you require messages to be displayed when {}not{} in debug mode, use&nbsp;{}{}show_debug_message{}{}.":"此函数生成一个自定义调试事件，当游戏在{}调试模式{}下运行时，该事件将显示在调试器的 Graph View 中。如果您需要在调试模式下在{}而不是{}时显示消息，请使用{}{}show_debug_message{}{}。",
    "When you call {}debug_event{} with the {}\"DumpMemory\"{} argument, it returns a struct with information about your game\u0027s memory usage.":"当您使用 {}\"DumpMemory\"{} 参数调用 {0}debug_event{1} 时，它将返回一个结构，其中包含有关游戏内存使用的信息。",
    "When you call {}debug_event{} with the {}\"ResourceCounts\"{} argument, it returns a struct with information about all the active resources in your game.":"当您使用 {}\"ResourceCounts\"{} 参数调用 {0}debug_event{1} 时，它将返回一个结构，其中包含有关游戏中所有活动资源的信息。",
    "{}\"&lt;resource&gt;ArrayAllocatedSize\"{}: The highest number of resources that were ever created for the given resource type":"{}\"&lt;resource&gt;ArrayAllocatedSize\"{}: 为给定资源类型创建的最大资源数量",
    "{}\"&lt;resource&gt;Count\"{}: The number of resources of this type that exist when the function is called":"{}\"&lt;resource&gt;Count\"{}: 调用函数时存在的此类资源的数量",
    "{}\"&lt;resource&gt;MaxIndex\"{}: The maximum valid integer index that exists for the resource":"{}\"&lt;resource&gt;MaxIndex\"{}: 资源存在的最大有效整数索引",
    "{}free{}: How much allocated memory is unused":"{}free{}: 有多少已分配的内存未使用",
    "{}peakUsage{}: The highest amount of memory your game used since it was started":"{}peakUsage{}: 您的游戏自启动以来使用的最大内存量",
    "{}totalUsed{}: How much memory your game is using at the moment":"{}totalUsed{}: 您的游戏目前使用了多少内存"
}