{
    "Please read the {}{}buffer_load(){}{} page for platform-specific notes.":"请阅读{}{}buffer_load(){}{}页面了解平台特定注释。",
    "The above code loads the contents of the file \"{}Player_Save.sav{}\" to the given buffer, storing the ID of the function call in the variable \"{}loadid{}\". When the load is complete, the asynchronous Save/Load event will be triggered and you can parse the {}async_load{} map for the correct ID of the function, like this:":"上述代码将文件\"{}Player_Save.sav{}\"的内容加载到给定缓冲区，将函数调用的ID存储在变量\"{}loadid{}\"中。 加载完成后，异步保存/加载事件将被触发，您可以解析{}async_load{}映射以获取函数的正确ID，如下所示：",
    "The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there has been any issues.":"上述代码将首先检查已创建的DS映射的ID，然后检查回调的状态，如果出现任何问题，则发布调试消息。",
    "The function returns a unique ID value which can then be used in the {}Save / Load Asynchronous event{}&nbsp;to check the&nbsp;{}{}async_load{}{} ID value, as shown in the extended example below. The {}async_load{} map in the event will have the following two key/value pairs:":"函数返回唯一ID值，然后可以在{}保存/加载异步事件{}中使用该值来检查{}{}async_load{}{}ID值，如下扩展示例所示。事件中的{}async_load{}映射将具有以下两个键/值对：",
    "The index of the buffer to load.":"要加载的缓冲区索引。",
    "The name of the file to load.":"要加载的文件名。",
    "The offset within the buffer to load to (in bytes).":"缓冲区内要加载到的偏移(以字节为单位)。",
    "The size of the buffer area to load (in bytes).":"要加载的缓冲区的大小(以字节为单位)。",
    "The {}buffer_load_async(){} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}buffer_load_async(){}函数可以从任何事件中调用，由于它是异步的，所以回调可以几乎是瞬时的，或者可能需要几秒钟的时间。调用函数很简单，看起来如下：",
    "With this function you can load a file that you have created previously using the {}{}buffer_save(){}{} function (or any of the other functions for saving buffers) into a buffer. The \"offset\" defines the start position within the buffer for loading (in bytes), and the \"size\" is the size of the buffer area to be loaded from that offset onwards (also in bytes). You can supply a value of -1 for the size argument and the entire buffer will be loaded. Note that the function will load from a \"default\" folder, which does {}not{} need to be included as part of the file path you provide. This folder will be created if it doesn\u0027t exist or when you save a file using {}{}buffer_save_async(){}{}.":"使用此函数，可以将以前使用{}{}buffer_save(){}{}函数(或任何其他用于保存缓冲区的函数)创建的文件加载到缓冲区中。\"偏移\"定义缓冲区内加载的起始位置(以字节为单位)，\"大小\"是从该偏移量开始加载的缓冲区的大小(也以字节为单位)。您可以为 size 参数提供值 -1，然后将加载整个缓冲区。请注意，该函数将从\"default\"文件夹加载，而{}不需要{}作为您提供的文件路径的一部分。如果此文件夹不存在，或使用{}{}buffer_save_async(){}{}保存文件时，将创建此文件夹。",
    "{}\"id\": {}the ID of the async function as returned by the save function.":"{}\"id\"：{}save 函数返回的 async 函数的 ID。",
    "{}\"status\": {}will return {}true{} if the data was saved/loaded correctly, and {}false{} otherwise.":"{}\"status\"：{}如果数据保存/加载正确，将返回{}true{}，否则返回{}false{}。",
    "{}NOTE{}&nbsp;On {}HTML5{}, this is the preferred method for loading a file if you are loading from a server and not local storage, as loading synchronously has been deprecated on most browsers and will eventually be obsoleted.":"{}注意{}在{}HTML5{}上，如果您从服务器而非本地存储加载文件，这是首选的加载文件方法，因为同步加载在大多数浏览器上已经过时，最终将被淘汰。"
}