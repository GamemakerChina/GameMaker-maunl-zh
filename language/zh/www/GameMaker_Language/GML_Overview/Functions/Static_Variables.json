{
    "A static variable is always initialized at the top of the function,&nbsp;so no matter where you define a static variable in the function, it will always be available to be read and changed throughout the function (even if it\u0027s used before being defined). See the following example:":"静态变量总是在函数的顶部初始化，因此，无论你在函数的哪个位置定义静态变量，它在整个函数中都始终可供读取和更改(即使在定义之前已使用过静态变量)。参见以下示例：",
    "An interesting feature of {}script functions{} and {}method variables{}&nbsp;is that they can have {}static variables{}. A static variable is one that is defined the first time that the function is called and that will maintain its value from then onward. To create a static variable you need to define it using the {}static{} keyword, as shown in this simple example:":"{}脚本函数{}和{}方法变量{}的一个有趣特征是，它们可以有{}静态变量{}。静态变量是指在函数第一次被调用时定义的变量，它将从那时起保持其数值。要创建静态变量，需要使用{}static{}关键字来定义它，如这个简单的例子所示。",
    "Calling the {}Child(){}&nbsp;constructor prints this to the output log:":"调用{}Child(){}构造函数会将以下内容打印到输出日志：",
    "Here&nbsp;the static variable \"{}my_health{}\" is being changed and printed to the compiler output&nbsp;{}before{}&nbsp;being initialized. While that looks wrong, it is perfectly fine because static variables are initialized {}before {}any function code is executed. Note that if there are multiple static variables in a function, the order in which they were defined will be kept when they are initialized at the top.":"在这里，静态变量\"{}my_health{}\"在{}被初始化之前被改变并打印到编译器输出{}。虽然这看起来不对，但这是很好的，因为静态变量在执行{}任何函数代码之前就被初始化{}。注意，如果一个函数中有多个静态变量，当它们在顶部被初始化时，它们被定义的顺序将被保留。",
    "If you didn\u0027t use the {}static{} keyword here then the output would simply be {}0{} for every iteration of the loop, since the variable {}num{}&nbsp;will be getting defined as {}0{} every time the function is called before being returned. Note that a static variable can only be changed inside the original function, and returning it will simply give you a copy of its value&nbsp;- essentially the shared static variable can only be changed by the function that contains it.":"如果此处没有使用{}static{}关键字，则循环的每次迭代的输出都将是{}0{}，因为在返回之前，每次调用函数时，变量{}num{}都将被定义为{}0{}。请注意，静态变量只能在原始函数内部进行更改，返回它将简单地为您提供其值的副本-实际上，共享的静态变量只能由包含它的函数进行更改。",
    "In the above example, the constructor function&nbsp;{}{}Vector2{}{} can be used to create a struct, and the struct will have some variables, one of which is the method variable {}{}Add{}{}. Since this variable has been defined as static, the function it contains will only be initialized {}once {}the first time the {}Vector2{} function is called, and all further structs created with this constructor will reference the function {}Add{} that was created initially, instead of creating a new function for each struct (for more information on structs and the {}constructor{} keyword please see {}here{}).":"在上面的示例中，构造函数{}{}Vector2{}{}可以用来创建结构，并且该结构将有一些变量，其中一个是方法变量{}{}Add{}{}。由于此变量已被定义为静态变量，因此它包含的函数仅在首次调用{}Vector2{}时初始化{}一次{}，使用此构造函数创建的所有其他结构将引用最初创建的函数{}Add{}，而不是为每个结构创建一个新函数(有关结构和{}构造函数{}的更多信息，请参阅{}此处{})。",
    "In the above example, the variable {}num{}&nbsp;is a static variable, and so will be defined as {}0{} the first time the function is called, but every time the function is called after that, the variable&nbsp;initialization will be ignored. So, if you then call this function like this:":"在上面的例子中，变量{}num{}是一个静态变量，所以在第一次调用函数时将被定义为{}0{}，但之后每次调用函数时，变量的初始化都会被忽略。因此，如果你再这样调用这个函数。",
    "The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child\u0027s static variable {}value{} was not initialized until the parent constructor was finished, and that in each constructor the static variable was initialized before the {}show_debug_message(){} call.":"第一个值来自父构造函数，第二个值来自子构造函数。这表明在父构造函数完成之前未初始化孩子的静态变量{}值{}，并且在每个构造函数中，在{}show_debug_message(){}调用之前已初始化静态变量。",
    "The output will be:":"输出将为：",
    "When using inheritance with constructors, any static variables in the child constructor will only be initialized once the parent constructor has been executed, so the child constructor\u0027s static variables will not override the parent\u0027s static variables. See the following example:":"当使用构造函数的继承性时，子构造函数中的任何静态变量只有在父构造函数被执行后才会被初始化，所以子构造函数的静态变量不会覆盖父构造函数的静态变量。请看下面的例子。",
    "You can also use the {}static{}&nbsp;keyword within a function to create a {}static function{}, which - like with variables - simply means that the function will only be defined once, which is the first time the function is called, for example:":"你也可以在一个函数中使用{}static{}关键字来创建一个{}static函数{}，这和变量一样，只是意味着该函数只被定义一次，也就是第一次调用该函数的时候，例如。"
}