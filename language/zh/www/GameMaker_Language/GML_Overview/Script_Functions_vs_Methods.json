{
    "A {}method variable{} is created with this syntax:":"{}方法变量{}使用以下语法创建：",
    "A {}script function{} is created with this syntax:":"{}脚本函数{}使用以下语法创建：",
    "Again, this only applies if you\u0027re calling a script function {}indirectly{}, via a reference stored in a variable. Calling it directly doesn\u0027t cause such problems.":"同样，这只适用于你通过存储在变量中的引用间接调用脚本函数{}的情况。直接调用它并不会导致这样的问题。",
    "Basic Difference":"基本差异",
    "Calling {}temp_1(){}&nbsp;now using parentheses will not increase memory usage, as the method is already created for you.":"现在使用圆括号调用{}temp_1(){}不会增加内存占用，因为已经为你创建了方法。",
    "Direct Calls":"直接调用",
    "However, since this variable refers to a {}script function{}, it first has to convert it into a {}method{}, and then call it.":"但是，由于此变量引用{}脚本函数{}，因此它必须先将其转换为{}方法{}，然后再调用它。",
    "In this example, calling {}temp_1{} will call {}reset_alpha{}, as it stores a reference to that {}method{}.":"在这个例子中，调用{}temp_1{}将调用{}reset_alpha{}，因为它存储了对该{}方法{}的引用。",
    "Indirect Calls: Methods":"间接调用：方法",
    "Indirect Calls: Script Functions":"间接调用：脚本函数",
    "Now, you can call {}temp_1{} by doing this:":"现在，您可以通过执行以下操作来调用{}temp_1{}：",
    "Or, the better solution: convert your script function {}into a method{} when passing its reference.":"或者，更好的解决方案是：在传递脚本函数引用时，将脚本函数{}转换为方法{}。",
    "Script Functions vs. Methods":"脚本函数与方法",
    "So, what is the solution?":"那么，解决方案是什么？",
    "This can easily result in increased memory usage, especially if you\u0027re calling it every frame, because the engine now has to create a new method every frame for this call.&nbsp;":"这很容易导致内存使用量增加，尤其是在你每帧调用它时，因为引擎现在必须为这个调用每帧创建一个新方法。",
    "This is creating a new method from the&nbsp;{}reset_x{}&nbsp;script function, using&nbsp;{}{}method(){}{}.":"这是从{}reset_x{}脚本函数中创建一个新方法，使用{}{}method(){}{}。",
    "This page covers essential information about using script functions vs. methods.":"本页介绍有关使用脚本函数与方法的基本信息。",
    "To implement the second solution, your code would look like this:":"要实现第二种解决方案，您的代码将如下所示：",
    "Use {}{}script_execute(){}{} to call the script function via its reference, which will not create a method.":"使用{}{}script_execute(){}{}通过脚本函数的引用调用该脚本函数，该引用不会创建方法。",
    "You are completely fine to pass around a method reference in this way. When using script functions though, there is a caveat.":"以这种方式传递方法引用是完全正确的。但在使用脚本函数时，需要注意。",
    "You can also store a reference to a script function, in another variable:":"你也可以把对脚本函数的引用，存储在另一个变量中。",
    "You can also use the function {}{}script_execute(){}{} to run a script function, although it\u0027s now a legacy function and not recommended for use.":"你也可以使用函数{}{}script_execute(){}{}来运行一个脚本函数，尽管它现在是一个遗留函数，不推荐使用。",
    "You can call both script functions and methods directly by using parentheses {}(){},&nbsp; just like a {}runtime function{}:":"你可以通过使用括号{}(){}直接调用脚本函数和方法，就像{}运行时函数{}一样。",
    "You can store a reference to a method, in another variable, to call it later through that different variable:":"您可以在另一个变量中存储对方法的引用，以便稍后通过该变量调用该方法：",
    "You should use the first syntax in scripts, to create global functions that can be called from any scope in your game.":"你应该在脚本中使用第一种语法，以创建全局函数，可以从游戏中的任何范围调用。",
    "You should use the second syntax when creating functions in {}structs/constructors{} and objects. This syntax creates a variable containing a method.":"在{}结构/构造函数{}和对象中创建函数时，应使用第二种语法。此语法创建一个包含方法的变量。",
    "{}NOTE{} See how the code doesn\u0027t put&nbsp;{}(){} after {}reset_alpha{}. That\u0027s because we\u0027re reading the method reference and not calling it.":"{}注意{}看代码中没有把{}(){}放在{}reset_alpha{}后面。这是因为我们在读取方法的引用，而不是调用它。"
}