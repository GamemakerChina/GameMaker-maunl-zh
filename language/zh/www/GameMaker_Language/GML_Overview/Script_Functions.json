{
    "Additional functions for the script can be added using the same format as shown above, one after the other within the script asset.":"可以使用与上面所示相同的格式在脚本资源中逐个添加脚本的其他函数。",
    "Also see:&nbsp;{}Script Functions vs. Methods{}":"另请参阅：{}脚本函数与方法对比{}",
    "Arguments passed into a function can also be accessed through the {}argumentN{} variables ({}argument0, argument1, etc.{}) or the {}{}argument[]{}{} array ({}argument[0], argument[1], etc.{}).":"传入函数的参数也可以通过{}argumentN{}变量({}argument0，argument1等{})或{}argument[]{}{}数组({}argument[0]，argument[1]等{})访问。",
    "Creating Functions":"创建函数",
    "Functions can also make use of static variables, which maintain their values throughout every function call. Please {}read this page{} for more information.":"函数还可以使用静态变量，这些变量在每个函数调用过程中都会保持其值。有关详细信息，请{}阅读此页面{}。",
    "Functions in scripts can also return a value, just as runtime functions can, and as such they can be used in expressions. For this you would use the {}{}return{}{} statement:":"脚本中的函数也可以返回一个值，就像运行时的函数一样，因此它们可以被用于表达式中。为此，你可以使用{}{}return{}{}语句。",
    "If an argument is not given to a function, its value will be&nbsp;{}undefined{}. You can use this to define&nbsp;{}optional{}&nbsp;arguments, and check whether an argument is passed in or not by checking if it is equal to {}undefined{}. However, you can also explicitly define a default value for an argument which will be used instead of {}undefined{}&nbsp;when it is not passed in.":"如果一个参数没有被传递给函数，它的值将是{}undefined{}。你可以用它来定义{}可选{}参数，并通过检查参数是否等于{}undefined{}来检查参数是否被传入。然而，你也可以明确地定义一个参数的默认值，当它没有被传入时，它将被用来代替{}undefined{}。",
    "If the {}dir{} argument is not passed in when calling the above function, then its value will default to {}90{}, moving the instance in an upward direction.":"如果调用上述函数时没有传入{}dir{}参数，那么它的值将默认为{}90{}，将实例向上移动。",
    "In general, however, you would use the {}first {}form for script functions as it will define the function as specifically being a script function, meaning that it will be {}global {}in {}scope{}, be assigned a {}script index{}, and not require the {}global{} prefix to identify it since the compiler will recognise it as a script function.":"然而，一般来说，你会对脚本函数使用{}首先{}的形式，因为它将定义该函数是一个脚本函数，这意味着它将是{}全局{}在{}范围{}，被分配一个{}脚本索引{}，并且不需要{} global{} 前缀来识别它，因为编译器会识别它是一个脚本函数。",
    "In the above case, not only have we defined the functions {}Foo{} and {}Bar{} but also the variable {}blah{} and all of them are considered to have been created in the {}global{} scope. The functions don\u0027t need the {}global{} keyword to be recognized as the compiler understands that these functions are part of the script, but if you wanted to access {}blah{} then you would need to do:":"在上述情况下，我们不仅定义了函数{}Foo{}和{}Bar{}，而且还定义了变量{}blah{}，并且所有这些都被认为是在{}全局{}范围内创建的。这些函数不需要识别{}全局{}关键字，因为编译器了解这些函数是脚本的一部分，但是如果要访问{}blah{}，则需要执行以下操作：",
    "Index-Based Arguments":"基于索引的参数",
    "It is important to understand that script {}names{} are {}independent of the functions that they contain{}, so you can name your scripts in a more \"common sense\" way, ie: all your AI functions could go in a script \"{}Enemy_AI{}\" (following the standard asset naming conventions of alpha-numeric characters and the under-bar \"_\" only). However, you can still call scripts in your game - and you can name scripts the same as a function that you define in them - which can give rise to a issues due to the way that {}GameMaker{} stores asset references. To give an example consider this code, called from an instance:":"了解脚本{}名称{}{}独立于它们包含的函数{}很重要，因此您可以用更“常识”的方式命名您的脚本，即：您的所有 AI 函数都可以放在一个脚本“{}Enemy_AI{}”（仅遵循字母数字字符和下划线“_”的标准资源命名约定）。但是，您仍然可以在游戏中调用脚本 - 您可以将脚本命名为与您在其中定义的函数相同的名称 - 由于 {}GameMaker{} 存储资源引用的方式，这可能会引起问题。举个例子考虑这个代码，从一个实例调用：",
    "It should be noted that the {}{}execution of the function ends at the return statement{}{}, meaning that any code which comes after {}return {}has been called {}will not be run{}. Here is a short example function from a function called \"{}sqr_calc{}\" which calculates the square of whatever value is passed to it, and in case the given value is not a real number, it uses {}return{} to end the function early so the actual calculation never runs:":"需要注意的是，函数的{}{}执行在返回语句{}{}处结束，也就是说，任何在{}return{}之后的代码都{}不会被运行{}。下面是一个名为\"{}sqr_calc{}\"的简短函数示例，该函数计算传递给它的任何数值的平方，如果给定的数值不是实数，它将使用{}return{}来提前结束函数，因此实际计算永远不会运行。",
    "Note how all these constants are set up outside of any&nbsp;function call, meaning they will be initialised before everything else and at a {}global {}scope. This means that if you want to use a script&nbsp;to initialise variables on an {}instance {}scope then you must wrap them in a function, for example:":"请注意，所有这些常量都是在任何函数调用之外设置的，这意味着它们将在所有其他东西之前被初始化，而且是在{}全局{}范围内。这意味着，如果你想用脚本来初始化{}实例{}范围内的变量，那么你必须用函数来包装它们，比如说。",
    "Note that if you create a script function with&nbsp;{}no{}&nbsp;return value then in your code check for one, you will get the value {}undefined{}&nbsp;by default.":"注意，如果你创建的脚本函数{}没有{}返回值，那么在你的代码中检查时，你将得到{}undefined{}的默认值。",
    "One final thing to note about script functions is that if you are developing for {}Web {}(ie: targeting {}HTML5{}), then there is an additional function protocol that you can use when adding functions to scripts, which is to prefix a function name with {}gmcallback_{}, for example:":"关于脚本函数需要注意的最后一件事是，如果您正在为 {}Web{} 开发（即：以 {}HTML5{} 为目标），那么在向脚本添加函数时可以使用一个额外的函数协议，即在函数名称前加上 {}gmcallback_{}，例如：",
    "Optional Arguments":"可选参数",
    "Parameters/Arguments":"Parameters/Arguments 参数",
    "Return Value":"返回值",
    "Script Functions And Variables":"脚本函数和变量",
    "Script Names vs. Function Names":"脚本名称与函数名称",
    "Script Scope":"脚本范围",
    "Script assets&nbsp;are essentially a collection of one or more user defined functions or variables that you write yourself as snippets of code in the {}Script Editor{}. The functions you define in a script can resolve expressions, return values or do anything else that the GameMaker Language permits, just like the built in {}runtime functions{}.":"脚本资源实质上是一个或多个用户定义的函数或变量的集合，您可以在{}脚本编辑器{}中将自己编写为代码片段。您在脚本中定义的函数可以解析表达式、返回值或执行GameMaker语言允许的任何其他操作，就像内置的{}运行时函数{}一样。",
    "Script functions&nbsp;should generally be used if you have a block of code that you use in more than one place or object, or when you want a block of code to be used across multiple objects in a modular fashion. Using scripts to define functions means that you can change the function just once when required and the change will be \"picked up\" by every object that has a call to the function.":"如果在多个位置或对象中使用了一个代码块，或者希望以模块化方式将一个代码块用于多个对象，则通常应使用脚本函数。使用脚本定义函数意味着您只需在需要时更改一次函数，每个对函数有调用的对象都会\"拾取\"该更改。",
    "Scripts can also be very handy from an organisational point of view, as they permit you to create groups of functions that belong to a certain category - for example, you might have several functions all related to collisions between instances in your game, so you would create a \"{}Collision_Functions{}\" script and store all these functions together in it.":"从组织角度来看，脚本也可以非常方便，因为它们允许您创建属于某个类别的函数组-例如，您可能拥有多个与游戏中实例之间的冲突相关的函数，因此您可以创建\"{}Collision_Functions{}\"脚本并将所有这些函数一起存储在其中。",
    "So, scripts can be used to generate macros, enums and global variables before the game starts so they are ready for use at any time, and they can also be used to create \"unbound\" methods (user-defined functions) that can be used in your game like GML runtime functions.":"因此，脚本可以用来在游戏开始前生成宏、枚举和全局变量，这样它们就可以随时使用，而且它们还可以用来创建 \"非绑定 \"方法(用户定义的函数)，这些方法可以像GML运行时函数一样在你的游戏中使用。",
    "Static Variables":"静态变量",
    "That said, we recommend that you {}always explicitly type global variables{} when creating them in scripts to prevent any issues later. Scripts are also an ideal place to define any {}Macros{} or {}Enums{} ({}constants{}), as adding them to a script outside of a function also means that they will be created for use before the game code actually starts running. Below is an example of a script that is creating different global scope values for a game:":"也就是说，我们建议您{}在脚本中创建全局变量时始终显式键入{}，以防止以后出现任何问题。脚本也是定义任何{}宏{}或{}枚举{}({}常量{})的理想位置，因为将它们添加到函数之外的脚本中也意味着将在游戏代码实际开始运行之前创建脚本以供使用。下面是为游戏创建不同全局范围值的脚本示例：",
    "The above code is attempting to call a script called \"myscript\" within a method, which in this case will fail. This is because the in-line function is actually using the {}index{} for the script asset and {}not {}actually calling the script function - eg: if the script index resolves to \"4\", essentially the function is calling {}4(arg);{}, which makes no sense. The code should instead be structured in one of the following two ways:":"上面的代码试图在一个方法中调用一个名为“myscript”的脚本，在这种情况下会失败。这是因为内联函数实际上是在使用脚本资源的{}索引{}，而{}不是{}实际调用脚本函数 - 例如：如果脚本索引解析为“4”，本质上是函数在调用{}4(arg);{}，这毫无意义。代码应该改为采用以下两种方式之一构建：",
    "The default&nbsp;value of an optional variable can be an&nbsp;expression, so for example, you can use variables and call functions while defining an optional variable. Note that such an expression will only be executed&nbsp;if its&nbsp;optional argument is not provided in the function call. See the following example of a logging function:":"可选变量的默认值可以是一个表达式，因此，例如，你可以在定义可选变量的同时使用变量并调用函数。注意，这样的表达式只有在函数调用中没有提供其可选参数时才会被执行。请看下面这个日志函数的例子。",
    "This function takes three arguments, where the&nbsp;first argument defaults to a string constant,&nbsp;the second argument defaults to an instance variable (in the scope of the calling instance) and the third argument defaults to an expression calling a function to retrieve the current date and time. This function can now be called with up to three&nbsp;arguments,&nbsp;as seen in the following example:":"这个函数需要三个参数，其中第一个参数默认为一个字符串常量，第二个参数默认为一个实例变量(在调用实例的范围内)，第三个参数默认为一个调用函数检索当前日期和时间的表达式。现在可以用最多三个参数来调用这个函数，如下面的例子所示。",
    "This function takes two arguments and applies their values to the instance\u0027s {}speed{} and {}direction{} variables. It can now be called like any runtime function and arguments can be passed into it:":"该函数接收两个参数，并将其值应用于实例的{}speed{}和{}direction{}变量。现在，它可以像其他运行时函数一样被调用，参数可以被传入。",
    "This is important to note, especially when working with legacy projects where scripts contain one single function, and the function is named the same as the script. However, you really should&nbsp;{}never{}&nbsp;do this, and your scripts should be named independently of the functions they contain.":"需要注意的是，这一点非常重要，尤其是在使用传统项目时，如果脚本包含一个单独的函数，并且该函数的命名与脚本相同。但是，您确实应该{}永远不要{}执行此操作，并且您的脚本的命名应该与它们包含的函数无关。",
    "This leads us to the final and most important thing to know about scripts and the functions they contain: scripts are parsed on a {}global{} level and will be {}compiled at the very start of the game{}. This means that {}technically{} all functions in a script are \"unbound\"&nbsp;{}method variables{}, and any variables declared outside of a function in the script will be considered {}global variables{}. For example, consider this script:":"这引导我们了解关于脚本及其包含的函数的最后也是最重要的事情：脚本在{}全局{}级别进行解析，并将{}在游戏一开始就编译{}。这意味着{}技术上{}脚本中的所有函数都是“未绑定”{}方法变量{}，并且在脚本中的函数外部声明的任何变量都将被视为{}全局变量{}。例如，考虑这个脚本：",
    "This {}print(){} function loops through all the passed arguments, and adds them to a string variable. That string is then printed to the output log.":"这个{}print(){}函数循环浏览所有传递的参数，并将它们添加到一个字符串变量中。然后，该字符串被打印到输出日志中。",
    "To call a script function from within a piece of code, just use it the same way as when calling any runtime function - that is, write the function name with the parameter values in parentheses. So, the above script would be called like this:":"要在一段代码中调用一个脚本函数，只需像调用任何运行时函数一样使用它--即把函数名称和参数值写在括号里。因此，上面的脚本会被这样调用。",
    "To create a function in GML Visual, use&nbsp;{}Declare A New Function{}. Enable its \"Temp\" option to create a method variable (second syntax shown above).":"要在GML Visual中创建一个函数，请使用{}声明一个新函数{}。启用其 \"Temp \"选项来创建一个方法变量(如上图所示的第二个语法)。",
    "Using the above function name would mean that the function {}gmcallback_create_button(){} will not be obfuscated and so can be used in JavaScript extensions and other areas of your game, for example, when using the {}{}clickable_*{}{}&nbsp;functions.":"使用上述函数名称将意味着函数{}gmcallback_create_button(){}不会被混淆，因此可以在JavaScript扩展和游戏的其他领域使用，例如，在使用{}{}clickable_*{}{}函数时。",
    "Using the second form will instead be generating a global scope {}method variable{}, and as such it will {}not {}be recognised as a script function by the IDE and will require the use of the {}global{} prefix when being referenced&nbsp;in your code.":"使用第二种形式将生成一个全局范围的{}方法变量{}，因此它{}不会被IDE识别为一个脚本函数，在你的代码中引用时需要使用{} global {}前缀。",
    "We also recommend that you add comments to define the properties of the function (see the section on {}JSDoc Comments{} for more details), such that a simple script would look like this:":"我们还建议你添加注释来定义函数的属性(详见{}JSDoc Comments{}一节)，这样一个简单的脚本会是这样的。",
    "When creating a script with functions in it, the functions must be created using the following formats:":"创建包含函数的脚本时，必须使用以下格式创建函数：",
    "You can assign such a default value to a parameter using the equal ({}={}) sign, making it an optional variable:":"你可以用equal({}={})符号给参数指定这样一个默认值，使其成为一个可选变量。",
    "You can define your own parameters/arguments for a function, which will be available to the function as local variables and can be used for any purpose within that function:":"你可以为一个函数定义你自己的参数，这些参数将作为局部变量提供给函数，并可用于该函数的任何用途。",
    "You can get the number of arguments passed into the function using {}{}argument_count{}{}, thus allowing a variable number of arguments to be passed in.":"你可以使用{}{}argument_count{}{}来获得传入函数的参数数，从而允许传入可变的参数数。",
    "You can now call this function with as many strings as you like, which will all be joined together.":"现在你可以用任意多的字符串调用这个函数，这些字符串都将被连接在一起。",
    "or:":"或:",
    "{}NOTE{}&nbsp;Keep in mind that if your script is {}completely empty{}, it will not be loaded into the compiled game and will become non-existent; meaning that trying to reference such a script asset will crash your game. Note that this only applies to scripts that are completely empty, so even if your script only contains&nbsp;comments, it will still be included in the compiled game.":"{}注意{}请记住，如果您的脚本{}完全为空{}，则不会将其加载到编译的游戏中并且不存在;这意味着尝试引用此类脚本资源将导致游戏崩溃。请注意，这仅适用于完全为空的脚本，因此即使您的脚本仅包含注释，它仍将包含在编译的游戏中。",
    "{}NOTE{}&nbsp;You can check this by using both forms in a script and then calling the runtime&nbsp;function {}typeof(){} on each of them. One will be classed as a \"number\" - since it returns a script index ID - and the other will be classed as a \"method\".":"{}注意{}你可以通过在一个脚本中使用两种形式，然后分别调用运行时函数{}typeof(){}来检查。其中一个将被归类为 \"数字\" --因为它返回一个脚本索引ID --而另一个将被归类为 \"方法\"。",
    "{}NOTE{}: When using your own functions from scripts in the code editor, you can press{}&nbsp;{}{} or click the middle mouse button {}{}&nbsp;{}on the function name to open the script that contains it for editing directly.":"{}注意{}：在代码编辑器中使用自己的脚本中的函数时，您可以按{}{}{}或在函数名称上单击鼠标中键{}{}，直接打开包含该函数的脚本进行编辑。",
    "{}TIP{}&nbsp;You can omit arguments from function calls and they will default to {}undefined{}&nbsp;(or the default value for that argument as defined by the function).{}\n    {}\n    For example, writing&nbsp;{}my_func(0,,,1){} is the same as writing&nbsp;{}my_func(0, undefined, undefined, 1){}.\n  ":"{}提示{}你可以在函数调用中省略参数，它们将默认为{}undefined{}(或函数定义的该参数的默认值)。\n{}\n例如，写{6}my_func( 0,, 1){7}与写{8}my_func( 0, undefined, undefined, 1){9}是一样的。{}"
}