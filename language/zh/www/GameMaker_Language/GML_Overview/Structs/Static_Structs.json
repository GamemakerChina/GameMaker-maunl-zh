{
    "After applying the static struct for {}potion{} to it (which is a constructor), it becomes an instance of {}potion{} (as tested with {}is_instanceof(){}) and also gets any static variables and static methods contained in the {}potion{} constructor.":"在将 {}potion{} 的静态结构应用于它之后，它将成为 {}potion{} 的实例 (如用 {}is_instanceof(){} 测试的那样)，并且还获得包含在 {}potion{} 构造函数中的任何静态变量和静态方法。",
    "After applying the static struct for {}potion{} to it, it becomes an instance of {}potion{} (as tested with {}{}is_instanceof{}(){}) and also gets any static variables and static methods contained in the {}potion{} constructor.":"在将 {}potion{} 的静态结构应用于它之后，它将成为 {}potion{} 的实例 (如用 {}{}is_instanceof{}(){} 测试的那样)，并且还获得包含在 {}potion{} 构造函数中的任何静态变量和静态方法。",
    "As static variables belong to the constructor in which they\u0027re defined, it is possible to define a static variable in a child constructor with the same name as a static variable of the parent constructor. For example:&nbsp;":"由于静态变量属于定义它们的构造函数，因此可以在子构造函数中定义与父构造函数的静态变量同名的静态变量。例如：",
    "Changing The Static Struct":"改变静态结构",
    "Checking Inheritance":"检查多重继承",
    "Each shape now has its own {}count{}&nbsp;static variable that keeps track of the number of items of that shape. Child shapes will increment the {}count{} of their parent shapes as well, as they run their parents\u0027 constructors in addition to their own.":"现在，每个形状都有自己的{}count{}静态变量，用于跟踪该形状的项目数量。子形状也会增加其父形状的{}计数{}，因为它们除了运行自己的构造函数之外，还运行父形状的构造函数。",
    "Every function has a \"static struct\", where its static variables are stored. You can get that struct using&nbsp;{}{}static_get{}{}:":"每个函数都有一个\"静态结构\"，其中存储了它的静态变量。您可以使用{}{}static_get{}{}获取该结构：",
    "Every struct created from the constructor accesses its static variables from that static struct.":"从构造函数创建的每个结构都从该静态结构访问其静态变量。",
    "For example, let\u0027s say you have a constructor {}item{}, and a constructor {}potion{}&nbsp;which is a child of&nbsp;{}item{}:":"例如，假设您有一个构造函数 {}item{}，以及一个构造函数 {}potion{}，它是 {}item{} 的子级：",
    "How the Dot Operator Looks Up a Variable Name":"点运算符如何查找变量名称",
    "If the struct contains a non-static variable with that name, the dot operator returns that variable. If it doesn\u0027t, the dot operator returns the first variable in the static chain with that name, checking the current static struct, and then traversing back the entire static chain, if needed, until a variable with that name is encountered.&nbsp;If the variable name cannot be found anywhere in the static chain,&nbsp;{}GameMaker{}&nbsp;will throw an error.":"如果该结构包含具有该名称的非静态变量，则点运算符返回该变量。如果没有，点运算符返回静态\u200B\u200B链中具有该名称的第一个变量，检查当前静态结构，然后根据需要遍历整个静态链，直到遇到具有该名称的变量。如果在静态链中的任何位置都找不到变量名称，{}GameMaker{}将抛出错误。",
    "In certain situations you may want to access a static variable or method of the parent constructor from within the child constructor. To achieve this, you can go up the static chain and access the parent\u0027s static variable:&nbsp;":"在某些情况下，您可能希望从子构造函数中访问父构造函数的静态变量或方法。为了实现这一点，您可以沿着静态链向上访问父级的静态变量：",
    "In the code above, upon loading the potion struct from a JSON string, it\u0027s only created as a simple struct and doesn\u0027t belong to a constructor, nor does it have any static variables.":"在上面的代码中，从 JSON 字符串加载 potion 结构时，它只被创建为一个简单的结构，不属于构造函数，也没有任何静态变量。",
    "In the code above, upon loading the potion struct, it\u0027s only created as a simple struct and doesn\u0027t belong to a constructor, nor does it have any static variables.":"在上面的代码中，在加载 potion 结构时，它只被创建为一个简单的结构，不属于构造函数，也没有任何静态变量。",
    "It creates a struct from the {}potion{} constructor. Using {}is_instanceof(){}, we can check that the new struct:":"它从 {}potion{} 构造函数创建一个结构。使用 {}is_instanceof(){}，我们可以检查新结构：",
    "Let\u0027s say you\u0027re looking for a specific variable in a struct, using the dot operator (i.e. {}struct.variable_name{}).":"假设您正在使用点运算符(即{}struct.variable_name{})在结构体中查找特定变量。",
    "Now, if you call {}static_get(static_potion){}, you will get the static struct for {}item{}! This is the same struct you would get from {}static_get(item){}.":"现在，如果您调用 {}static_get(static_potion){}，您将获得 {}item{} 的静态结构！这与您从 {}static_get(item){} 获得的结构相同。",
    "Parent\u0027s Static Variable or Method":"父级的静态变量或方法",
    "Same Variable Name in Parent &amp; Child Constructor":"父级和父级中的变量名称相同子构造函数",
    "Static Chain":"静态链",
    "The above code shows three constructors:&nbsp;{}item{}, {}potion{} which is a child of {}item{}, and {}enemy{}, which is a separate constructor.":"上面的代码显示了三个构造函数：{}item{}，{}potion{}，它是 {}item{} 的子类，以及 {}enemy{}，它是一个单独的构造函数。",
    "The following happens in the above code:&nbsp;":"上面的代码中发生了以下情况：",
    "The function&nbsp;{}{}static_set{}{}&nbsp;is provided to let you change the static struct of a function (constructor or not). This way you can change what static variables are available to a constructor and its structs, and also change the \"static chain\" that a constructor belongs to.":"函数 {}{}static_set{}{} 允许您更改函数的静态结构 (构造函数或非构造函数)。通过这种方式，您可以更改构造函数及其结构可用的静态变量，还可以更改构造函数所属的 \" 静态链\"。",
    "The recommended use-case for this function is deserialisation. If you\u0027re loading structs from JSON, those structs won\u0027t belong to any constructors, however you can change that by using&nbsp;{}{}static_set{}{}&nbsp;to \"apply\" a constructor to a struct, so that that struct receives its shared static variables and you can run&nbsp;{}{}is_instanceof{}{}&nbsp;to check its kind.":"此函数的推荐用例是反序列化。如果您从 JSON 加载结构，那么这些结构将不属于任何构造函数，但是您可以通过使用 {}{}static_set{}{} 将构造函数 \" 应用 \" 到一个结构，以便该结构接收其共享的静态变量，并且您可以运行 {}{}is_instanceof{}{} 来检查其类型。",
    "The static structs of the top-level constructor functions, i.e. those that don\u0027t have a parent constructor, share the same parent struct. This struct is the \"root\" static struct, which has&nbsp;{}undefined{}&nbsp;as its&nbsp;parent struct:&nbsp;":"顶级构造函数的静态结构(即那些没有父构造函数的静态结构)共享相同的父结构。该结构是\"根\"静态结构，其父结构为{}undefined{}：",
    "This is also true for {}constructor functions{}. Each constructor has a static struct, where its static variables and static methods are stored.":"对于{}构造函数{}也是如此。每个构造函数都有一个静态结构，其中存储了它的静态变量和静态方法。",
    "This is because {}item{} is the parent of the {}potion{} constructor, so the static struct for {}item{} is linked to the static struct for {}potion{}.":"这是因为 {}item{} 是 {}potion{} 构造函数的父级，因此 {}item{} 的静态结构链接到 {}potion{} 的静态结构。",
    "This is done by checking if your struct has the given constructor\u0027s static struct anywhere in its static chain.":"这是通过检查结构是否在其静态链中的任何位置具有给定构造函数的静态结构来完成的。",
    "This means that you can get the full static chain of a struct as follows:":"这意味着您可以获取结构的完整静态链，如下所示：",
    "This shared struct is the root parent struct of {}all{} structs and defines the default&nbsp;{}toString{} function that\u0027s called when the struct is converted to string.":"此共享结构是{}所有{}结构的根父结构，并定义在结构转换为字符串时调用的默认{}toString{}函数。",
    "This way you can check whether a struct \"is\" something, as {}a potion is an item{}, so it returns {}true{} for both constructors. However if wouldn\u0027t be true the other way around: {}an item is not a potion{}.":"通过这种方式，您可以检查结构是否\"是\"某物，因为 {}potion 是 item{}，因此它为两个构造函数返回 {}true{}。然而，如果不是真的，反过来：{} item 不是 potion {}。",
    "When you use constructor inheritance, those constructors form a \"static chain\" - a chain of static structs where each child links to its parent.":"当您使用构造函数继承时，这些构造函数形成一个\"静态链\" -- 一个静态结构链，其中每个子级都链接到其父级。",
    "You can get the static struct of {}potion{} using {}static_get(potion){}&nbsp;- this is where the static variables for {}potion{} are stored. Let\u0027s call this {}static_potion{}.":"您可以使用 {}static_get(potion){} 获取 {}potion{} 的静态结构-这是存储 {}potion{} 的静态变量的位置。让我们将其称为 {}static_potion{}。",
    "You can use&nbsp;{}{}is_instanceof{}{}&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent.":"您可以使用 {}{}is_instanceof{}{} 来检查结构是否属于给定的构造函数，或者是否将该构造函数作为父构造函数。",
    "is a {}potion{}":"是一个 {}potion{}",
    "is an {}item{}":"是一个 {}item{}",
    "is not an {}enemy{}":"不是一个 {}enemy{}",
    "{}Static Struct{}":"{}静态结构{}",
    "{}child1{}&nbsp;is a {}child{}, which has no {}show(){} method of its own but inherits from {}root{}. {}root.show(){} is called and {}\"root\"{} is output.":"{}child1{}是一个{}child{}，它没有自己的{}show(){}方法，但继承自{}root{}。调用{}root.show(){}并输出{}\"root\"{}。",
    "{}child2{} is a {}child_with_static_func{}, which has a static {}show(){}&nbsp;method. This method is called, which outputs {}\"child_with_static_func\"{}.":"{}child2{}是一个{}child_with_static_func{}，它具有静态{}show(){}方法。调用此方法会输出{}\"child_with_static_func\"{}。",
    "{}child3{} is a {}child_with_func{}, which inherits from {}root{} but also has its own (non-static)&nbsp;{}show(){} method. It calls its own {}show(){} method, outputting {}\"child_with_func\"{}.":"{}child3{}是一个{}child_with_func{}，它继承自{}root{}，但也有自己的(非静态){}show(){}方法。它调用自己的{}show(){}方法，输出{}\"child_with_func\"{}。",
    "{}{}WARNING{}{}&nbsp;You can\u0027t access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.":"{}{}警告{}{}您无法从从未调用过的函数访问静态变量，因为静态变量是在第一次调用函数时初始化的。尝试这样做将会出现错误并导致游戏崩溃。",
    "{}{}{}Static{} Struct{}{}":"{}{}{}静态{}结构{}{}"
}