{
    "By far the most common and practical method, however, is to use a&nbsp;{}variable{} on the left of the point, as long as the variable in question{} has stored a valid {}instance id{}{}. The following examples illustrate this.":"然而，到目前为止，最常见和实用的方法是在点左侧使用{}变量{}，只要有问题的变量{}存储了有效的{}实例id{}{}。下面的例子说明了这一点。",
    "In practice it would look like this:":"在实践中，它看起来像这样。",
    "In the above code for Example 1, there is an {}{}instance_exists(){}{}&nbsp;call in the code block. This is because using the point method to access or change another instances value will give an error and crash the game if the instance does not exist, and there is the possibility that this is the case in that example. We don\u0027t need the check however in Examples 2 and 3 because we {}know{} that the instance is there since in Example 2 we created it, and in Example 3, its the other instance in a collision event. However, if there is {}any{} possibility that the instance could be destroyed, deactivated, or otherwise removed from the room while using this method, you should {}always{} check beforehand using the {}instance_exists(){} function or the {}{}instance_number(){}{}&nbsp;function.":"在上面例1的代码中，有一个{}{}instance_exists(){}{}代码块的调用。这是因为使用点方法来访问或改变另一个实例的值，如果该实例不存在，就会出现错误并使游戏崩溃，而在这个例子中就有可能出现这种情况。然而在例2和例3中我们不需要检查，因为我们{}知道{}实例是存在的，因为在例2中我们创建了它，而在例3中，是碰撞事件中的另一个实例。然而，如果在使用这个方法时，有{}任何{}可能性，即实例可能被销毁、停用或以其他方式从房间中移除，你应该{}总是{}事先使用{}instance_exists(){}函数或{}{}instance_number(){}{}函数来检查。",
    "In the sections dedicated to {}variables{} you found out how to create and use variables within a single instance, or on a global scope, but what happens if you want one instance to access a variable in another, different instance? There are many cases when you may want to do this, for example in a collision with a bullet object, you may want to find out how much damage the bullet does by accessing a variable in the bullet, or you might want to stop the motion of all the balls in a puzzle, or you might want to move the main character to a particular position, or any number of other situations you typically come across in any game. Thankfully the GameMaker Language comes equipped with mechanisms to achieve this.":"在专门讨论{}变量{}的章节中，你发现了如何在单个实例中或在全局范围内创建和使用变量，但如果你想让一个实例访问另一个不同实例中的变量，会发生什么？有很多情况下你可能想这样做，例如在与子弹物体的碰撞中，你可能想通过访问子弹中的一个变量来了解子弹的伤害程度，或者你可能想在一个谜题中停止所有球的运动，或者你可能想把主角移动到一个特定的位置，或者你在任何游戏中通常遇到的任何其他情况。值得庆幸的是，GameMaker语言配备了实现这一目的的机制。",
    "It is also important to note that you cannot use&nbsp;any function by itself as the left-hand side of an assignment. For example, the following code would give you an error:":"同样重要的是要注意，你不能使用任何函数本身作为赋值的左边。例如，下面的代码会给你一个错误。",
    "Note that you cannot use the special {}keyword{} \"{}all{}\" with this method to target all instances(eg: {}all.val = 10{} would give an error), but you {}can{} use the keywords \"{}other{}\" and \"{}self{}\" without issues. For example, using {}other{} in a {}collision event{}:":"注意，你不能在这个方法中使用特殊的{}关键字{}\"{}all{}\"来针对所有实例(例如 {}all.val= 10{}会出错)，但你{}可以{}使用关键字\"{}other{}\"和\"{}self{}\"，不会有问题。例如，在一个{}碰撞事件{}中使用{}other{}。",
    "One of the most common methods of accessing or changing a variable in {}another {}instance is to use its object name as an identifier, and then use a point \"{}.{}\" to tell {}GameMaker{} that the variable being referenced should&nbsp;be assigned or changed within that specific object\u0027s instance. This is known as \"dot notation\", and its syntax is as follows:":"访问或改变{}另一个{}实例中的变量的最常见方法之一是使用其对象名称作为标识符，然后使用点\"{}.{}\"来告诉{}GameMaker{}，被引用的变量应该在该特定对象的实例中被分配或改变。这被称为 \"点符号\"，其语法如下。",
    "The other way to reference variables in another instance is to use the GameMaker Language function {}with(){}, which is discussed in detail {}here{}:":"另一种引用另一个实例中的变量的方法是使用GameMaker语言函数{}with(){}，{}这里详细讨论过{}。",
    "The return value for the expression in that code example is an integer number (the unique ID value for the nearest instance) and so it must be enclosed in brackets {}(){} to be used in this way and properly address the instance required. The above code would be correctly written as:":"该代码示例中表达式的返回值是一个整数(最近实例的唯一Id值)，因此必须将其括在括号{}(){}中，才能以这种方式使用并正确处理所需的实例。上述代码将正确写入为：",
    "These are all perfectly valid ways of reading, changing and setting variables in other instances, and work because the point is actually an {}operator{}. It takes a value as the left {}operand{} and a variable as the right operand, and returns the address of this particular variable in the indicated object or instance. All the object names, constants, IDs etc... simply represent values and these can be dealt with like any other value.":"这些都是读取、改变和设置其他实例中的变量的完全有效的方法，之所以有效是因为 点 实际上是一个{}操作符{}。它把一个值作为左{}操作数{}，把一个变量作为右操作数，并返回指定对象或实例中这个特定变量的地址。所有的对象名称、常量、ID等等......都只是代表值，这些都可以像其他值一样被处理。",
    "With the above code you are setting the speed of an instance of \"{}obj_ball{}\". However if you have more than one instance of the given object in the room, {}then it will apply to ALL of them equally{} - unless you are using {}HTML5{}, in which case it will affect only {}one{}, but you have no way of knowing which one it will affect - so if you need to access all instances of an object, you should be using {}{}with(){}{}, as that is 100% cross platform compatible. In general, this format should only be used when you have a single instance of the object in the room, or (as you will see in the next part) when you have a specific {}instance {}ID{}{}.":"通过上述代码，你正在设置\"{}obj_ball{}\"的一个实例的速度。然而，如果你在房间里有一个以上的对象实例，{}那么它将同样适用于所有对象{}--除非你使用{}HTML5{}，在这种情况下，它将只影响{}一个{}，但你无法知道它将影响哪一个--所以如果你需要访问一个对象的所有实例，你应该使用{}{}with(){}{}，因为那是100%跨平台兼容。一般来说，只有当你的房间里只有一个对象的实例，或者(正如你将在下一部分看到的)你有一个特定的{}实例{}ID{}{}时，才应该使用这种格式。",
    "You can also access a single instance of an object when there are multiple instances within the room using the unique {}instance name{} to tell {}GameMaker{} exactly which instance we wish to address. The {}instance name constant{} is the unique identifying constant that is given to each and every instance added to a room in your game. You can find this constant by double clicking on an instance in the {}room editor{}:":"当房间内有多个实例时，您也可以使用唯一的{}实例名称{}来确切告诉{}GameMaker{}我们要处理的实例，从而访问该对象的单个实例。{}实例名称常量{}是游戏中添加到房间的每个实例的唯一标识常数。你可以在{}房间编辑器{}中双击一个实例来找到这个常量：",
    "{}// This will affect all instances of the object \"obj_Enemy\"{}{}\n    {}with{} (obj_Enemy){}\n    {{}\n    &nbsp; &nbsp; target = {}other{}.parent;{}\n    }{}\n    {}\n    {}// This will affect one instance of the object \"obj_Enemy\"{}{}\n    {}var{} _enemy = {}instance_nearest{}({}x{}, {}y{}, obj_Enemy);{}\n    {}if{} {}instance_exists{}(_enemy){}\n    {{}\n    &nbsp; &nbsp; {}with{} (_enemy){}\n    &nbsp; &nbsp; {{}\n    &nbsp; &nbsp; &nbsp; &nbsp; target.{}x{} = {}mouse_x{};{}\n    &nbsp; &nbsp; &nbsp; &nbsp; target.{}y{} = {}mouse_y{};{}\n    &nbsp; &nbsp; }{}\n    }\n  ":"{}// 这将影响 \"obj_Enemy\"对象的所有实例{}{}\n    {}with{} (obj_Enemy){}\n    {{}\n    &nbsp; &nbsp; target = {}other{}.parent;{}\n    }{}\n    {}\n    {}// 这将影响 \"obj_Enemy\"对象的一个实例 {}{}\n    {}var{} _enemy = {}instance_nearest{}({}x{}, {}y{}, obj_Enemy);{}\n    {}if{} {}instance_exists{}(_enemy){}\n    {{}\n    &nbsp; &nbsp; {}with{} (_enemy){}\n    &nbsp; &nbsp; {{}\n    &nbsp; &nbsp; &nbsp; &nbsp; target.{}x{} = {}mouse_x{};{}\n    &nbsp; &nbsp; &nbsp; &nbsp; target.{}y{} = {}mouse_y{};{}\n    &nbsp; &nbsp; }{}\n    }\n  ",
    "{}Note that this name can be be edited and given a more descriptive name - although the name {}must{}&nbsp;be unique to the entire game -&nbsp;and it can be used as the left-hand side of the point:":"{}请注意，可以编辑此名称并赋予更描述性的名称-尽管名称{}必须{}对于整个游戏而言是唯一的-并且可以用作点的左侧:"
}