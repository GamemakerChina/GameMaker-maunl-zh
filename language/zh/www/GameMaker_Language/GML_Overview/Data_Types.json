{
    "A boolean is simply a value that can either be&nbsp;{}true{}&nbsp;or&nbsp;{}false{}. Note that currently&nbsp;{}GameMaker{}&nbsp;will interpret a real number equal to or below 0.5 as a&nbsp;{}false{}&nbsp;value, and any real number greater than 0.5 as being&nbsp;{}true{}. This does&nbsp;{}not{}&nbsp;mean however that you should be checking 1 and 0 (or any other real number) for true and false, as you are also provided with the&nbsp;{}constants{}&nbsp;{}true{}&nbsp;and&nbsp;{}false{}&nbsp;which should always be used in your code to prevent any issues should real boolean data types be added in a future update.":"布尔值可以是 {}true{} 或 {}false{}。注意，当前 {}GameMaker{} 将等于或低于0.5的实数解释为 {}false{} 值，而任何大于0.5的实数将解释为 {}true{}。但是 {}不是{} 意味着你应该检查1和0(或任何其他实数)是否为真和假，因为你还提供了 {} 常量{} {}true{} 和 {}false{} 这应该总是在你的代码中使用在将来的更新中添加真实的布尔数据类型，以防止出现任何问题。",
    "A hexadecimal value can also begin with a hash/pound symbol ({}#{}), however when written this way, its value will not equal a similar hex value written using a previously shown format ({}${} or {}0x{}). This is due to the way colours are interpreted in GML, which required the format for hash/pound hex values to be changed so that CSS colours could be written in an {}#RRGGBB{} format. For more information, read {}Hex Colours{}.":"十六进制值也可以以哈希/磅符号({}#{})开头，但是，以这种方式写入时，其值将不等于使用先前显示的格式({}${}或{}0x{})写入的类似十六进制值。这是由于Gml中解释颜色的方式，这要求更改哈希/磅十六进制值的格式，以便可以以{}#Rrggbb{}格式写入CSS颜色。有关详细信息，请阅读{}十六进制颜色{}。",
    "A pointer is a data type that \"points\" to a memory location. You cannot do operations on a pointer and it is used only for some very specific functions, like getting a texture or buffer address from memory for another function. For examples of functions that return a pointer you can see&nbsp;{}{}buffer_get_address(){}{}&nbsp;or&nbsp;{}{}sprite_get_texture(){}{}.":"指针是一种“指向”内存位置的数据类型。你不能对指针进行操作，它只用于一些非常特定的函数，比如为另一个函数从内存中获取纹理或缓冲区地址。对于返回指针的函数示例，您可以看到 {}{}buffer_get_address(){}{} 或 {}{}sprite_get_texture(){}{}。",
    "An \"int64\" is a 64-bit integer that can be created using {}{}int64(){}{} (by passing in a non-64-bit real number) or when reading a {}buffer_u64{} value from a {}buffer{}.":"\"int 64\"是一个64位整数，可以使用{}{}int 64(){}{}(通过输入非64位实数)或从{}缓冲区{}读取{}buffer_u64{}值来创建。",
    "An enum is an \"enumerator\", and it essentially permits you to create your own limited data type with a list of constant values. Enums are explained in depth on the page for {}Constants{}.":"枚举是\"枚举器(enumerator)\"，它基本上允许您使用常量值列表创建自己的有限数据类型。{}常量{}的页面上详细说明了枚举。",
    "Any bitwise operations, even when run on non-64-bit values, will always return a 64-bit integer back.":"任何按位操作，即使在非64位值上运行，也将始终返回64位整数。",
    "Before continuing, let\u0027s just briefly explain what we mean by \"data types\". When you create a variable it can be used to hold information, and when you call a&nbsp;function, it can also stored returned information. However this information can come in various \"flavours\" -&nbsp;for example, it can be a {}real number{} or it can be a {}string{}. These different types of values being used are called&nbsp;{}data types{}&nbsp;and when using&nbsp;the GameMaker Language they can be any of the following:":"在继续之前，我们先简单解释一下\"数据类型\"是什么意思。创建变量时，它可用于保存信息，调用函数时，它还可以存储返回的信息。但是，此信息可以有多种\"风格\"-例如，它可以是{}实数{}或者可以是{}字符串{}。使用的这些不同类型的值称为{}数据类型{}，当使用GameMaker语言时，它们可以是以下任意值：",
    "Data Types":"数据类型",
    "Divisions on int64 values will also return integers (e.g.: {}int64(5) / int64(2) = 2{}).":"int 64值的除法也将返回整数(例如：{}int 64(5 )/ int 64(2 )= 2{}。",
    "For example, the following decimal values can be expressed as hexadecimal as shown:":"例如，以下十进制值可以表示为十六进制，如图所示：",
    "For example, the following two are not equal:":"例如，以下两项不相等：",
    "For them to refer to the same decimal value, you would have to swap the first two and last two characters:":"要使它们引用相同的十进制值，必须交换前两个和最后两个字符：",
    "In previous section&nbsp;we&nbsp;covered {}variables and their scoping rules{} but little has been said about the different {}data types{} that a variable can store. Therefore this section explains the different types and what they can be used for.":"在前面的章节中，我们介绍了{}变量及其范围规则{}，但对于变量可以存储的不同{}个数据类型{}却鲜有说明。因此，本节将说明不同的类型以及它们可用于哪些目的。",
    "Note that since {}NaN{} is not a number, it cannot be compared to itself, so&nbsp;comparisons such as {}NaN == NaN{} will return {}false{}. Same goes for an array comparison such as this:":"请注意，由于{}NaN{}不是数字，因此无法将其与自身进行比较，因此比较(例如{}NaN==NaN{})将返回{}false{}。对于数组比较(例如：",
    "Note that the {}infinity{} constant is equal to itself, so {}infinity == infinity{} will return {}true{}.":"请注意，{}无穷{}常量等于其自身，因此{}infinity==infinity{}将返回{}true{}。",
    "Note that while created variables in&nbsp;{}GameMaker{}&nbsp;are all stored as double-precision floating point numbers or integers, you can still use other formats when dealing with extensions. These can be passed into {}GameMaker{} from an extension and then checked using the appropriate&nbsp;{}is_*(){}&nbsp;function, a list of which can be found {}here{}.":"请注意，虽然{}GameMaker{}中创建的变量全部存储为双精度浮点数或整数，但在处理扩展时仍可使用其他格式。这些信息可以从扩展名传递到{}GameMaker{}，然后使用相应的{}is_*(){}函数进行检查，{}此处可以找到列表{}。",
    "Real numbers are any value that is not a string, nor any of the other possible data types. So, 124, 45639.566546456, 0, -45.5 etc... are all examples of real numbers. All real numbers are stored as 64-bit double-precision floating point values (or integer values), and the compiler will optimise where possible (for example, 0.0 will be optimised to the integer value of 0).":"实数是任何不是字符串，也不是任何其他可能的数据类型的值。因此，124, 45639.566546456,0,-45.5等...都是实数的例子。所有实数都存储为64位双精度浮点值(或整数值)，编译器将在可能的情况下进行优化(例如，0.0将被优化为0的整数值)。",
    "The \"{}Any{}\" data type can be found on many pages in the manual, e.g. {}in the arguments,{}&nbsp;or as a {}return value{}.&nbsp;It indicates that {}any type of value{} is accepted, or can be returned.":"“{}Any{}”数据类型可以在手册的许多页面上找到，例如{}在参数中{}，或作为{}返回值{}。它表示接受或返回{}任何类型的值{}。",
    "The constant&nbsp;{}infinity{}&nbsp;refers to a number that is considered infinite, such as the result you would get when dividing any floating point value by zero, eg: 1.0/0.":"常数 {}无穷大{} 指的是一个被认为是无穷大的数字，例如，将任何浮点值除以零时得到的结果，例如：1.0/0。",
    "There is also a function to check if a value is a pointer (see \"{}Checking Data Types{}\", below) and a function to convert a value into a pointer:":"还有一个函数用于检查值是否为指针(请参阅下面的\"{}检查数据类型{}\")，以及一个函数用于将值转换为指针：",
    "This can be used in places where a 64-bit integer is strictly required, or when you want to work with {}bit-shifting{} and need those 64 bit positions.":"这可用于严格要求64位整数的位置，也可用于要使用{}位移{}并需要这些64位位置的位置。",
    "This constant indicates that the pointer is not pointing to anything meaningful (the same as {}NULL{} in C++ or {}null{} in C#). This value is {}falsy{}.":"这个常数表示指针没有指向任何有意义的东西（与C++中的{}NULL{}或C#中的{}null{}相同）。这个值是{}falsy{}。",
    "This constant simply means that the value is not a valid pointer":"此常量仅表示该值不是有效的指针",
    "Type Tables":"类型表",
    "Variable Functions":"变量函数",
    "When dealing with any value that is not an integer, you may experience slight rounding errors due to the nature of floating point maths. For more information on this and other number related functions, please see:&nbsp;{}GML Reference - Number Functions{}.":"处理任何非整数值时，由于浮点数学的性质，您可能会遇到轻微的舍入错误。有关此功能和其它与数字相关的功能的详细信息，请参阅：{}Gml参考-数字函数{}。",
    "You can also find arithmetic type tables that show the results of different operations using mixed variable data types here:":"您还可以在此处找到显示使用混合变量数据类型的不同操作结果的算术类型表格：",
    "You can check the data type of any variable using the functions listed on the following the page:":"可以使用以下页面中列出的函数检查任何变量的数据类型：",
    "You can convert any real number into an implicitly boolean value using the following function:":"您可以使用以下函数将任何实数转换为隐式布尔值：",
    "You may also use (and get returned) the following built in constants when using pointers:":"使用指针时，还可以使用(并返回)以下内置常量：",
    "bool":"bool 布尔",
    "{}A method variable is a variable that has been assigned a function and it can be used exactly the same as you would use a GML runtime function. For more detailed information, please see the section&nbsp;{}Method Variables{}.{}":"{}方法变量是已分配函数的变量，可以使用与使用Gml运行时函数完全相同的变量。有关详细信息，请参阅{}方法变量{}一节。{}",
    "{}A string is simply any text that has been placed in quotation marks \"...\". You can perform certain operations on strings, like add two strings together to create a longer string (concatenation) and you can also change the string properties and even extract real numbers from it. For more information on strings and the string functions see:&nbsp;{}GML Reference - Strings{}.{}":"{}字符串只是放在引号\"...\"中的任何文本。您可以对字符串执行某些操作，如将两个字符串添加到一起以创建更长的字符串(连接)，还可以更改字符串属性，甚至从中提取实数。有关字符串和字符串函数的详细信息，请参阅：{}Gml参考-字符串{}。{}",
    "{}A struct (sometimes called a \"lightweight object\") is a raw data structure that acts as a container for variables of all data types. You assign a struct to a variable and in the struct you can then define further variables and these can then be read from or written to as required. For more detailed information on structs, please see the section&nbsp;{}GML Overview - Structs{}.{}":"{}结构(有时称为\"轻量级对象\")是一种原始数据结构，用作所有数据类型变量的容器。将结构指定给变量，然后在结构中定义进一步的变量，然后可以根据需要读取或写入这些变量。有关结构的详细信息，请参阅{}Gml概述-结构{}一节。{}",
    "{}An array is a special data type that can be used to hold multiple values. You assign the array to a variable, and then \"fill in\" different indices of the array with values. This array can then be passed through to scripts and functions on a pass-by-reference basis, however should you modify the passed array, it will then become a copy of the original array and so will need to be returned back to the original variable for the array to be updated. For more information on arrays, please see:&nbsp;{}GML Overview - Arrays{}.{}":"{}数组是一种特殊的数据类型，可用于保存多个值。将数组指定给变量，然后使用值\"填充\"数组的不同索引。然后，可以在逐个引用的基础上将此数组传递给脚本和函数。但是，如果修改传递的数组，它将成为原始数组的副本，因此需要返回到原始变量以更新数组。有关阵列的详细信息，请参阅：{}Gml概述-阵列{}。{}",
    "{}An undefined value (also known as a \"null\" value) is one where an expression doesn\u0027t have a correct value, although it is syntactically correct, and so must return&nbsp;{}something{}. For example, say you have a {}DS map{} and use the function&nbsp;{}{}ds_map_find_value(){}{}. Now, what happens when the map does not have the value being looked for? Well, since the function is correctly formatted, and the issue is that the no such value exists, then it would return the&nbsp;constant&nbsp;{}undefined{}, and you can check for this constant as you would check for&nbsp;{}true{}&nbsp;or any other value.{}{}":"{}未定义值（也称为“空”值）是指表达式没有正确值的值，尽管它在语法上是正确的，因此必须返回{}某些内容{}。例如，假设您有一个 {}DS map{}并使用函数 {}{}ds_map_find_value(){}{}。现在，当地图没有要查找的值时会发生什么？那么，由于函数格式正确，问题是不存在这样的值，那么它会返回常量 {}undefined{}，您可以像检查 {}true{} 或其他值一样检查这个常量。{}{}",
    "{}Any{}{}Any{}":"{}Any{}{}Any{} 任何",
    "{}Arrays{}{}Arrays{}":"{}Arrays{}{}Arrays{} 数组",
    "{}Boolean{}{}Boolean{}":"{}Boolean{}{}Boolean{} 布尔",
    "{}Enum{}{}Enum{}":"{}Enum{}{}Enum{} 枚举",
    "{}GameMaker{}&nbsp;will accept&nbsp;{}hexadecimal literals{}&nbsp;as legitimate values. Hexadecimal values are especially common when working with colours, but can be used anywhere a positive integer value is required. Hexadecimal values can be formatted in the following two ways, where {}{}abcd{}{}&nbsp;would be the actual hex value:":"{}GameMaker{}将接受{}个十六进制文字{}作为合法值。使用颜色时，十六进制值尤其常见，但可以在需要正整数值的任何地方使用。十六进制值可以通过以下两种方式进行格式化，其中{}{}abcd{}{}将是实际的十六进制值：",
    "{}Hexadecimal Values{}{}Hexadecimal Values{}":"{}Hexadecimal Values{}{}Hexadecimal Values{} 十六进制",
    "{}Infinity{}{}Infinity{}":"{}Infinity{}{}Infinity{} 无穷大",
    "{}Method Variables{}{}Method Variables{}":"{}Method Variables{}{}Method Variables{} 方法变量",
    "{}NOTE{}&nbsp;On the&nbsp;{}HTML5{}&nbsp;target, all real numbers are doubles.":"{}注意{}在{}HTML5{}目标上，所有实数都是双精度的。",
    "{}NaN{}{}NaN{}":"{}NaN{}{}NaN{} 非数字",
    "{}Pointer{}{}Pointer{}":"{}Pointer{}{}Pointer{} 指针",
    "{}Real Numbers{}{}Real Numbers{}":"{}Real Numbers{}{}Real Numbers{} 实数",
    "{}Strings{}{}Strings{}":"{}Strings{}{}Strings{} 字符串",
    "{}Structs{}{}Structs{}":"{}Structs{}{}Structs{}结构",
    "{}Undefined{}{}Undefined{}":"{}Undefined{}{}Undefined{} 未定义",
    "{}{}NaN{}&nbsp;stands for \"not a number\", and is a constant that can be returned when the compiler cannot evaluate the results of an operation as a number. For example, 0/0 cannot be defined as a real number, and is therefore represented by&nbsp;{}NaN{}, or the square root of a negative number - which is considered an \"imaginary\" number - cannot be represented as a real number, and so is represented by&nbsp;{}NaN{}.{}":"{}{}NaN{}代表\"非数字\"，是一个常量，当编译器无法将操作结果作为数字计算时，可以返回该常量。例如，0/0不能定义为实数，因此用{}NaN{}表示，或者负数的平方根(被认为是\"想象的\"数)不能用实数表示，因此用{}NaN{}表示。{}"
}