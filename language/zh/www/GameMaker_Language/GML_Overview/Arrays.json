{
    "&nbsp; &nbsp; &nbsp; &nbsp;Array Bounds":"数组边界",
    "&nbsp; &nbsp; &nbsp; &nbsp;Creating Arrays":"创建数组",
    "&nbsp; &nbsp; &nbsp; &nbsp;Deleting Arrays":"删除数组",
    "&nbsp; &nbsp; &nbsp; &nbsp;Extended Example":"扩展示例",
    "&nbsp; &nbsp; &nbsp; &nbsp;Using Arrays":"使用数组",
    "A multi-dimension array needs to be initialised before use, the same as a single 1D array, and can hold real numbers, strings, and any other {}data type{}, just like any variable, making them ideal candidates for any game that needs to store large amounts of data in an easily accessible way (remember, you can loop through an array easily).":"多维数组在使用前需要进行初始化，与单个1D数组相同，并且可以保存实数、字符串和任何其他{}数据类型{}，就像任何变量一样，使它们成为任何需要以易于访问的方式存储大量数据的游戏的理想候选对象(请记住，您可以轻松循环浏览数组)。",
    "Accessors":"访问器",
    "Again, all of this is not necessary if {}Copy on Write{} is {}disabled{} (which is the default and recommended option).":"同样，如果{}写时复制{}{}禁用{}(这是默认和推荐的选项)，则所有这些都不是必需的。",
    "Also see:&nbsp;{}&nbsp;{}":"另请参阅：{}变量函数{}",
    "Arrays as Function Arguments":"作为函数参数的数组",
    "Arrays&nbsp;can be extremely useful and are an essential part of making games. It is essentially a type of variable that can hold multiple values as a \"list\" -- consider the following code:":"数组非常有用，是制作游戏的重要组成部分。它本质上是一种可以将多个值保存为\"list\"的变量类型--请考虑以下代码：",
    "As described in the previous section, arrays can be passed into functions as arguments. To do this, you simply have to specify the array variable (no need for each of the individual positions, nor the {}[]{} brackets) and the entire array will be {}passed by reference{} into the function:":"正如上一节所述，数组可以作为参数传入函数。要做到这一点，你只需要指定数组变量(不需要每个单独的位置，也不需要{}[]{}括号)，整个数组将通过{}引用{}传递到函数中。",
    "As you can see, you give the array a variable name and then a value in square brackets {}[]{}, where the value is the position in the array to get the data from. So&nbsp;essentially, an array is a container with a number of slots to store values, and each position in the container has a specific number to identify it, which is what we put in the {}[]{}. It\u0027s worth noting that the contents of an array {}always&nbsp;start&nbsp;at 0{} and can {}never be negative{}{}!{}":"如您所见，为数组指定一个变量名称，然后在方括号{}[]{}中指定一个值，其中该值是数组中用于获取数据的位置。因此，实质上，数组是一个具有多个存储值的插槽的容器，容器中的每个位置都有一个特定的编号来标识它，这就是我们在{}[]{}中输入的内容。值得注意的是，数组{}的内容始终从0{}开始，并且{}永远不能为负{}{}!{}",
    "Before going any further let\u0027s clarify what an array actually is and how it\u0027s structured. An array is simply a {}data type{} that is assigned to a variable, and it can contain not just one value, but multiple values. The image below shows a schematic for a basic array:":"在进一步讨论之前，让我们先澄清一下数组究竟是什么，以及它是如何结构的。数组只是一个分配给变量的{}数据类型{}，它不仅可以包含一个值，而且可以包含多个值。下面的图片显示了一个基本数组的示意图。",
    "Copy on Write":"写时复制",
    "Find out more information on accessors and how they work, along with an example for arrays, from the following page:":"有关访问器及其工作方式的详细信息，以及阵列示例，请参阅以下页面：",
    "First we should initialize the array we are going to use in the Create event of our \"controller\" object (note the use of comments to remind you what each array entry does):":"首先，我们应该初始化要在\"controller\"对象的创建事件中使用的数组(请注意，使用注释来提醒您每个数组条目的作用)：",
    "For example, the function called above,&nbsp;{}do_something(){}, may do something simple like this:":"例如，上面调用的函数{}do_something(){}可能会做这样简单的事情：",
    "For example, this function simply changes the first three elements of the array passed into it:":"例如，这个函数只是改变了传入数组的前三个元素。",
    "Here is one final example of how this may be used in an actual game:&nbsp;Say you want to spawn four different enemies at four different points in your game depending on a random value. Well, we can use an array with 2 dimensions to do this and save writing out a load of code.":"下面是一个最后的示例，说明如何在实际游戏中使用这种方法：假设您希望根据随机值在游戏中的四个不同点生成四个不同的敌人。好吧，我们可以使用一个具有2维的数组来执行此操作，并节省写出一大堆代码的时间。",
    "However, when {}Copy on Write{} is enabled, changing any of the array\u0027s values inside the function creates a temporary copy with your modifications. The original array is not modified. This behaviour is called Copy on Write.":"但是，如果启用了{}写入时复制{}，则更改函数内部的任何数组值会创建一个包含您的修改的临时副本。不会修改原始数组。此行为称为写入时拷贝。",
    "If the array has multiple dimensions (see below), they will all be cleaned up too, and note that when you create arrays in instances, these do not need to be cleaned up when the instance is removed from the game, as they will be removed automatically by the {}garbage collector{} on Destroy or Room End. However, if any of the array positions hold references to&nbsp;{}dynamic{}&nbsp;assets, such as particle systems, buffers, or data structures, then these&nbsp;{}will{}&nbsp;need to be destroyed before the array is deleted, the instance is destroyed or the room ends.":"如果数组有多个维度(见下文)，它们也会被清理，请注意，当您在实例中创建数组时，这些不需要在实例从游戏中移除时被清理，因为它们将在销毁或房间结束时由{}垃圾收集器{}自动删除。但是，如果任何数组位置都保留了对{}动态{}资产的引用，例如粒子系统，缓冲区或数据结构，那么这些{}将需要在删除数组，实例被销毁或房间结束之前销毁{}。",
    "If you already know which items you want to put into the array, you can add comma-separated values between the brackets when declaring the array:":"如果已经知道要放入数组的项，则可以在声明数组时在括号内添加逗号分隔的值：",
    "In previous GameMaker versions, this was not the case, as modifying an array inside a function would create a copy instead. This {}deprecated{} behaviour can still be enabled if desired: read the \"{}Copy on Write{}\" section below for more information.":"在以前的GameMaker版本中，情况并非如此，因为在一个函数中修改数组会创建一个副本。如果需要的话，这种{}被废弃的{}行为仍然可以被启用：阅读下面的\"{}写时复制{}\"部分以了解更多信息。Write{}时的拷贝 \"一节，以了解更多信息。",
    "In the above code, {}array[0]{} has 2 slots, {}array[1]{} has 4 slots and {}array[2]{} has 3 slots.":"在上述代码中，{}array[0]{}有2个槽，{}array[1]{}有4个槽，{}array[2]{}有3个槽。",
    "In the above code, {}array[0]{} holds another array, and so does&nbsp;{}array[1]{}.":"在上面的代码中，{}array[0]{}持有另一个数组，{}array[1]{}也是如此。",
    "It should be noted too that the length of each dimension in an array can be different, so you can have the initial array dimension with a length of 3, but the second dimension entry can be a different length for each slot in the first dimension; for example:":"还应该注意的是，数组中每个维度的长度可以不同，所以你可以让数组初始维度的长度为3，但第二个维度条目可以是第一个维度中每个槽的不同长度;例如。",
    "Multi-dimension arrays are also not limited to {}just {}two dimensions, and you can have 3, 4 or more dimensions to an array as required in your code, just by adding {}[n]{} further arguments, eg:":"多维数组也不限于{}只是{}两个维度，只需添加{}[n]{}其他参数，就可以根据代码中的要求为数组添加3、4或更多维度，例如：",
    "Now how do we use an array practically? Exactly the same as we would use a normal variable, as shown in the following examples:":"现在，我们如何实际使用阵列？与使用普通变量完全相同，如以下示例所示：",
    "Now you would expect {}my_array{} to hold the values {}1, 200, 4{}, etc., which would normally be correct -- but when {}Copy on Write{} is enabled, the original array remains unaffected.":"现在，您将期望{}my_array{}保存值{}1、200、4{}等，这通常是正确的-但是当启用{}写时复制{}时，原始数组不受影响。",
    "Since arrays are numbered sequentially, this means you can loop through them to perform extra actions too, just like we did to initialize it:":"由于数组是按顺序编号的，这意味着您也可以循环浏览它们以执行额外的操作，就像我们初始化它们一样：",
    "That short code will now spawn a random enemy in the game room, and it uses far less code than an \"{}if / then / else{}\" structure or even a \"{}switch{}\", and as the array is initialized all together in the create event it is MUCH easier to edit and change any of those values as they are not {}hard-coded{} into the rest of the project code.":"这段简短的代码现在将在游戏室中生成一个随机的敌人，它使用的代码比\"{}if/ then/ else{}\"结构甚至\"{}switch{}\"少得多，而且由于数组是在创建事件中一起初始化的，编辑和改变这些值要容易得多，因为它们没有{}硬编码{}到项目代码的其他部分。",
    "The Copy on Write behaviour is deprecated, and is only used when \"{}Enable Copy on Write behaviour for Arrays{}\" is enabled in the {}General Game Options{}. This section describes the behaviour of arrays when this option is enabled.":"不推荐使用 \"写入时复制\" 行为，仅在{}General Game Options{}中启用 \"{}为数组启用写入时复制{}\" 时使用。本节描述了启用此选项时数组的行为。",
    "The above code gets the value from position 0 of&nbsp;the array \"{}a{}\" then outputs it to the console, which - based on the contents of the array shown in the image above - would output 125. If you did the following:":"上面的代码从数组\"{}a{}\"的第0个位置获取数值，然后将其输出到控制台，根据上图中数组的内容，将输出125。如果你做了以下事情。",
    "The above code will add up all the values in our array, draw each one of them and then draw the total value at the end.":"以上代码将我们数组中的所有值相加，每个值绘制一个，然后在最后绘制总值。",
    "The array was only initialised with 5&nbsp;positions, but we\u0027ve tried to get position 7 - since arrays are numbered from 0, {}array[6]{} is position 7&nbsp;- therefore the game generates an error and crashes.":"数组只用5个位置进行了初始化，但我们尝试获取位置7-因为数组的编号是从0开始的，{}array[6]{}是位置7-因此游戏会生成错误并崩溃。",
    "The function itself would return the modified array back:":"该函数本身将返回修改后的数组。",
    "The last thing to mention about arrays is that you can delete an array simply by \"re-assigning\" the variable that defines it to a single value. This will free up the memory associated with all the positions and values for that array. For example:":"关于数组的最后一点需要提及的是，您可以简单地通过\"重新分配\"将数组定义为单个值的变量来删除数组。这将释放与该数组的所有位置和值关联的内存。例如：",
    "The output would show \"Hi!\".":"输出将显示\"Hi!\"。",
    "The second solution is to use the&nbsp;{}@{}&nbsp;accessor to change the array values directly, which saves the CPU overhead of having to make a temporary copy. This means that you do not need to return the array from the function and can edit it directly:":"第二种解决方案是使用{}@{}访问器直接更改数组值，这节省了必须进行临时复制的CPU开销。这意味着你不需要从函数返回数组，可以直接编辑它:",
    "This is called a {}1D{} (one-dimensional) array, and as you can see the array is stored in the variable \"{}a{}\" and contains multiple values. To access the array you would do something like the following:":"这被称为{}1D{}(一维)数组，正如你所看到的，该数组存储在变量\"{}a{}\"中，包含多个值。要访问这个数组，你需要做如下的事情。",
    "This is essentially telling GameMaker that the array is actually comprised of various 1D arrays. Here\u0027s an extended example:":"这实质上是告诉GameMaker，阵列实际上是由各种1D阵列组成的。下面是一个扩展示例：",
    "This simple code will initialize a ten-slot&nbsp;array (from 0 to 9) to hold 0, ie: each slot in the array contains the value 0. You will notice that the array has been initialised {}backwards{}, with the last value being defined first. This is not strictly necessary but is the optimal way to do it as it will reserve a space in memory that is the exact size of the array, whereas if you initialize an array from 0 {}upwards{}, the memory has to be re-allocated for every additional value added (so for a ten-slot&nbsp;array, initialising it in a loop would change the memory allocation ten times). The speed difference is negligible for smaller arrays, but larger ones should be optimised as much as possible in this way.":"这个简单的代码将初始化一个十槽的数组(从0到9) 以保持0，即: 数组中的每个槽都包含值0。您会注意到数组已向后{}初始化{}，最后一个值是首先定义的。这不是严格必要的，但这是最好的方式来做到这一点，因为它将在内存中保留一个空间，这是数组的确切大小，而如果你初始化一个数组从0{}向上{}，内存必须重新分配每增加一个额外的值(所以对于一个十槽数组，在循环中初始化它会改变内存分配十次)。对于较小的数组，速度差异可以忽略不计，但是较大的数组应以这种方式尽可能地优化。",
    "This tells GameMaker that the variable \"{}my_array{}\" is an array, and you can then {}add values{} to it at any time in the future. However, if you try to access a value in an empty&nbsp;array then you will get an error.":"这告诉GameMaker，变量\"{}my_array{}\"是一个数组，然后你可以{}在未来的任何时候向它添加值{}。然而，如果你试图访问一个空数组中的值，那么你会得到一个错误。",
    "To actually modify the original array that was passed into the function, you must either return it back, or use the {}@{} accessor.":"要实际修改传递到函数中的原始数组，您必须将其返回或使用{}@{}访问器。",
    "To work around this, you can make the function {}return{} the modified array copy, and then apply it back to the original variable:":"为了解决这个问题，你可以让函数{}返回{}修改后的数组副本，然后将其应用于原始变量。",
    "Using the {}[item, item, item]{} syntax we are creating an array that is stored in a variable. The items stored in an array can later be accessed through that variable using an integer number, starting at {}0{}, which is placed inside {}[]{} brackets:":"使用{}[item ,item ,item]{}语法，我们将创建一个存储在变量中的数组。稍后可以使用整数(从{}0{}开始)通过该变量访问存储在数组中的项目，该整数位于{}[]{}括号内：",
    "Using this accessor bypasses the Copy on Write behaviour and directly modifies the referenced array. This can be used to selectively disable Copy on Write for specific statements while keeping the option enabled.":"使用此访问器可以绕过 写时复制 行为，直接修改引用的数组。这可用于有选择地为特定语句禁用 写时复制，同时保持该选项处于启用状态。",
    "We now have the objects to spawn instances of and their corresponding x and y spawn coordinates within the room all stored in our array. This can now be used as follows in another event of the controller object (an alarm for example, or a key press event):":"我们现在有了要生成实例的对象，以及它们在房间里相应的X和Y的生成坐标，都存储在我们的数组中。现在可以在控制器对象的另一个事件中使用(例如，一个警报，或一个按键事件)。",
    "We\u0027ve shown how to check an array for data, but how do we create the array to start with? First it has to be&nbsp;{}initialized{} before we can use it or {}GameMaker{} will give us an error. Initializing an array just means that we give each slot of the array an initial value in preparation for it to be used elsewhere in the project code. This is important to remember as it means that you have to do a certain amount of planning before using arrays, but it is easy enough to initialize one using a repeat loop like this:":"我们已经演示了如何检查阵列中的数据，但是我们应该如何创建阵列？首先必须对其进行{}初始化{}才能使用，否则{}GameMaker{}将给出错误消息。初始化数组只是意味着我们为数组的每个插槽提供一个初始值，以便在项目代码的其他位置使用它。请务必记住这一点，因为这意味着您必须在使用阵列之前进行一定数量的规划，但是使用如下重复循环来初始化阵列非常容易：",
    "You can also initialize a multi-dimensional array within one statement&nbsp;by nesting 1-dimensional arrays:":"也可以通过嵌套一维数组在一个语句中初始化多维数组：",
    "You can also use the GML function {}{}array_create(){}{} to initialize an array with&nbsp;a fixed size, and you can even create \"empty\" arrays with&nbsp;{}no{}&nbsp;values, for example:":"您还可以使用Gml函数{}{}array_create(){}{}初始化具有固定大小的数组，甚至可以使用{}否{}值创建\"清空\"数组，例如：",
    "You can now create an array and pass it into this function, which will modify the array:":"现在你可以创建一个数组并将其传入该函数，该函数将修改数组。",
    "You can pass arrays into&nbsp;{}script&nbsp;functions{} and {}method variables{} as arguments, and modify those arrays anywhere inside the function. Doing so will modify the original arrays as well.":"你可以将数组作为参数传入{}脚本函数{}和{}方法变量{}，并在函数中的任何地方修改这些数组。这样做也会修改原来的数组。",
    "You should always take care to only access valid array positions, as trying to access a value outside of an array will also give an error. For example, this will cause the project to crash when run:":"应始终注意只访问有效的数组位置，因为尝试访问数组外部的值也会导致错误。例如，这将导致项目在运行时崩溃：",
    "{}1-Dimensional Arrays{}{}1-Dimensional Arrays{}":"{}1-Dimensional Arrays{}{}1-Dimensional Arrays{} 一维数组",
    "{}A basic array is classed as having 1 {}dimension{}, but you can have arrays with more than one dimension too. The sections below explain both types of arrays:{}":"{}一个基本的数组被归类为有1{}个维度{}，但是你也可以有不止一个维度的数组。下面的章节解释了这两种类型的数组：{}。",
    "{}Multi-Dimensional Arrays{}{}Multi-Dimensional Arrays{}":"{}Multi-Dimensional Arrays{}{}Multi-Dimensional Arrays{} 多维数组",
    "{}NOTE{}: The HTML5 export is the exception to the above rule, and when targeting that you should initialise arrays in consecutive order from 0 upwards.":"{}注意{}：HTML5导出是上述规则的例外情况，当确定要从0向上连续初始化数组时。",
    "{}NOTE{}{}&nbsp;{}The above code is not necessary if you are not changing any of the array\u0027s values, but rather referencing them. Referencing an array will not copy it and will be faster to parse.":"{}注意{}{}{}如果您不更改数组的任何值，而是引用它们，则不需要上面的代码。引用数组不会复制它，解析速度会更快。",
    "{}We now know what a 1-dimensional array is, but in {}GameMaker{} you can have arrays with multiple dimensions, which are essentially structured as an array inside an array inside an array... For example, the following is a {}2D{}&nbsp;(two-dimensional) array:{}":"{}我们现在知道什么是一维数组，但是在{}GameMaker{}中，您可以有多个维度的数组，这些数组本质上是作为数组内部的数组构成的...例如，以下是{}2D{}(二维)数组：{}"
}