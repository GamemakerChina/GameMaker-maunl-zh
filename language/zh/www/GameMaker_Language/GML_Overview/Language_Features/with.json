{
    "An example of using {}continue{} in a {}with{}&nbsp;loop would be:":"在 {}with{} 循环中使用 {}continue{} 的示例如下：",
    "As indicated in the section {}Addressing Variables in Other Instances{}, it is possible to read and change the value of variables in instances and {}structs{} other than the one currently executing any given code. However, in a number of cases you want to do a lot more than just change a single variable within those other instances, and may want to perform more complex code actions that require multiple functions and lines of code. For example, imagine that you want to move all the instances of a ball object in your game 8 pixels down. You may think that this is achieved simply by the following piece of code:":"正如{}在其他实例中处理变量{}一节所指出的，可以读取和改变当前执行任何给定代码的实例和{}结构{}中的变量值。然而，在很多情况下，你想做的事情远不止是在这些其他实例中改变一个变量，而且可能想执行更复杂的代码操作，需要多个函数和代码行。例如，想象一下，你想把你游戏中的一个球对象的所有实例向下移动8像素。你可能认为这只需通过下面这段代码即可实现。",
    "As mentioned above, within the statement(s), the indicated instance or struct&nbsp;has become the target ({}self{}) instance that runs the code block, which means that the original instance (that contains the {}with{} and the entire code block) has become the {}{}other{}{} instance. So - for example -&nbsp;to move all balls to the position of the current instance that actually contains the code, you can type this:":"如上所述，在语句中，指示的实例或结构已成为运行代码块的目标 ({}self{}) 实例，这意味着原始实例（包含 {}with{} 和整个代码块）已成为 {}{}other{}{} 实例。因此 - 例如 - 要将所有球移动到实际包含代码的当前实例的位置，您可以键入：",
    "But this is not correct, as the right side of the assignment gets the value of the y-coordinate of the first ball and adds 8 to it. Next this new value is set as the y-coordinate of {}all {}balls, so the result is that all balls get the same y-coordinate, and even if you use the following:":"但这是不正确的，因为赋值的右侧获取第一个球的 y 坐标值并将其加 8。接下来，这个新值被设置为{}所有{}球的 y 坐标，因此结果是所有球都获得相同的 y 坐标，即使您使用以下内容也是如此：",
    "Essentially this is a loop, and each {}iteration{}&nbsp;of the loop, the code will run on one instance of the object {}obj_ball{}.":"从本质上讲，这是一个循环，循环的每次{}迭代{}，代码都会在对象 {}obj_ball{} 的一个实例上运行。",
    "For the {}expression{}, you can indicate&nbsp;one or more instances (or a struct)&nbsp;to perform the code on, using&nbsp;an instance ID, the object ID (which indicates that&nbsp;{}all instances{}&nbsp;in the room of this object are to run the code block), the struct ID,&nbsp;or one of the special&nbsp;{}keywords{}&nbsp;({}all{}&nbsp;or&nbsp;{}other{}). This will then change the {}scope{} of the code within the curly brackets {}{}{}&nbsp;from&nbsp;the instance, struct or function that actually holds the code to the instance (or instances or struct) given in the expression.":"对于{}表达式{}，您可以使用实例 ID 指示一个或多个实例（或结构）执行代码，对象 ID（指示此对象房间中的{}所有实例{}用于运行代码块）、结构 ID 或特殊{}关键字{}之一（{}all{} 或 {}other{}）。然后，这会将大括号 {}{}{} 内代码的{}范围{}从实际保存代码的实例、结构或函数更改为表达式中给出的实例（或多个实例或结构）。",
    "If you want to execute multiple statements, just include them in the curly brackets, the same as you would around any other code block. So for example, to move all the balls in our example to a random position and give them a random speed and direction, you would use:":"如果你想执行多条语句，只需将它们包含在大括号中，就像你在任何其他代码块周围一样。因此，例如，要将示例中的所有球移动到随机位置并给它们随机速度和方向，您可以使用：",
    "It is worth noting that you can use the special {}{}break{}{} and {}{}continue{}{} statements within a {}{}{}with{}{}{}&nbsp;call too. Using {}break{} will immediately exit the {}with{} code block and move on to any code that is in the event or function after the {}with{} should have finished, eg:":"值得注意的是，您也可以在 {}{}{}with{}{}{} 调用中使用特殊的 {}{}break{}{} 和 {4}{5}continue{6}{7} 语句。使用 {}break{} 将立即退出 {}with{} 代码块，并在 {}with{} 应该完成后继续执行事件或函数中的任何代码，例如：",
    "Once the expression has set the scope of the {}with{}, the {}statement{} will then be executed for each of the indicated instances, as if that instance is the current ( {}self{}) instance. So, returning to our original problem, to move all instances of the ball object 8 pixels down you would type:":"一旦表达式设置了 {}with{} 的范围，就会为每个指定的实例执行 {}语句{}，就像该实例是当前 ({}self{}) 实例一样。因此，回到我们最初的问题，要将球对象的所有实例向下移动 8 个像素，您可以键入：",
    "The above code is slightly more complex than previous ones due to it using a {}local variable{}. This variable is {}local {}to either the {}event{}&nbsp;or the {}script&nbsp;{}{}function{}&nbsp;and not to the instance or struct and so can be used and accessed by all instances that are referenced within the code block. So, in the code above we have set a local variable to the special&nbsp;keyword&nbsp;{}noone{}&nbsp;and then use the&nbsp;{}with{}&nbsp;construction to have every instance of&nbsp;{}obj_Ball{}&nbsp;check their&nbsp;{}str{}&nbsp;variable against that of the instance running the code block. If the value of the variable is larger, then they store their unique ID in the&nbsp;{}inst{}&nbsp;local variable, meaning that at the end of the code, only the instance with a value greater than the calling instance (or the&nbsp;keyword&nbsp;{}noone{}&nbsp;if none are larger) will be stored in the local variable {}_inst{}.":"上面的代码比之前的代码稍微复杂一些，因为它使用了一个{}局部变量{}。这个变量对{}事件{}或{}脚本{}{} 函数{}而言是{}局部 {}，而不是对实例或结构而言，因此可以被代码块中引用的所有实例使用和访问。因此，在上面的代码中，我们将一个局部变量设置为特殊的关键字{}noone{}，然后使用{}with{}结构让{}obj_Ball{}的每个实例对照运行代码块的实例检查其{}str{}变量。如果变量的值更大，那么他们就会将自己的唯一ID存储在{}inst{}本地变量中，这意味着在代码结束时，只有值大于调用实例的实例（或者如果都不大则是关键字{}noone{}）会被存储在本地变量{}_inst{}中。",
    "The above code loops through the instances in the room of the object {}obj_Enemy{} and sets the variable {}hp{} to 100 for the first 10 it finds. If any more than 10 instances exist, the with code will call {}break{} and end.":"上面的代码循环遍历对象 {}obj_Enemy{} 房间中的实例，并将找到的前 10 个变量 {}hp{} 设置为 100。如果存在超过 10 个实例，with 代码将调用 {}break{} 并结束。",
    "The above code uses {}with{} to target a struct and set the given struct member variables to the values stored in the instance variables from the instance calling the code.":"上面的代码使用 {}with{} 来定位结构并将给定的结构成员变量设置为存储在调用代码的实例的实例变量中的值。",
    "The above code will create an instance of {}obj_Ball{} and assign it the speed and direction of the instance that runs the whole code block.":"上述代码将创建一个 {}obj_Ball{} 实例，并为其分配运行整个代码块的实例的速度和方向。",
    "The above code will destroy the instance of {}obj_Ball{} nearest to the instance running the code.":"上述代码将销毁离运行代码的实例最近的 {}obj_Ball{} 实例。",
    "The {}with{} statement is an extremely powerful tool and is useful in many, many circumstances so it is important that you understand fully how it can be used. To help there are a few more examples of use below:":"{}with{} 语句是一个极其强大的工具，在很多情况下都很有用，因此您必须充分了解如何使用它。为了提供帮助，下面还有一些使用示例：",
    "This code will loop through all instance with the parent {}obj_Enemy_Parent{}, then checks each instance to see if the {}invulnerable{} instance variable is {}true{} or not. If it is, the {}continue{} keyword ends the current iteration of the loop and moves on to the next available instance, otherwise it removes 25 from the {}hp{} variable. This will repeat until all instances with that parent have been checked.":"这段代码将循环所有父代{}obj_Enemy_Parent{}的实例，然后检查每个实例，看{}invulnerable{}实例变量是否为{}true{}。如果是，{}continue{}关键字将结束当前的循环迭代，并进入下一个可用的实例，否则将从{}hp{}变量中删除25。这将重复进行，直到所有具有该父类的实例都被检查过。",
    "it will have exactly the same effect because it is simply an abbreviation of the first statement. So how {}do{} we achieve something like this? This is why the {}with{} statement exists in GML. The {}with{} statement has the following syntax:":"它将具有完全相同的效果，因为它只是第一条语句的缩写。那么我们{}如何{}实现这样的目标呢？这就是 GML 中存在 {}with{} 语句的原因。 {}with{} 语句具有以下语法：",
    "{}NOTE{}&nbsp;Instances in a room are created in a certain {}order{}, and their Create events are also executed as they are created one-by-one. This means that you must be careful when reading variables from other instances in the Create event, as that other instance may not have run its Create event yet!{} {} For example: let\u0027s say {}ObjectA{} is created before {}ObjectB{}, and you have the following code in those objects\u0027 Create events:{} {} {}ObjectA {}Create -&nbsp;{}myValue = objectB.myValue;{}{} {}ObjectB {}Create -&nbsp;{}myValue = 10;{}{} {} ObjectA is created first and its Create event runs, which then crashes the game:{} {} {}{}\"Variable objectB.myValue(100003, -2147483648) not set before reading it.\"{}{}{} {} That\u0027s simply because ObjectB has not even been created yet, so any variables initialised in its Create event do not yet exist. This is why you must take caution when referencing other instances&nbsp;like this in the Create event, including any code run inside {}{}with(){}{} blocks. ":"{}注意{}房间中的实例是按照特定的{}顺序{}创建的，它们的创建事件也会在一个接一个创建时执行。这意味着您在从 创建事件中的其他实例读取变量时必须小心，因为其他实例可能尚未运行其 创建事件！{}{}例如：假设 {}ObjectA{} 在 {}ObjectB{} 之前创建，并且您在这些对象的创建事件中有以下代码：{}{}{}ObjectA {}创建 -{}myValue = objectB.myValue;{}{}{}ObjectB {}创建 -{}myValue = 10;{}{}{}首先创建 ObjectA 并运行其 Create 事件，然后导致游戏崩溃：{}{}{}{}“变量 objectB.myValue(100003, -2147483648) 在读取之前未设置。”{}{}{}{}这仅仅是因为 ObjectB 甚至还没有被创建，所以在它的 创建事件中初始化的任何变量都不存在。这就是为什么在 创建事件中引用其他类似实例时必须小心，包括在 {}{}with(){}{} 块内运行的任何代码。"
}