{
    "A collision event can only happen between {}two {}instances. You {}can{} have multiple collisions between multiple instances, but they are all resolved by {}GameMaker{} on a 1-on-1 basis, with the \"self\" instance that has the collision event and the \"other\" instance that is colliding with it.":"碰撞事件只能发生在{}两个{}实例之间。{}可以{}在多个实例之间有多个碰撞，但{}GameMaker{}会以1对1的方式解决这些冲突，具有冲突事件的\"self\"实例和与其冲突的\"other\"实例。",
    "All instances currently active in the room.":"房间中当前处于活动状态的所有实例。",
    "Collision Event":"碰撞事件",
    "Constructor Function":"构造函数",
    "Do note that in events other than the&nbsp;collision event, when outside of any function calls and {}with(){} blocks, {}other{} simply returns the struct for the current instance.":"请注意，在碰撞事件之外的事件中，当在任何函数调用和{}with(){}块之外时，{}other{}只是返回当前实例的结构。",
    "For example, let\u0027s say {}Object2{} has a method that references {}self{} and {}other{}. This method is then called in {}Object1{}. Since the method was created in {}Object2{}, it is&nbsp;{}bound{}&nbsp;to it and will always use the {}Object2{}&nbsp;instance as the \"self\", no matter which instance calls it. In such a case, the calling instance becomes&nbsp;{}other{}.":"例如，假设{}Object2{}有一个引用{}self{}和{}other{}的方法。然后在{}Object1{}中调用该方法。由于方法是在{}Object2{}中创建的，所以它与{}绑定{} 并始终使用{}Object2{} 实例作为“self”，无论哪个实例调用它。在这种情况下，调用实例变成 {}other{}。",
    "For this, the player will need to have a collision event with {}obj_Bullet{}, and within that event use {}other{} to read variables from the colliding bullet instance:":"为此，玩家需要与{}obj_Bullet{}发生碰撞事件，并在该事件中使用{}other{}从碰撞项目符号实例读取变量：",
    "However, you do not need to use {}other{} to read variables from the instance as any variables you reference directly will be read from that instance\u0027s scope, as described {}in this section{} of the manual. You would only need to use this if you wanted to store a reference to that instance\u0027s struct.":"但是，您不需要使用{}other{}从实例中读取变量，因为您直接引用的任何变量都将从该实例的作用域中读取，如手册{}本节{}中所述。只有当您希望存储对该实例的结构的引用时，才需要使用此方法。",
    "Imagine you have a player instance, multiple enemy instances and multiple bullet instances that the enemy can fire at you. You can assign each enemy a single bullet instance but with a different damage variable randomly assigned to it when created, for example:":"想象一下，你有一个玩家实例，多个敌人实例和多个子弹实例，敌人可以向你开火。您可以为每个敌人指定一个项目符号实例，但在创建时会随机指定不同的损坏变量，例如：",
    "In this example you can see that we have a {}local{} variable called {}val{} and we want it to set the {}instance{} variable with the same name in the newly created object instance. To identify the instance variable correctly and tell {}GameMaker{} to set it in the instance calling the code block, we use the {}self{} keyword. In most cases you can also use the {}id{} built-in&nbsp;instance variable instead of {}self{}, but {}self{} offers certain benefits. To start with, it is faster for the compiler to identify the instance (or struct) using {}self{} rather than {}id{}, as the {}id{} value goes through the instance lookup table while {}self{} does not.&nbsp;Secondly, for those people making extensions, it is very useful to ensure the correct scoping of variables, since it is possible that a project which uses an extension may have a global scope variable or something&nbsp;with the same name as a variable in the extension.":"在此示例中，您可以看到我们有一个名为{}val{}的{}local{}变量，我们希望它在新创建的对象实例中设置名称相同的{}实例{}变量。要正确识别实例变量并告诉{}GameMaker{}在调用代码块的实例中设置它，我们使用{}self{}关键字。在大多数情况下，您还可以使用{}id{}内置实例变量而不是{}self{}，但{}self{}具有一定的优势。首先，编译器使用{}self{}而不是{}id{}来标识实例(或结构)的速度更快，因为{}id{}值会经过实例查找表，而{}self{}不会。其次，对于那些进行扩展的人来说，确保变量的正确范围非常有用，因为使用扩展的项目可能具有全局范围变量或与扩展中的变量具有相同名称的东西。",
    "In this example, the function {}instance_nearest(){} will return either {}noone{} or the unique ID of the nearest found instance. Basically, any time that you need to check for an instance, you can expect to get either {}noone{} or a unique instance ID returned.":"在此示例中，函数{}instance_nearest(){}将返回{}noone{}或最近找到的实例的唯一ID。基本上，任何需要检查实例的时候，都可以获得{}noone{}或返回唯一的实例Id。",
    "Instance Keywords":"实例关键字",
    "Instance Method":"实例方法",
    "It is also worth noting that {}self{} can also be used within {}structs{}&nbsp;- under very specific circumstances - to reference member variables for the struct.":"还值得注意的是，在非常特定的情况下，{}self{}也可以在{}结构{}&nbsp;中使用，以引用结构的成员变量。",
    "It may seem odd, but many times while programming your games will you find the need to check if there are no instances found at a location, or in a collision etc... In those cases you would use this keyword to check for nothing, something like this:":"这可能看起来很奇怪，但很多时候，在编程游戏时，您会发现需要检查是否在某个位置找不到实例，或者在碰撞中等等……在这些情况下，您可以使用此关键字进行空检查，例如：",
    "No instance at all.":"没有任何实例。",
    "Note that all the given keywords are represented by&nbsp;{}negative integer values{} internally, so care must be taken when assigning or checking variable values against or with these keywords, as you may get unexpected results later as {}GameMaker{} interprets the value you have used as something else. You should also note that using the integer values directly instead of the keywords in your code is {}not recommended at all{} and could cause issues later on.":"注意，所有给定的关键字在内部都是由&nbsp;{}负整数值{}表示的，所以在分配或检查变量值时必须注意这些关键字，因为{}GameMaker{}可能会在以后得到意想不到的结果，因为你已经使用了其他值。您还应该注意，在您的代码中直接使用整数值而不是关键字是完全不建议使用{}的，{}可能会在以后引起问题。",
    "Struct Declaration":"结构声明",
    "The above code will deduct the amount stored in the {}other{} instance\u0027s \"damage\" variable from the player\u0027s \"hp\" variable, then it will check to see if the \"hp\" is lower than or equal to 0. If it is then it will destroy the player instance. Please note that&nbsp;the other instance must have the variable being checked or else an error will be thrown.":"以上代码将从玩家的“hp”变量中扣除{}other{}实例的“伤害”变量，然后它将检查“hp”是否小于或等于0。如果是，那么它将破坏玩家实例。请注意，另一个实例必须有被检查的变量，否则将抛出错误。",
    "The above code will set the speed of all instances in the room to 0. You can also use {}all{} within functions to target or check all instances in the room for example:":"上述代码将房间中所有实例的速度设置为0。您还可以在函数内使用{}all{}来锁定或检查房间中的所有实例，例如：",
    "The instance/struct which is executing the current block of code.":"正在执行当前代码块的实例/结构。",
    "The other instance involved in a collision event, in a {}with{} function or in a function.":"碰撞事件中涉及的另一个实例，在{}with{}函数中或在函数中。",
    "The same will apply to a method that is bound to a struct.":"这同样适用于绑定到结构的方法。",
    "The special keyword {}other{} has multiple ways that it can be used to reference a specific instance (and in some cases, a struct): it can be used in a {}with{} statement (explained&nbsp;{}here{}),&nbsp;in a {}collision event{}, or in a function. This section is going to explain the last two use cases.":"特殊关键字{}other{}有多种方法可以用来引用特定实例(在某些情况下，还可以引用结构):它可以在{}with{}语句中使用(在{}这里解释{})，在{}碰撞事件{}中使用或在函数中使用。本节将解释最后两个用例。",
    "This keyword is used to tell {}GameMaker{} that a function is to be applied, or to check, all active instances within a room (deactivated instances will not be checked or accessed). You {}cannot{} use {}all{} to access or set variables in other instances using the point method (see {}here{}), but you {}can {}use it when calling {}{}with(){}{}, for example:":"这个关键字用来告诉{}GameMaker{}一个函数将被应用，或者检查房间内的所有活动实例(未激活的实例将不会被检查或访问)。你{}不能{}使用{}all{}来使用point方法访问或设置其他实例中的变量(参见{}这里的{})，但是你{}可以在用(){}{}调用{}{}时使用{}，例如:",
    "This would cause the instance to first print its own object name&nbsp;(\"Object2\") and then the object name of the calling instance (\"Object1\").":"这将导致实例首先打印自己的对象名(\" Object 2\")，然后打印调用实例的对象名(\" Object 1\")。",
    "To make certain things easier in {}GameMaker{}, you can use one of several {}instance keywords{} in your code (whether GML or GML Visual). These keywords are used primarily to identify instances - and in some cases structs - under different situations, and each one is explained in the text below.":"为了在{}GameMaker{}中简化某些事情，你可以在代码中使用几个{}实例关键字{}中的一个(无论是GML还是GML Visual)。这些关键字主要用于识别不同情况下的实例(在某些情况下是结构)，每个关键字在下面的文本中进行解释。",
    "Using {}other{} within another instance\u0027s {}method{} refers to the instance that called that method.":"在另一个实例的{}方法{}中使用{}other{}会引用调用该方法的实例。",
    "When used inside a struct declaration, {}other{} refers to the instance that is initialising the struct:":"在结构声明内部使用时，{}other{}引用正在初始化结构的实例：",
    "When used within a constructor function, {}other{} will reference the instance that is calling that function,&nbsp;however this is not recommended for general use as any external data that a constructor needs to use should be passed in as arguments.":"在构造函数中使用时，{}other{}将引用正在调用该函数的实例，但不建议在一般情况下使用该实例，因为构造函数需要使用的任何外部数据都应作为参数传入。",
    "You can assign values to variables, or even create new ones, using {}other{} in the collision event, like this:":"您可以在碰撞事件中使用{}其他{}为变量指定值，甚至创建新值，如下所示：",
    "You can see how we set its variables using the dot notation&nbsp;as outlined in the section on {}Addressing Variables In Other Instances{}. This will give each bullet instance a different damage value, but how will the player detect the damage that it has to take when it\u0027s hit by a bullet?":"您可以看到我们如何使用点符号设置其变量，如{}其他实例中的寻址变量{}一节所述。这将为每个项目符号实例提供不同的损坏值，但玩家如何检测它在被子弹击中时必须承受的损坏？",
    "{}NOTE{}: The Collision event is the only event that has a special meaning for the {}other{} keyword. In all other events and scripts, the behaviour of {}other{} will be defined by the context it is being used in (such as a {}with() {}block, a function, struct declaration, etc.).":"{}注意{}：\"碰撞\"事件是唯一对{}other{}关键字具有特殊含义的事件。在所有其他事件和脚本中，{}other{}的行为将由它正在使用的上下文定义(例如{}with(){}块、函数、结构声明等)。",
    "{}NOTE{}: The&nbsp;{}self{}&nbsp;keyword is {}not {}a shortcut for the actual ID value of an instance or struct and should only be used in the context explained above. If you require the ID {}value {}for an instance then you need to use&nbsp;{}self.id{}, eg:":"{}注意{}: {}self{} 关键字{}不是{}实例或结构的实际ID值的快捷方式，应该只在上面解释的上下文中使用。如果你需要一个实例的ID{}值{}，那么你需要使用 {}self.id{},例如:",
    "{}all{} is a very useful keyword and can be used in numerous situations within your code and actions, often cutting down on the amount of code you need to write to achieve a desired effect.":"{}all{}是一个非常有用的关键字，可以在代码和操作中的许多情况下使用，通常会减少需要编写的代码量以达到所需的效果。",
    "{}self{} can be used to identify the current struct or instance that is in scope in the current block of code. For example:":"{}self{}可用于标识当前代码块中范围内的当前结构或实例。例如：",
    "{}{}all{}{}{}{}all{}{}":"{}{}all{}{}{}{}all{}{} 全部",
    "{}{}noone{}{}{}{}noone{}{}":"{}{}noone{}{}{}{}noone{}{} 无",
    "{}{}other{}{}{}{}other{}{}":"{}{}other{}{}{}{}other{}{} 另一个",
    "{}{}self{}{}{}{}self{}{}":"{}{}self{}{}{}{}self{}{} 自身"
}