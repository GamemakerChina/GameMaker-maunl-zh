{
    "Above we mentioned the {}texture2D{} function, and we\u0027ll&nbsp;use that&nbsp;to grab the color at the pixel we are working on and get the transparency from it. The return value of is&nbsp;{}texture2D{}&nbsp;is&nbsp;a {}vec4{}, where the components are the red, green, blue, and alpha, in that order. We can access the alpha channel either by putting a period followed by an {}a{} or a {}w{} after the variable name. This corresponds to RGBA and XYZW, respectively.":"上面我们提到了 {}texture2D{} 函数，我们将使用它来获取我们正在处理的像素的颜色并从中获取透明度。 {}texture2D{} 的返回值是一个 {}vec4{}，其中组件按顺序为红色、绿色、蓝色和 透明度。 我们可以通过在变量名称后放置一个句点后跟 {}a{} 或 {}w{} 来访问 alpha 通道。 这分别对应于 RGBA 和 XYZW。",
    "All we need to do is call {}{}shader_get_uniform(){}{}&nbsp;to get a pointer to the uniform. The parameters we need to pass are the shader asset name (without quotation because we want to pass the ID that GameMaker generates for us) and the name of the uniform variable inside of the shader, this time as a string. This name&nbsp;needs to match exactly the one inside the shader code for it to work. We have&nbsp;also added a colour variable so we can change it at runtime and have it remember our changes.":"我们需要做的就是调用 {}{}shader_get_uniform(){}{} 获取指向 uniform 的指针。 我们需要传递的参数是着色器资源名称（没有引号，因为我们想传递 GameMaker 为我们生成的 ID）和着色器内部统一变量的名称，这次是一个字符串。 此名称需要与着色器代码中的名称完全匹配才能正常工作。 我们还添加了一个颜色变量，以便我们可以在运行时更改它并让它记住我们的更改。",
    "And our final result is this!":"我们的最终结果是这样的！",
    "And we modify the draw event to get the values and then pass them to the shader:":"我们修改绘制事件来获取值，然后将它们传递给着色器:",
    "As explained before, the idea behind a fragment shader is to return the color of the current pixel. This is done by assigning the variable {}gl_FragColor{} the final color value. The {}texture2D{} function takes a texture and a {}vec2{} with the UV coordinates you want to check in that texture, which returns a {}vec4{} with the color. In the pass through shader, all we are doing is grabbing the color of the texture in the coordinate of this pixel and multiplying it by the color of the vertex associated with this pixel.":"如前所述，片段着色器背后的想法是返回当前像素的颜色。 这是通过为变量 {}gl_FragColor{} 分配最终颜色值来完成的。 {}texture2D{} 函数采用一个纹理和一个 {}vec2{}，其中包含您要在该纹理中检查的 UV 坐标，它返回一个带有颜色的 {}vec4{}。 在 直通着色器 中，我们所做的就是获取该像素坐标中的纹理颜色，并将其乘以与该像素关联的顶点的颜色。",
    "As for our draw code, it is trivial at the moment:":"至于我们的绘制代码，目前它是微不足道的:",
    "As for the draw event, it’s quite simple since we don’t have a uniform to pass in:":"至于绘制事件，它很简单，因为我们没有要传入的 uniform ：",
    "As for the shader, we need to pass the saturation and brightness to the color, which will affect the color generated by our helper function. The section needs to be multiplied by our position to reduce the range. We will also grab&nbsp;the entire texture color, so we&nbsp;can calculate our final color by mixing the texture color with the RGB conversion of our color. The last parameter of the mix function determines how much of the second color we want to add. This is our final shader code:":"至于着色器，我们需要将饱和度和亮度传递给颜色，这将影响我们的辅助函数生成的颜色。section需要乘以我们的位置来缩小范围。我们还将获取整个纹理颜色，所以我们可以通过混合纹理颜色和我们的颜色的RGB转换来计算我们的最终颜色。mix函数的最后一个参数决定了我们想要添加多少第二个颜色。这是我们最终的着色器代码:",
    "As you can see, we can use any combination of up to four letters to create a vector of that length. We cannot attempt to access a component that would be out of bounds (for example, trying to access w in {}secondVec{} or {}thirdVec{}, since they don’t have a fourth component). Also, we can repeat letters and use them in any order, as long as the vector variable it’s being assigned to is the same size as the number of letters used.":"正如你所看到的，我们可以使用最多四个字母的任意组合来创建这个长度的向量。我们不能尝试访问超出界限的组件(例如，尝试访问{} 二维 Vec {}或{} 三维 Vec {}中的 w，因为它们没有第四个分量)。此外，我们可以重复使用字母，并以任何顺序使用它们，只要向量变量被赋值的大小与使用的字母数量相同。",
    "Creating A Shader":"创建着色器",
    "Each shader is made up of two separate components: a {}vertex shader {}and a {}fragment shader {}(also referred to as {}pixel shader{}). Let’s start with the vertex shader. Each sprite is formed by a rectangle, but computers like to draw triangles, so those rectangles are split into two triangles (sometimes called a {}quad{}). This leaves us with six vertices (corners)&nbsp;per sprite, but two of those are the same one, so we should only worry about four. Now, imagine we have a for loop that goes over every vertex and executes the code inside the vertex shader for each. This allows us to change the vertex position and color before passing it over to the fragment shader since the vertex shader is executed earlier.":"每个着色器都由两个独立的组件组成:{}顶点着色器{}和{}片段着色器{}(也称为{}像素着色器{})。让我们从顶点着色器开始。每个精灵都由一个矩形组成，但计算机喜欢绘制三角形，所以这些矩形被分成两个三角形(有时称为{}quad{})。这样每个精灵就有6个顶点(角)，但其中有两个是相同的，所以我们只需要关心4个。现在，假设我们有一个for循环，它遍历每个顶点并为每个顶点着色器执行内部的代码。这允许我们在将顶点位置和颜色传递给片段着色器之前更改它，因为顶点着色器会在更早的时候执行。",
    "Every draw call we make between {}{}shader_set(){}{}&nbsp;and {}{}shader_reset(){}{}&nbsp;will have the shader applied to it. Here, we are drawing the object sprite with our passthrough shader:":"我们在 {}{}shader_set(){}{}&nbsp;和 {}{}shader_reset(){}{}&nbsp;之间进行的每个绘图调用都会应用着色器。 在这里，我们使用直通着色器绘制对象精灵：",
    "Finally we pass the vertex color and texture coordinate to the fragment shader through our varying variables.":"最后，我们通过 varying 变量将顶点颜色和纹理坐标传递给片段着色器。",
    "Finally, we\u0027ll go back to our shader to actually use these variables now. What we will do is multiply the speed with the time and add it to the position, like so:":"最后，我们将回到我们的着色器来实际使用这些变量。我们要做的是将速度与时间相乘，并将其与位置相加，就像这样:",
    "First, we create a {}vec4{} and initialize it with the components of the position, adding one as the fourth component. In linear algebra, the convention is that we add a one to the fourth component if the vector is representing a point, or a zero if it represents an actual vector.":"首先，我们创建一个 {}vec4{} 并使用位置的向量对其进行初始化，添加一个作为第四个向量。 在线性代数中，惯例是如果向量表示一个点，我们在第四个分量上加一个 1，如果它表示一个实际向量，则在第四个分量上加一个零。",
    "For obvious reasons, when using swizzle to set component values, you can’t use the same component twice. For example, the below is not valid as you are trying to set the same component to two different values:":"出于显而易见的原因，在使用 swizzle 设置组件值时，不能两次使用同一个组件。例如，下面的内容是无效的，因为您试图将同一个组件设置为两个不同的值:",
    "Guide To Using Shaders":"着色器使用指南",
    "Having to change the shader each time we want to use a different color isn’t a good idea, especially since we’d need to have a separate shader for each color we want. Instead, we will pass the color information to the shader using a {}uniform{}. To do this, we first need to get a {}pointer {}to the uniform. We will do this in the {}Create Event{} of our object that has the sprite by adding:":"每次我们想使用不同的颜色时都必须更改着色器不是一个好主意，特别是因为我们需要为我们想要的每种颜色都有一个单独的着色器。 相反，我们将使用{}uniform {}将颜色信息传递给着色器。 为此，我们首先需要获取指向uniform的{}指针{}。 我们将在具有精灵的对象的 {} 创建事件 {} 中执行此操作，方法是添加：",
    "Here we add the uniform variable at the top of the file with the same name we used in the Create Event. Next, we calculate the normalized horizontal position by translating our current {}x{} coordinate to the origin ( {}v_vTexcoord.x - u_uv[0]{}) and then we divide&nbsp;it by the width of the sprite to make the range from 0 to 1 ({}u_uv[1] - u_uv[0]{}).":"这里，我们在文件顶部添加了与创建事件中使用的名称相同的uniform变量。接下来，通过将当前{}x{}坐标转换为原点({}v_vTexcoord.x - u_uv[0]{})计算归一化的水平位置，然后我们用它除以精灵的宽度，使范围从0到1 ({}u_uv[] - u_uv[]{})。",
    "Here’s how that would look:":"看起来是这样的:",
    "Here’s the updated code:":"这是更新后的代码:",
    "Here’s what the shader looks like at this stage:":"下面是着色器在这个阶段的样子:",
    "However, there is another way to access the components with the following syntax:":"但是，还有另一种方法可以使用以下语法访问组件:",
    "If you did everything correctly, you should be seeing something like this:":"如果你做的一切都正确，你应该会看到如下内容:",
    "If you have created a shader in {}GameMaker{}, you might have noticed the following keywords in the default {}pass-through{} shader. These keywords help the shader understand the purpose and scope of each variable:":"如果您已经在{} GameMaker {}中创建了一个着色器，那么您可能已经在默认的{}直通{}着色器中注意到了以下关键字。这些关键字帮助着色器理解每个变量的用途和范围:",
    "In the end, it looks very similar, but it’s technically more correct.":"最后，它看起来非常相似，但在技术上更正确。",
    "It would look something like this:":"它看起来像这样:",
    "It’s the same code as before, but before we draw anything, we need to pass all the uniform&nbsp;values to the shader. In this case, we are passing the color as an array of floats. As for the shader, we will change it to include the uniform and use it, so it becomes:":"它和之前的代码相同，但是在我们绘制任何东西之前，我们需要将所有的uniform值传递给着色器。在本例中，我们将颜色作为浮点数组传递。至于着色器，我们将改变它包括uniform和使用它，所以它成为:",
    "Last, we have been using {}xyzw{} as our swizzle mask, which is usually the case when dealing with positions. There are two more sets of masks you can use: {}rgba{} (used for colors), or {}stpq{} (used for texture coordinates). Internally, there is no difference between these masks, and we only use them to make the code clearer as to what the vector represents in that instance. Also, we can’t combine swizzle masks in the same operation, so this is invalid:":"最后，我们可使用{}xyzw{}作为我们的混合蒙版，这通常是在处理位置时的情况。你还可以使用另外两组蒙版:{}rgba{}(用于颜色)或{}stpq{}(用于纹理坐标)。在内部，这些蒙版之间没有区别，我们使用它们只是为了使代码更清楚地知道向量在该实例中表示什么。此外，我们不能在同一个操作中合并混合蒙版，所以这是无效的:",
    "Let’s check out what we got:":"让我们看看我们得到了什么:",
    "Let’s compile and see what we got.":"我们来编译一下，看看有什么发现。",
    "Let’s go through the code for a newly created shader asset and analyze it, starting with the vertex shader.":"让我们浏览一下新创建的着色器资源的代码并分析它，从顶点着色器开始。",
    "Let’s go to the draw event now to send these uniforms to the shader:":"我们现在去绘制事件把这些uniform送到着色器:",
    "Let’s take a quick look at the fragment shader now:":"现在让我们快速浏览一下片段着色器:",
    "Making a black and white shader is a great way to learn more about how shaders work, and a lot of beginners start by trying to do this, since conceptually it\u0027s quite simple: get every pixel and assign it a shade of gray. But is it simple? Not quite...":"制作黑白着色器是了解更多有关着色器工作原理的好方法，许多初学者都是从尝试这样做开始的，因为从概念上讲它非常简单：获取每个像素并为其分配一个灰色阴影。 但这简单吗？ 不完全的...",
    "Next, we need to add this fourth component to multiply it with the {}MATRIX_WORLD_VIEW_PROJECTION{} matrix, which is a 4x4 matrix. This multiplication will project the world position of the vertex into screen coordinates.":"接下来，我们需要添加这第四个分量以将其与 {}MATRIX_WORLD_VIEW_PROJECTION{} 矩阵相乘，后者是一个 4x4 矩阵。 此乘法会将顶点的世界位置投影到屏幕坐标中。",
    "Now that we have our first shader, all we have to do to test it is create an object and assign it a sprite, then in the {}Draw Event{}&nbsp;of the object you set the shader like this:":"现在我们已经有了第一个着色器，我们要做的就是测试它创建一个对象并分配一个精灵，然后在对象的{}画事件{}中像这样设置着色器:",
    "Now the code in our draw event will change slightly to pass the uniform variable.":"现在，在我们的绘制事件中的代码将稍微改变以传递uniform变量。",
    "One thing you might have noticed is that in the {}gl_FragColor{} code, we\u0027re&nbsp;multiplying the&nbsp;{}vec4{} with something called {}v_vColour{}. This is a variable passed by the vertex shader which tells us the color of the vertex associated with this pixel. It’s always a good idea to multiply your final calculated color with the vertex color. In most cases, it won’t do anything, but if you changed the vertex color in GML, this will reflect that (by using functions such as {}{}draw_sprite_ext(){}{}&nbsp;or {}{}draw_sprite_general(){}{}&nbsp;to change the {}{}image_blend{}{}).":"您可能已经注意到，在 {}gl_FragColor{} 代码中，我们将 {}vec4{} 与称为 {}v_vColour{} 的东西相乘。 这是一个由顶点着色器传递的变量，它告诉我们与该像素相关联的顶点的颜色。 将最终计算出的颜色与顶点颜色相乘总是一个好主意。 在大多数情况下，它不会执行任何操作，但如果您在 GML 中更改了顶点颜色，这将反映出来（通过使用 {}{}draw_sprite_ext(){}{} 或 {}{}draw_sprite_general(){}{} 等函数更改{}{}image_blend{}{})。",
    "Our draw event changes to include these uniforms like this:":"我们的绘制事件更改为包括这些uniform，如下所示：",
    "Our final shader example&nbsp;is a fun one and can be used to add life to text and buttons and other things.&nbsp;We\u0027ll start simple and add functionality gradually since this shader is highly customizable. There\u0027s quite a lot to cover for this one, so if you feel a bit lost or confused, please go back and re-read some of the sections above.":"我们的最后一个着色器例子是一个有趣的例子，可以用来为文本、按钮和其他东西添加生命。我们将从简单开始，逐渐添加功能，因为这个着色器是高度可定制的。这里有很多内容要介绍，所以如果你觉得有点迷路或困惑，请返回并重新阅读上面的部分。",
    "Outside of the main function, we see some variable declarations and their qualifiers. The attributes are given to us by GameMaker. The varying ones are created by the user to pass that information over to the fragment shader. Inside the main function, we have the calculations to find the screen position of the vertex:":"在主函数之外，我们看到一些变量声明及其限定符。 这些属性由 GameMaker 提供给我们。 不同的是由用户创建的，以将该信息传递给片段着色器。 在 main 函数中，我们进行计算以找到顶点的屏幕位置：",
    "Shader Variables":"着色器变量",
    "Shaders are often used to create beautiful graphical effects in games. They are also among the most advanced features offered by {}GameMaker{}, so it is necessary that you have a basic understanding of programming and how {}GameMaker{} works before getting started with them.":"着色器通常用于在游戏中创造漂亮的图像效果。它们也是{}GameMaker{}提供的最高级功能之一，所以在开始使用它们之前，有必要对编程以及{}GameMaker{}的工作原理有一个基本的了解。",
    "So, what is a shader?&nbsp;Initially they were created to provide shading for lighting (hence the name), but they are now used to produce a huge variety of effects. Shader code is similar to regular code, but it is (almost always) executed by the GPU, not the CPU. This difference comes with its own set of rules and limitations, but we’ll cover those later.":"最初，它们被创造出来是为了给照明提供阴影(因此得名)，但现在它们被用来产生各种各样的效果。Shader代码类似于常规代码，但它(几乎总是)由GPU而不是CPU执行。这种差异有它自己的一组规则和限制，但我们将在后面讨论这些。",
    "That\u0027s the end of this short guide and you should now have a better understanding of how shaders work and some of the uses they can be put to. You should take your time to play with the shaders you\u0027ve created following this guide, and try to experiment with them do other things - how about creating a blur shader, or a shader that makes a gameboy-style monochrome screen? - since shaders are an incredibly powerful tool for adding visual complexity and style to your games.":"以上就是本简短指南的全部内容，现在你应该对着色器的工作原理以及它们的一些用途有了更好的理解。你应该花时间来玩你已经按照本指南创建的着色器，并尝试用它们做其他的事情-如何创建一个模糊着色器，或一个着色器，使一个游戏机风格的单色屏幕? -因为着色器是一个非常强大的工具，可以为你的游戏添加视觉复杂性和风格。",
    "The first thing we want to do is color pixels with every hue, depending on the pixel’s horizontal position. The way to do this is to set the x position to be the hue and then convert from HSV (hue, saturation, brightness) format to RGB (red, green, and blue) format. For this, we will need to write a helper function in our fragment shader that takes HSV values and returns an RGB vector. We&nbsp;will use a single function which does this without the need for any {}if{}&nbsp;statements, as using conditionals in shader code makes shaders {}very {}slow, and should be avoided.":"我们要做的第一件事是根据像素的水平位置，用每种色调给像素上色。方法是将x位置设置为色相，然后将HSV(色相、饱和度、亮度)格式转换为RGB(红、绿、蓝)格式。为此，我们需要在片段着色器中编写一个辅助函数，它接受HSV值并返回一个RGB向量。我们将使用一个单独的函数来完成这个任务，而不需要任何{}if{}&nbsp;语句，因为在着色器代码中使用条件会使着色器{}非常{}慢，应该避免。",
    "The function {}{}sprite_get_uvs(){}{}&nbsp;takes a sprite and an index, and it returns an array with tons of information, such as the coordinates for each corner, how many pixels were cropped to optimize it, etc. We are interested in two of those values: the left and right coordinates of the sprite, which are stored&nbsp;in {}uv[0]{} and {}uv[2]{} respectively. In the fragment shader, we will use those values now to calculate the normalized horizontal position like this:":"函数{}{}sprite_get_uvs(){}{}&nbsp;接受一个精灵和一个索引，它返回一个包含大量信息的数组，例如每个角落的坐标，为优化它裁剪了多少像素，等等。我们对其中的两个值感兴趣:精灵的左右坐标，它们分别存储在{}uv[0]{}和{}uv[2]{}中。在片段着色器中，我们将使用这些值来计算归一化水平位置，如下所示:",
    "The result is:":"结果是:",
    "The vertex shader is executed first, and as we explained above, it deals with {}vertices{}. It is used to calculate positions, normals, and texture coordinates. These shaders are not particularly useful in 2D, since every sprite is usually a square, but it can be used to do some skewing, scaling, etc... It becomes much more useful in 3D for lighting calculations and mesh deformations. Fragment shaders are much more interesting and are what will be covered mostly here, since the fragment shader is where we get information about our textures and can tweak the final color of each pixel in our image.":"顶点着色器首先被执行，正如我们上面解释的，它处理{}顶点{}。它用于计算位置、法线和纹理坐标。这些着色器在2D中并不是特别有用，因为每个精灵通常都是一个正方形，但它可以用来做一些倾斜，缩放等……它在3D中对照明计算和网格变形更加有用。片段着色器更有趣，也是我们将在这里讨论的主要内容，因为片段着色器是我们获取纹理信息的地方，可以调整图像中每个像素的最终颜色。",
    "There\u0027s a bit more going on here than in the previous examples, but most of it should be fairly obvious to you now. First, there’s our {}hsv2rgb{} function, which takes a {}vec3{} with our HSV colour and returns another {}vec3{} with our RGB conversion. In the main function, we start by creating our HSV colour, where the hue is our x position, and we’ll leave the saturation and brightness as 1.0 for now. Then, we get the alpha from the texture so it only colors our sprite character and not the entire sprite rectangle (as we did in the colour overlay example, above). Lastly, we set our Fragment color to be our HSV color converted to RGB with the alpha, multiplied by the vertex color (good practice to do this always).":"这里的内容比前面的示例要多一些，但大部分内容现在应该已经相当明显了。首先，是我们的{}hsv2rgb{}函数，它接受带有HSV颜色的{}vec3{}，并使用RGB转换返回另一个{}vec3{}。在主函数中，我们从创建HSV颜色开始，其中色调是我们的x位置，我们现在将饱和度和亮度保留为1.0。然后，我们从纹理中获得alpha，所以它只给我们的精灵角色着色，而不是整个精灵矩形(就像我们在上面的颜色覆盖例子中所做的那样)。最后，我们设置我们的片段颜色为我们的HSV颜色转换为带有alpha的RGB颜色，乘以顶点颜色(总是这样做的好做法)。",
    "This shader should be left alone if you are not planning to play with vertex positions and it will not be used in any of the examples given below&nbsp;because all the effects shown will be created using the fragment shader.":"如果您不打算使用顶点位置，则应单独放置此着色器，并且不会在下面给出的任何示例中使用它，因为显示的所有效果都将使用片段着色器创建。",
    "This uses the component names inside the vector to access them. You can use x, y, z, or w, to get the first, second, third, or fourth components, respectively. We refer to this method as {}swizzling {}because the following syntax is also valid:":"这将使用向量内的组件名称来访问它们。您可以使用x、y、z或w分别得到第一、第二、第三或第四个分量。我们把这个方法称为{}swizzling{}，因为下面的语法也是有效的:",
    "This will give us the following result:":"这将给我们带来以下结果:",
    "Those were a lot of definitions and information, but knowing these things is necessary to understand shaders themselves.":"这些都是很多的定义和信息，但知道这些事情是必要的理解着色器本身。",
    "To initialize them, we can use the constructor to create the vector. You need to provide the same number of values as the length of the vector, but you can mix and match scalars and smaller vectors to reach the target length. Here are some examples of this:":"为了初始化它们，我们可以使用构造函数来创建向量。您需要提供与向量长度相同数量的值，但是您可以混合和匹配标量和更小的向量以达到目标长度。以下是一些例子:",
    "We also need to increase the time every frame, so in the Step Event we add:":"我们还需要每帧增加时间，所以在步事件中我们添加:",
    "We are now assigning a new {}vec4{} to {}gl_FragColor{}, where the red channel is maxed, the green, and blue channels are zero, and the alpha channel is the same as the original texture. The output looks like this:":"我们现在将新的 {}vec4{} 分配给 {}gl_FragColor{}，其中红色通道最大化，绿色和蓝色通道为零，Alpha 通道与原始纹理相同。 输出如下所示：",
    "We can also assign them another vector of the same length (or {}swizzle {}the vector until it has the proper length, but we\u0027ll explain that in a moment):":"我们也可以给它们指定另一个相同长度的向量(或者{}旋转{}这个向量直到它有合适的长度，但是我们稍后会解释) :",
    "We can edit the base shader now to do something different. We\u0027ll not be touching the vertex shader part, and only editing the fragment shader, and to start with we\u0027ll do a very simple operation, which is to make the shader draw the sprite using the colour red. We\u0027ll do this by simply changing the {}gl_FragColor{} to be red., like this:":"我们现在可以编辑基础着色器来做一些不同的事情。我们将不接触顶点着色器部分，只编辑片段着色器，开始时我们将执行一个非常简单的操作，即让着色器使用红色绘制精灵。我们将通过简单地将{}gl_FragColor{}更改为红色来做到这一点。，像这样:",
    "We declare a variable with the same name as in the create shader ({}u_color{}) and we pass it as the first three components of the {}gl_FragColor{} vector, taking advantage of swizzling. If we compile again, we should see this:":"我们声明了一个与创建着色器 ({}u_color{}) 同名的变量，并将其作为 {}gl_FragColor{} 向量的前三个组件传递，利用swizzling。 如果我们再次编译，我们应该看到：",
    "We use the dot product as a shorthand for multiplying each component of {}texColor{} with the correct weights and then add them together. If you are unfamiliar with the dot product, this is essentially what’s happening:":"我们使用点积作为缩写，将{}texColor{}的每个组件与正确的权重相乘，然后将它们相加。如果你对点积不熟悉，这就是它的本质:",
    "We would like to thank&nbsp;{}Alejandro Hitti{}&nbsp;and {}Amazon{} for permitting us to reproduce this guide. You can find the original version on the&nbsp;{}Amazon Developer Blog{}.":"我们要感谢 {}Alejandro Hitti{} 和{}Amazon{}允许我们复制本指南。您可以在 {}Amazon开发者博客{}上找到原始版本。",
    "When accessing vector components in GLSL, we have a few options. The most basic one is to treat the vector as an array and access the components using square brackets, like this:":"在访问GLSL中的向量组件时，我们有几个选项。最基本的一个是将vector作为数组，并使用方括号访问组件，像这样:",
    "When using RGB colour, if all three components are the same value, then we get a gray tone. The naïve approach to creating a shader to use this idea would be to add all three color channels (red, green, and blue) and then divide it by three. After that you\u0027d&nbsp;assigned the value to all three channels, thus creating a gray tone. Here’s what that fragment shader looks like:":"当使用 RGB 颜色时，如果所有三个分量都具有相同的值，那么我们会得到灰色调。 使用此想法创建着色器的天真的方法是添加所有三个颜色通道（红色、绿色和蓝色），然后将其除以三。 之后，您将值分配给所有三个通道，从而创建灰色调。 这是片段着色器的样子：",
    "When you create a shader in {}GameMaker{}, it will open two files for you: a vertex shader ({}.vsh{}) and a fragment shader ({}.fsh{}). This is the most basic shader you can make, which takes a sprite, reads the texture, and colors each pixel with that color. If you specify vertex colors when drawing, those colors will blend with the texture.":"当您在 {}GameMaker{} 中创建着色器时，它会为您打开两个文件：顶点着色器 ({}.vsh{}) 和片段着色器 ({}.fsh{})。 这是您可以制作的最基本的着色器，它获取精灵、读取纹理并使用该颜色为每个像素着色。 如果在绘制时指定顶点颜色，这些颜色将与纹理混合。",
    "You might be happy with that, but we can have some more fun with this shader. What if we added an offset to the colors based around time to produce movement? To do this, we will need two extra variables for&nbsp;{}speed {}and {}time{}. We will also need two more uniforms, one for each of the new variables, so the Create Event becomes:":"您可能对此感到满意，但我们可以使用此着色器获得更多乐趣。 如果我们根据时间为颜色添加偏移量以产生运动会怎么样？ 为此，我们需要两个额外的变量，分别用于{}速度{}和{}时间{}。 我们还需要两个uniform，每个新变量一个，所以 创建事件 变成：",
    "You\u0027ll also see the use of {}vec{} as a keyword. This is used to identify a vector variable in the shader and you\u0027ll soon see that&nbsp;vectors are very important when working with shaders. That is why they are implemented as a base type in GLSL. If you are unfamiliar with them, they are a mathematical term represented as a matrix with only one column. In programming, we usually represent them as an array where the number of components corresponds to the dimension. Two and three-dimensional vectors are often used for positions, texture coordinates, or colors without an alpha channel, while four-dimensional ones are used for colors with an alpha channel. We can also specify if they hold booleans, integers, or floating point values. The syntax to declare a vector is this:":"您还会看到使用 {}vec{} 作为关键字。 这用于识别着色器中的向量变量，您很快就会发现向量在使用着色器时非常重要。 这就是它们在 GLSL 中作为基本类型实现的原因。 如果您不熟悉它们，它们是一个数学术语，表示为只有一列的矩阵。 在编程中，我们通常将它们表示为一个数组，其中组件的数量对应于维度。 二维和三维向量通常用于没有 alpha 通道的位置、纹理坐标或颜色，而四维向量用于具有 alpha 通道的颜色。 我们还可以指定它们是否包含布尔值、整数或浮点值。 声明向量的语法是这样的：",
    "vec2 firstVec; &nbsp;{}// Two-dimensional vector of floats{}{} vec3 secondVec; {}// Three-dimensional vector of floats{}{} vec4 thirdVec; &nbsp;{}// Four-dimensional vector of floats{}{} {} bvec3 boolVec; &nbsp;{}// Three-dimensional vector of booleans{}{} ivec4 intVec; &nbsp; {}// Four-dimensional vector of integers {}":"vec2 firstVec; &nbsp;{}// 2维浮点向量{}{} vec3 secondVec; {}// 3维浮点向量{}{} vec4 thirdVec; &nbsp;{}// 4维浮点向量{}{} {} bvec3 boolVec; &nbsp;{}// 3维布尔向量{}{} ivec4 intVec; &nbsp; {}// 4维整数向量 {}",
    "{}// Simple 2D vector with 2 scalar values{}{} vec2 firstVec &nbsp;= vec2({}2.0{}, {}1.0{});{} {}// A 4D vector using 2 scalars and a vec2 create the 4 values{}{} vec4 secondVec = vec4({}1.0{}, firstVec, {}0.0{});{} {}// A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values{}{} vec3 thirdVec &nbsp;= vec3(secondVec.{}x{}, firstVec);":"{}// 带有两个标量值的简单2D向量{}{} vec2 firstVec &nbsp;= vec2({}2.0{}, {}1.0{});{} {}// 一个4D向量使用2个标量和一个vec2创建4个值{}{} vec4 secondVec = vec4({}1.0{}, firstVec, {}0.0{});{} {}// 使用vec4的一个分量加上vec2来创建3个值的3D向量{}{} vec3 thirdVec &nbsp;= vec3(secondVec.{}x{}, firstVec);",
    "{}As explained above, {}v_vTexcoord{} gives us the absolute coordinates of the sprite within this entire texture page, but what we want is a value from 0.0 to 1.0 that only covers our current sprite. This process is called {}normalizing{} (getting a value and translating it to a 0 to 1 range). To normalize our horizontal values, we need to know the values of x0 and x1 in the picture above. Luckily, GameMaker has a function that gives us the location of every corner in our sprite within the texture page. First, we need to go to the Create Event and create a uniform to pass this data over to the shader:":"{}如上所述，{}v_vTexcoord{} 为我们提供了精灵在整个纹理页面中的绝对坐标，但我们想要的是一个介于 0.0 到 1.0 之间的值，它只覆盖我们当前的精灵。 此过程称为{}规一化{}（获取一个值并将其转换为 0 到 1 的范围）。 为了规一化我们的水平值，我们需要知道上图中 x0 和 x1 的值。 幸运的是，GameMaker 有一个函数可以为我们提供纹理页面中精灵中每个角的位置。 首先，我们需要转到 创建事件 并创建一个 uniform 以将此数据传递给着色器：",
    "{}As you might have guessed, this does not visually changing anything, as this is a simple pass-through shader. However the sections below outline some simple steps you can take to modify this and change the way the sprite will be drawn. Each of the section shows a different shader that you can create and use in your projects, explaining the steps required to create them and why we are doing things the way we are.":"{}您可能已经猜到了，这不会在视觉上改变任何东西，因为这是一个简单的直通着色器。 然而，以下部分概述了一些简单的步骤，您可以采取这些步骤来修改它并更改绘制精灵的方式。 每个部分都展示了一个不同的着色器，您可以在项目中创建和使用它们，解释创建它们所需的步骤以及我们为什么按照我们的方式做事。",
    "{}Attribute{}: These are variables passed in by OpenGL to the {}vertex {}shader. These can change per vertex and are read-only. These include information such as vertex position, texture coordinates, vertex color, and vertex normal.":"{}Attribute 属性{} : 这些是 OpenGL 传递给{}顶点{}着色器的变量。它们可以改变每个顶点，并且是只读的。这些信息包括顶点位置、纹理坐标、顶点颜色和顶点法线。",
    "{}Black And White Shader{}{}Black And White Shader{}":"{}黑白着色器{}{}黑白着色器{}",
    "{}Colour Overlay Shader{}{}Colour Overlay Shader{}":"{}颜色叠加着色器{}{}颜色叠加着色器{}",
    "{}For the fragment shader, you can imagine the same loop as before, but this time it goes over every single pixel in your sprite, giving you information such as location and color of that pixel. In your fragment shader code, you perform operations and calculations to determine the color of that pixel to get the effect you want. For example, if you want a shader to make your sprite be black and white, then you’d calculate which shade of grey each pixel needs to be to create the effect.":"{}对于片段着色器，你可以想象与之前相同的循环，但这一次它会遍历你的精灵中的每一个像素，为你提供像素的位置和颜色等信息。在片段着色器代码中，您可以执行操作和计算来确定像素的颜色，以获得您想要的效果。例如，如果你想要一个着色器将你的精灵变成黑色和白色，那么你就需要计算每个像素所需要的灰色阴影来创建效果。",
    "{}NOTE{}: In the image above, the rectangle changes size&nbsp;because the base sprite has had the \"empty\" space around it cropped automatically when it was placed on the texture page by GameMaker, so each animation frame the triangles that make it up are different sizes to fit the cropped size of the frame. If you disable this option, then you\u0027d simply have a motionless red square on the screen.":"{}注意{}: 在上图中，矩形的大小发生了变化，因为当基本精灵被GameMaker放在纹理页面上时，它周围的“空”空间被自动裁剪了，所以组成它的每个动画帧的三角形是不同的大小，以适应帧的裁剪大小。如果你禁用了这个选项，那么你只会在屏幕上看到一个静止的红色方块。",
    "{}NOTE{}: {}GameMaker{} allows users to write shaders in {}GLSL{} (OpenGL Shader Language), {}HLSL{} (High-level Shader Language, used when working with DirectX), and {}GLSL ES{} (a subset of GLSL which is common in mobile devices). Here we are&nbsp;using&nbsp;{}GLSL ES{} as the shader language since it’s the one that provides the best compatibility across target platforms. Generally this is the one you always want to use unless you have very specific needs and understand the limitation of the other shader languages. The math and techniques should be similar between all three languages however, save for a few syntax differences here and there.":"{}注意{}:{}GameMaker{}允许用户使用{}GLSL{} (OpenGL Shader语言)、{}HLSL{}(高级Shader语言，在使用DirectX时使用)和{}GLSL ES{} (GLSL的一个子集，在移动设备中很常见)编写着色器。这里我们使用&nbsp;{}GLSL ES{}作为着色器语言，因为它是一个跨目标平台提供最佳兼容性的语言。一般来说，除非你有非常特殊的需求，并且了解其他着色器语言的局限性，否则这是你总是想要使用的。这三种语言之间的数学和技术应该是相似的，除了一些语法差异。",
    "{}Not exactly what we expected!&nbsp;What we need to remember is that every sprite is ultimately a rectangle, so unless we consider transparency - which we haven\u0027t -&nbsp;this is the result we’ll get.":"{}我们需要记住的是，每个精灵最终都是一个矩形，所以除非我们考虑透明度 -我们还没有考虑 -这是我们将得到的结果。",
    "{}Now that’s what we were after! We have replaced the color of every pixel with red, but have kept the alpha channel intact.":"{}这才是我们想要的！我们已经用红色替换了每个像素的颜色，但是仍然保持了 alpha 通道的完整性。",
    "{}Now the shader is much more useful and reusable. It’s up to you to add more functionality if you need it to set the color (using the variable {}_color{}) during runtime.":"{}现在，着色器变得更加有用和可重用。 如果您需要在运行时设置颜色（使用变量 {}_color{}），您可以添加更多功能。",
    "{}Rainbow Shader{}{}Rainbow Shader{}":"{}彩虹着色器{}{}彩虹着色器{}",
    "{}The reason shader code is usually executed by the GPU is that it is more efficient at it. Modern CPUs typically have between two to eight cores. Each core can perform one task at a time, so by taking advantage of multiple cores, we can perform that many tasks simultaneously. In contrast, modern GPUs can perform thousands, and even tens of thousands, of tasks running at the same time. This is helpful for shaders because we can execute the shader code of thousands of pixels concurrently. The limitation is that we only have access to the initial state of the sprite, so we don’t know about any modifications done to other pixels since we can’t know for sure the code has run on them yet.":"{}着色器代码通常由GPU执行的原因是它在这方面效率更高。现代的cpu通常有2到8个核。每个核心一次可以执行一个任务，所以通过利用多个核心，我们可以同时执行这么多任务。相比之下，现代gpu可以同时执行数千甚至数万个任务。这对着色器很有帮助，因为我们可以同时执行数千像素的着色器代码。限制在于我们只能访问精灵的初始状态，所以我们不知道对其他像素所做的任何修改，因为我们不能确定代码是否在它们上运行。",
    "{}There we go! This is exactly what we wanted. We can see every color of&nbsp;the spectrum inside our sprite.":"{}我们开始了！ 这正是我们想要的。 我们可以在精灵中看到光谱的每种颜色。",
    "{}This looks great already, right? Well, yes and no...&nbsp;there is a solution that is more “correct”, since instead of adding the components and dividing by three, we multiply each component by the standard NTSC values for black and white. Here’s the modified fragment shader code:":"{}这看起来已经很棒了，对吧?有一个更“正确”的解决方案，因为我们不是将组件相加并除以3，而是将每个组件乘以黑白的标准NTSC值。下面是修改后的片段着色器代码:",
    "{}To finish this shader, we will add a few more uniforms to customize it even further. The first two are to control the saturation and brightness. The next one we\u0027ll&nbsp;call&nbsp;\"section\" and its function is to allow the user to pass a number between zero and one to determine what percentage of the entire spectrum we see at a time. Last, we&nbsp;will add a variable called \"mix\", which will specify how much we want to mix our shader color with the original texture color (1.0 is all rainbow, 0.0 is all texture). As always, let’s start by adding the variables to the Create Event:":"{}为了完成这个着色器，我们将添加更多的uniform来进一步定制它。前两个是控制饱和度和亮度。下一个我们称之为section，它的功能是允许用户传递一个0到1之间的数字，以确定我们一次看到的整个光谱的百分比。最后，我们将添加一个名为“mix”的变量，它将指定我们想将着色器颜色与原始纹理颜色混合的程度(1.0是全部彩虹颜色，0.0是全部纹理颜色)。和往常一样，让我们从添加变量到创建事件开始:",
    "{}Uniform{}: These are variables that change per object and are passed by the user to the shader. These can be used in both the vertex and fragment shaders, but are read-only.":"{}Uniform 统一{}: 这些变量会根据对象而变化，并由用户传递给着色器。 这些可以在顶点和片段着色器中使用，但是是只读的。",
    "{}Varying{}: These are variables used to pass data between the {}vertex {}and {}fragment {}shaders. These are available for writing in the vertex shader, but are read-only in the fragment shader.":"{}Varying 变量{} : 这些变量用于在{}顶点{}和{}片段{}着色器之间传递数据。它们可以在顶点着色器中写入，但是在片段着色器中是只读的。",
    "{}We are close to what we want, but there’s an issue: we are not seeing all the colors at once in every frame of the animation, and the colors seem to change randomly. The reason is that we assumed that {}v_vTexcoord{} gave us the coordinates of the sprite, starting at the top-left corner (0,0) and ending in the bottom right corner (1,1), which is standard in shaders. However, for optimization, GameMaker stuffs as many textures together as it can fit in what is called a {}texture page,{}&nbsp;and because of that, this is how our texture actually looks:":"{}我们已经接近我们想要的效果，但存在一个问题：我们没有在动画的每一帧中同时看到所有颜色，而且颜色似乎随机变化。 原因是我们假设 {}v_vTexcoord{} 为我们提供了精灵的坐标，从左上角 (0,0) 开始到右下角 (1,1) 结束，这在着色器中是标准的 . 然而，为了优化，GameMaker 将尽可能多的纹理填充在一起，以适应所谓的{}纹理页面{}&nbsp;正因为如此，这就是我们纹理的实际外观："
}