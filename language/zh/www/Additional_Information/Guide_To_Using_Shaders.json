{
    "Above we mentioned the {}texture2D{} function, and we\u0027ll&nbsp;use that&nbsp;to grab the color at the pixel we are working on and get the transparency from it. The return value of is&nbsp;{}texture2D{}&nbsp;is&nbsp;a {}vec4{}, where the components are the red, green, blue, and alpha, in that order. We can access the alpha channel either by putting a period followed by an {}a{} or a {}w{} after the variable name. This corresponds to RGBA and XYZW, respectively.":"上面我们提到了 {}texture2D{} 函数，我们将使用它来获取正在处理的像素处的颜色并从中获取透明度。 {}texture2D{} 的返回值是一个 {}vec4{}，其中组件按顺序为红色、绿色、蓝色和 Alpha。 我们可以通过在变量名称后添加一个句点并后跟 {}a{} 或 {}w{} 来访问 Alpha 通道。 这分别对应于 RGBA 和 XYZW。",
    "All we need to do is call {}{}shader_get_uniform(){}{}&nbsp;to get a pointer to the uniform. The parameters we need to pass are the shader asset name (without quotation because we want to pass the ID that GameMaker generates for us) and the name of the uniform variable inside of the shader, this time as a string. This name&nbsp;needs to match exactly the one inside the shader code for it to work. We have&nbsp;also added a colour variable so we can change it at runtime and have it remember our changes.":"我们需要做的就是调用 {}{}shader_get_uniform(){}{} 来获取指向 uniform 的指针。 我们需要传递的参数是着色器资源名称（不带引号，因为我们要传递 GameMaker 为我们生成的 ID）和着色器内部的统一变量的名称（这次是字符串）。 该名称需要与着色器代码中的名称完全匹配才能正常工作。 我们还添加了一个颜色变量，以便我们可以在运行时更改它并让它记住我们的更改。",
    "And our final result is this!":"我们的最终结果是这样的！",
    "And we modify the draw event to get the values and then pass them to the shader:":"我们修改绘制事件以获取值，然后将它们传递给着色器：",
    "As explained before, the idea behind a fragment shader is to return the color of the current pixel. This is done by assigning the variable {}gl_FragColor{} the final color value. The {}texture2D{} function takes a texture and a {}vec2{} with the UV coordinates you want to check in that texture, which returns a {}vec4{} with the color. In the pass through shader, all we are doing is grabbing the color of the texture in the coordinate of this pixel and multiplying it by the color of the vertex associated with this pixel.":"如前所述，片段着色器背后的想法是返回当前像素的颜色。这通过将最终颜色值分配给变量{}gl_FragColor{}来完成。{}texture 2D{}函数接受一个纹理和一个{}vec 2{}，其中包含要在该纹理中检查的UV坐标，该函数返回一个{}vec4{}颜色。在穿透着色器中，我们所做的就是获取该像素坐标中的纹理颜色，并将其乘以与该像素关联的顶点的颜色。",
    "As for our draw code, it is trivial at the moment:":"至于我们的draw代码，目前它是微不足道的：",
    "As for the draw event, it’s quite simple since we don’t have a uniform to pass in:":"至于绘制事件，非常简单，因为我们没有要传入的uniform ：",
    "As for the shader, we need to pass the saturation and brightness to the color, which will affect the color generated by our helper function. The section needs to be multiplied by our position to reduce the range. We will also grab&nbsp;the entire texture color, so we&nbsp;can calculate our final color by mixing the texture color with the RGB conversion of our color. The last parameter of the mix function determines how much of the second color we want to add. This is our final shader code:":"至于着色器，我们需要将饱和度和亮度传递给颜色，这将影响我们的辅助函数生成的颜色。 该部分需要乘以我们的位置以缩小范围。 我们还将获取整个纹理颜色，因此我们可以通过将纹理颜色与颜色的 RGB 转换混合来计算最终颜色。 mix 函数的最后一个参数决定了我们要添加多少第二种颜色。 这是我们最终的着色器代码：",
    "As you can see, we can use any combination of up to four letters to create a vector of that length. We cannot attempt to access a component that would be out of bounds (for example, trying to access w in {}secondVec{} or {}thirdVec{}, since they don’t have a fourth component). Also, we can repeat letters and use them in any order, as long as the vector variable it’s being assigned to is the same size as the number of letters used.":"正如你所看到的，我们可以使用最多四个字母的任何组合来创建一个长度相同的向量。我们不能尝试访问超出边界的组件(例如，尝试访问{}secondVec{}或{}thirdVec{}中的w，因为它们没有第四个组件)。此外，我们可以重复字母并以任何顺序使用它们，只要它被分配给的向量变量与所使用的字母数量相同。",
    "Creating A Shader":"创建着色器",
    "Each shader is made up of two separate components: a {}vertex shader {}and a {}fragment shader {}(also referred to as {}pixel shader{}). Let’s start with the vertex shader. Each sprite is formed by a rectangle, but computers like to draw triangles, so those rectangles are split into two triangles (sometimes called a {}quad{}). This leaves us with six vertices (corners)&nbsp;per sprite, but two of those are the same one, so we should only worry about four. Now, imagine we have a for loop that goes over every vertex and executes the code inside the vertex shader for each. This allows us to change the vertex position and color before passing it over to the fragment shader since the vertex shader is executed earlier.":"每个着色器由两个单独的组件组成：{}顶点着色器{}和{}片段着色器{}(也称为{}像素着色器{})。让我们从顶点着色器开始。每个精灵都由一个矩形组成，但计算机喜欢绘制三角形，因此这些矩形被分成两个三角形(有时称为{}quad{})。这使得我们每个精灵有六个顶点(角)，但其中两个是相同的，所以我们只需要担心四个。现在，假设我们有一个for循环，它遍历每个顶点，并为每个顶点执行顶点着色器中的代码。这允许我们在传递给片段着色器之前改变顶点的位置和颜色，因为顶点着色器是在前面执行的。",
    "Every draw call we make between {}{}shader_set(){}{}&nbsp;and {}{}shader_reset(){}{}&nbsp;will have the shader applied to it. Here, we are drawing the object sprite with our passthrough shader:":"我们在{}{}shader_set(){}{}和{}{}shader_reset(){}{}之间进行的每个绘制调用都将应用着色器。在这里，我们使用我们的穿透着色器绘制对象精灵：",
    "Finally we pass the vertex color and texture coordinate to the fragment shader through our varying variables.":"最后，我们通过我们的可变变量将顶点颜色和纹理坐标传递给片段着色器。",
    "Finally, we\u0027ll go back to our shader to actually use these variables now. What we will do is multiply the speed with the time and add it to the position, like so:":"最后，我们将回到我们的着色器，现在实际使用这些变量。我们要做的是将速度乘以时间，然后将其添加到位置，如下所示：",
    "First, we create a {}vec4{} and initialize it with the components of the position, adding one as the fourth component. In linear algebra, the convention is that we add a one to the fourth component if the vector is representing a point, or a zero if it represents an actual vector.":"首先，我们创建一个{}vec 4{}，并用位置的分量初始化它，添加一个作为第四个分量。在线性代数中，惯例是，如果向量表示一个点，我们就在第四个分量上加一个1，如果它表示一个实际的向量，我们就在第四个分量上加一个0。",
    "For obvious reasons, when using swizzle to set component values, you can’t use the same component twice. For example, the below is not valid as you are trying to set the same component to two different values:":"由于显而易见的原因，在使用swizzle设置组件值时，不能两次使用同一个组件。例如，下面的无效，因为您试图将同一组件设置为两个不同的值：",
    "Having to change the shader each time we want to use a different color isn’t a good idea, especially since we’d need to have a separate shader for each color we want. Instead, we will pass the color information to the shader using a {}uniform{}. To do this, we first need to get a {}pointer {}to the uniform. We will do this in the {}Create Event{} of our object that has the sprite by adding:":"每次我们想要使用不同的颜色时都必须更改着色器并不是一个好主意，特别是因为我们需要为我们想要的每种颜色都有一个单独的着色器。 相反，我们将使用 {}uniform{} 将颜色信息传递给着色器。 为此，我们首先需要获取指向制服的{}指针{}。 我们将在具有精灵的对象的 {}创建事件{} 中执行此操作，方法是添加：",
    "Here we add the uniform variable at the top of the file with the same name we used in the Create Event. Next, we calculate the normalized horizontal position by translating our current {}x{} coordinate to the origin ( {}v_vTexcoord.x - u_uv[0]{}) and then we divide&nbsp;it by the width of the sprite to make the range from 0 to 1 ({}u_uv[1] - u_uv[0]{}).":"这里我们在文件的顶部添加了一个uniform变量，其名称与我们在创建事件中使用的名称相同。接下来，我们通过将当前的{}x{}坐标转换到原点({}v_vTexcoord.x - u_uv[0]{})来计算归一化的水平位置，然后将其除以精灵的宽度，得到从0到1的范围({}u_uv[1] - u_uv[0]{})。",
    "Here’s how that would look:":"这看起来是这样的：",
    "Here’s the updated code:":"下面是更新后的代码：",
    "Here’s what the shader looks like at this stage:":"以下是着色器在此阶段的外观：",
    "However, there is another way to access the components with the following syntax:":"但是，还有另一种使用以下语法访问组件的方法：",
    "If you did everything correctly, you should be seeing something like this:":"如果你做的一切都是正确的，你应该会看到这样的东西：",
    "If you have created a shader in {}GameMaker{}, you might have noticed the following keywords in the default {}pass-through{} shader. These keywords help the shader understand the purpose and scope of each variable:":"如果您在{}GameMaker{}中创建了着色器，您可能已经注意到默认{}直通{}着色器中的以下关键字。这些关键字有助于着色器了解每个变量的用途和范围：",
    "In the end, it looks very similar, but it’s technically more correct.":"最后，它看起来非常相似，但在技术上更正确。",
    "It would look something like this:":"它看起来像这样：",
    "It’s the same code as before, but before we draw anything, we need to pass all the uniform&nbsp;values to the shader. In this case, we are passing the color as an array of floats. As for the shader, we will change it to include the uniform and use it, so it becomes:":"这段代码和前面的代码一样，但是在我们绘制任何东西之前，我们需要将所有的uniform值传递给shader。在这个例子中，我们将颜色作为一个浮点数组传递。至于shader，我们将改变它以包含uniform并使用它，所以它变成：",
    "Last, we have been using {}xyzw{} as our swizzle mask, which is usually the case when dealing with positions. There are two more sets of masks you can use: {}rgba{} (used for colors), or {}stpq{} (used for texture coordinates). Internally, there is no difference between these masks, and we only use them to make the code clearer as to what the vector represents in that instance. Also, we can’t combine swizzle masks in the same operation, so this is invalid:":"最后，我们一直使用{}xyzw{}作为我们的混合掩码，这通常是处理头寸时的情况。还有两组面具可以用途：{}rgba{}(用于颜色)或{}stpq{}(用于纹理坐标)。在内部，这些掩码之间没有区别，我们只是使用它们来使代码更清楚地了解向量在该实例中表示的内容。此外，我们不能在同一个操作中联合收割机swizzle掩码，因此这是无效的：",
    "Let’s check out what we got:":"让我们看看我们得到了什么：",
    "Let’s compile and see what we got.":"让我们编译一下，看看我们得到了什么。",
    "Let’s go through the code for a newly created shader asset and analyze it, starting with the vertex shader.":"让我们从顶点着色器开始，浏览新创建的着色器资源的代码并对其进行分析。",
    "Let’s go to the draw event now to send these uniforms to the shader:":"现在让我们转到绘制事件，将这些 uniforms 发送到着色器：",
    "Let’s take a quick look at the fragment shader now:":"现在让我们快速查看片段着色器：",
    "Making a black and white shader is a great way to learn more about how shaders work, and a lot of beginners start by trying to do this, since conceptually it\u0027s quite simple: get every pixel and assign it a shade of gray. But is it simple? Not quite...":"制作一个黑白着色器是了解着色器工作原理的好方法，很多初学者都是从尝试这样做开始的，因为从概念上讲，它非常简单：获取每个像素并为其分配灰色阴影。但它简单吗？不太简单。",
    "Next, we need to add this fourth component to multiply it with the {}MATRIX_WORLD_VIEW_PROJECTION{} matrix, which is a 4x4 matrix. This multiplication will project the world position of the vertex into screen coordinates.":"接下来，我们需要添加第四个分量，将其乘以{}MATRIX_WORLD_VIEW_PROJECTION{}矩阵，这是一个4x 4矩阵。这个乘法将顶点的世界位置投影到屏幕坐标中。",
    "Now that we have our first shader, all we have to do to test it is create an object and assign it a sprite, then in the {}Draw Event{}&nbsp;of the object you set the shader like this:":"现在我们有了第一个着色器，我们要做的就是创建一个对象并为其分配一个精灵，然后在对象的{}Draw Event{}中设置着色器如下：",
    "Now the code in our draw event will change slightly to pass the uniform variable.":"现在，我们的draw事件中的代码将稍微改变以传递uniform变量。",
    "One thing you might have noticed is that in the {}gl_FragColor{} code, we\u0027re&nbsp;multiplying the&nbsp;{}vec4{} with something called {}v_vColour{}. This is a variable passed by the vertex shader which tells us the color of the vertex associated with this pixel. It’s always a good idea to multiply your final calculated color with the vertex color. In most cases, it won’t do anything, but if you changed the vertex color in GML, this will reflect that (by using functions such as {}{}draw_sprite_ext(){}{}&nbsp;or {}{}draw_sprite_general(){}{}&nbsp;to change the {}{}image_blend{}{}).":"您可能已经注意到的一件事是，在 {}gl_FragColor{} 代码中，我们将 {}vec4{} 与名为 {}v_vColour{} 的值相乘。 这是顶点着色器传递的变量，它告诉我们与该像素关联的顶点的颜色。 将最终计算的颜色与顶点颜色相乘总是一个好主意。 在大多数情况下，它不会执行任何操作，但如果您更改了 GML 中的顶点颜色，这将反映出来（通过使用 {}{}draw_sprite_ext(){}{} 或 {}{}draw_sprite_general(){}{}  等函数） 更改 {}{}image_blend{}{}）。",
    "Our draw event changes to include these uniforms like this:":"我们的绘制事件发生了变化，包括这些 uniforms ，如下所示：",
    "Our final shader example&nbsp;is a fun one and can be used to add life to text and buttons and other things.&nbsp;We\u0027ll start simple and add functionality gradually since this shader is highly customizable. There\u0027s quite a lot to cover for this one, so if you feel a bit lost or confused, please go back and re-read some of the sections above.":"我们最后一个着色器示例是一个有趣的示例，可以用来为文本、按钮和其他东西添加生命力。我们将从简单的开始，逐渐添加功能，因为这个着色器是高度可定制的。这个着色器有很多内容要讲，所以如果你觉得有点困惑或困惑，请回去重新阅读上面的一些部分。",
    "Outside of the main function, we see some variable declarations and their qualifiers. The attributes are given to us by GameMaker. The varying ones are created by the user to pass that information over to the fragment shader. Inside the main function, we have the calculations to find the screen position of the vertex:":"在main函数之外，我们看到一些变量声明和它们的限定符。这些属性是由GameMaker提供给我们的。变化的着色器由用户创建以将该信息传递到片段着色器。在main函数中，我们有计算来找到顶点的屏幕位置：",
    "Shader Variables":"着色器变量",
    "Shaders are often used to create beautiful graphical effects in games. They are also among the most advanced features offered by {}GameMaker{}, so it is necessary that you have a basic understanding of programming and how {}GameMaker{} works before getting started with them.":"着色器通常用于在游戏中创建漂亮的图形效果。它们也是{}GameMaker{}提供的最高级功能之一，因此在开始使用它们之前，您必须对编程以及{}GameMaker{}的工作原理有基本的了解。",
    "So, what is a shader?&nbsp;Initially they were created to provide shading for lighting (hence the name), but they are now used to produce a huge variety of effects. Shader code is similar to regular code, but it is (almost always) executed by the GPU, not the CPU. This difference comes with its own set of rules and limitations, but we’ll cover those later.":"那么，什么是着色器？最初，它们被创建为照明提供阴影(因此得名)，但现在它们被用来产生各种各样的效果。着色器代码类似于常规代码，但它(几乎总是)由GPU执行，而不是CPU。这种差异有它自己的一套规则和限制，但我们将在后面介绍。",
    "That\u0027s the end of this short guide and you should now have a better understanding of how shaders work and some of the uses they can be put to. You should take your time to play with the shaders you\u0027ve created following this guide, and try to experiment with them do other things - how about creating a blur shader, or a shader that makes a gameboy-style monochrome screen? - since shaders are an incredibly powerful tool for adding visual complexity and style to your games.":"这是这篇简短的指南的结尾，现在你应该对着色器的工作原理和它们的一些用途有了更好的理解。你应该花时间来玩你按照这篇指南创建的着色器，并尝试用它们做其他事情-创建一个模糊着色器，或者一个着色器，使gameboy风格的单色屏幕怎么样？- 因为着色器是一个非常强大的工具，可以为游戏添加视觉复杂性和风格。",
    "The first thing we want to do is color pixels with every hue, depending on the pixel’s horizontal position. The way to do this is to set the x position to be the hue and then convert from HSV (hue, saturation, brightness) format to RGB (red, green, and blue) format. For this, we will need to write a helper function in our fragment shader that takes HSV values and returns an RGB vector. We&nbsp;will use a single function which does this without the need for any {}if{}&nbsp;statements, as using conditionals in shader code makes shaders {}very {}slow, and should be avoided.":"我们要做的第一件事是根据像素的水平位置，用每种色调给像素上色，方法是将x位置设为色调，然后从HSV转换(色调、饱和度、亮度)格式转换为RGB(红、绿色和蓝)格式。为此，我们需要在片段着色器中编写一个辅助函数，它接受HSV值并返回RGB向量。我们将使用一个函数来完成此操作，而不需要任何{}if{}语句，因为在着色器代码中使用条件会使着色器{}非常{}慢，应该避免。",
    "The function {}{}sprite_get_uvs(){}{}&nbsp;takes a sprite and an index, and it returns an array with tons of information, such as the coordinates for each corner, how many pixels were cropped to optimize it, etc. We are interested in two of those values: the left and right coordinates of the sprite, which are stored&nbsp;in {}uv[0]{} and {}uv[2]{} respectively. In the fragment shader, we will use those values now to calculate the normalized horizontal position like this:":"函数 {}{}sprite_get_uvs(){}{} 接受一个精灵和一个索引，它返回一个包含大量信息的数组，例如每个角的坐标、裁剪了多少像素来优化等等。我们 对其中两个值感兴趣：精灵的左坐标和右坐标，它们分别存储在 {}uv[0]{} 和 {}uv[2]{} 中。 在片段着色器中，我们现在将使用这些值来计算标准化水平位置，如下所示：",
    "The result is:":"其结果是：",
    "The vertex shader is executed first, and as we explained above, it deals with {}vertices{}. It is used to calculate positions, normals, and texture coordinates. These shaders are not particularly useful in 2D, since every sprite is usually a square, but it can be used to do some skewing, scaling, etc... It becomes much more useful in 3D for lighting calculations and mesh deformations. Fragment shaders are much more interesting and are what will be covered mostly here, since the fragment shader is where we get information about our textures and can tweak the final color of each pixel in our image.":"顶点着色器首先执行，正如我们上面解释的，它处理{}顶点{}。它用于计算位置、法线和纹理坐标。这些着色器在2D中不是特别有用，因为每个精灵通常都是正方形，但它可以用来做一些倾斜，缩放等。它在3D中对于照明计算和网格变形变得更加有用。片段着色器更有趣，也是这里主要讨论的内容，因为片段着色器是我们获取纹理信息的地方，可以调整图像中每个像素的最终颜色。",
    "There\u0027s a bit more going on here than in the previous examples, but most of it should be fairly obvious to you now. First, there’s our {}hsv2rgb{} function, which takes a {}vec3{} with our HSV colour and returns another {}vec3{} with our RGB conversion. In the main function, we start by creating our HSV colour, where the hue is our x position, and we’ll leave the saturation and brightness as 1.0 for now. Then, we get the alpha from the texture so it only colors our sprite character and not the entire sprite rectangle (as we did in the colour overlay example, above). Lastly, we set our Fragment color to be our HSV color converted to RGB with the alpha, multiplied by the vertex color (good practice to do this always).":"这里比前面的例子多了一点，但大部分对你来说应该是相当明显的。首先，有我们的{}hsv2rgb{}函数，它使用HSV颜色获取{}vec3{}，并使用RGB转换返回另一个{}vec3{}。在main函数中，我们首先创建HSV颜色，其中色调是x位置，我们现在将饱和度和亮度设为1.0。然后，我们从纹理中获取alpha，这样它只会给精灵角色着色，而不是整个精灵矩形(正如我们在上面的颜色叠加示例中所做的那样)。最后，我们将片段颜色设置为使用alpha转换为RGB的HSV颜色，乘以顶点颜色(最好始终这样做)。",
    "This shader should be left alone if you are not planning to play with vertex positions and it will not be used in any of the examples given below&nbsp;because all the effects shown will be created using the fragment shader.":"如果您不打算使用顶点位置，则应单独使用此着色器，并且它不会在下面给出的任何示例中使用，因为显示的所有效果都将使用片段着色器创建。",
    "This uses the component names inside the vector to access them. You can use x, y, z, or w, to get the first, second, third, or fourth components, respectively. We refer to this method as {}swizzling {}because the following syntax is also valid:":"这将使用向量中的组件名称来访问它们。可以使用x、y、z或w分别获取第一、第二、第三或第四个分量。我们将此方法称为{}swizzling{}，因为以下语法也是有效的：",
    "This will give us the following result:":"这将给我们给予以下结果：",
    "Those were a lot of definitions and information, but knowing these things is necessary to understand shaders themselves.":"这些是很多定义和信息，但了解这些东西对于理解着色器本身是必要的。",
    "To initialize them, we can use the constructor to create the vector. You need to provide the same number of values as the length of the vector, but you can mix and match scalars and smaller vectors to reach the target length. Here are some examples of this:":"要初始化它们，我们可以使用构造函数来创建向量。您需要提供与向量长度相同数量的值，但您可以混合和匹配标量和较小的向量以达到目标长度。以下是一些例子：",
    "We also need to increase the time every frame, so in the Step Event we add:":"我们还需要增加每帧的时间，因此在步事件中添加：",
    "We are now assigning a new {}vec4{} to {}gl_FragColor{}, where the red channel is maxed, the green, and blue channels are zero, and the alpha channel is the same as the original texture. The output looks like this:":"我们现在为 gl_FragColor 分配一个新的 vec4，其中红色通道已最大化，绿色和蓝色通道为零，并且 Alpha 通道与原始纹理相同。 输出如下所示：",
    "We can also assign them another vector of the same length (or {}swizzle {}the vector until it has the proper length, but we\u0027ll explain that in a moment):":"我们也可以给它们分配另一个相同长度的向量(或者{}swizzle{}向量，直到它有合适的长度，但我们稍后会解释)：",
    "We can edit the base shader now to do something different. We\u0027ll not be touching the vertex shader part, and only editing the fragment shader, and to start with we\u0027ll do a very simple operation, which is to make the shader draw the sprite using the colour red. We\u0027ll do this by simply changing the {}gl_FragColor{} to be red., like this:":"我们现在可以编辑基础着色器来做一些不同的事情。我们不会触及顶点着色器部分，而只是编辑片段着色器，首先我们将做一个非常简单的操作，即让着色器使用红色绘制精灵。我们将通过简单地将{}gl_FragColor{}更改为红色来实现这一点。像这样：",
    "We declare a variable with the same name as in the create shader ({}u_colour{}) and we pass it as the first three components of the {}gl_FragColor{} vector, taking advantage of swizzling. If we compile again, we should see this:":"我们声明一个与创建着色器 ({}u_colour{}) 中同名的变量，并利用调配功能将其作为 {}gl_FragColor{} 向量的前三个分量进行传递。 如果我们再次编译，我们应该看到：",
    "We use the dot product as a shorthand for multiplying each component of {}texColor{} with the correct weights and then add them together. If you are unfamiliar with the dot product, this is essentially what’s happening:":"我们使用点积作为简写，将{}texColor{}的每个分量乘以正确的权重，然后将它们加在一起。如果您不熟悉点积，则基本上是这样的：",
    "We would like to thank&nbsp;{}Alejandro Hitti{}&nbsp;and {}Amazon{} for permitting us to reproduce this guide. You can find the original version on the&nbsp;{}Amazon Developer Blog{}.":"我们要感谢{}Alejandro Hitti{}和{}Amazon{}允许我们复制本指南。您可以在{}Amazon Developer Blog{}上找到原始版本。",
    "When accessing vector components in GLSL, we have a few options. The most basic one is to treat the vector as an array and access the components using square brackets, like this:":"在GLSL中访问矢量分量时，我们有几个选项。最基本的方法是将向量视为数组，并使用方括号访问组件，如下所示：",
    "When using RGB colour, if all three components are the same value, then we get a gray tone. The naïve approach to creating a shader to use this idea would be to add all three color channels (red, green, and blue) and then divide it by three. After that you\u0027d&nbsp;assigned the value to all three channels, thus creating a gray tone. Here’s what that fragment shader looks like:":"当使用RGB颜色时，如果所有三个分量都是相同的值，那么我们就会得到一个灰色色调。使用这种想法创建着色器的简单方法是将所有三个颜色通道(红色，绿色和蓝色)相加，然后将其除以3。之后，您将值分配给所有三个通道，从而创建一个灰色色调。下面是片段着色器的外观：",
    "When you create a shader in {}GameMaker{}, it will open two files for you: a vertex shader ({}.vsh{}) and a fragment shader ({}.fsh{}). This is the most basic shader you can make, which takes a sprite, reads the texture, and colors each pixel with that color. If you specify vertex colors when drawing, those colors will blend with the texture.":"在{}GameMaker{}中创建着色器时，它将为您打开两个文件：顶点着色器({}.vsh{})和片段着色器({}.fsh{})。这是您可以制作的最基本的着色器，它获取精灵，读取纹理，并使用该颜色为每个像素着色。如果在绘制时指定顶点颜色，则这些颜色将与纹理混合。",
    "You might be happy with that, but we can have some more fun with this shader. What if we added an offset to the colors based around time to produce movement? To do this, we will need two extra variables for&nbsp;{}speed {}and {}time{}. We will also need two more uniforms, one for each of the new variables, so the Create Event becomes:":"你可能会很高兴，但我们可以用这个着色器来玩得更开心。如果我们根据时间为颜色添加偏移量来产生移动会怎么样？要做到这一点，我们需要两个额外的变量，分别用于{}速度{}和{}时间{}。我们还需要两个制服，每个新变量一个，所以创建事件变成：",
    "You\u0027ll also see the use of {}vec{} as a keyword. This is used to identify a vector variable in the shader and you\u0027ll soon see that&nbsp;vectors are very important when working with shaders. That is why they are implemented as a base type in GLSL. If you are unfamiliar with them, they are a mathematical term represented as a matrix with only one column. In programming, we usually represent them as an array where the number of components corresponds to the dimension. Two and three-dimensional vectors are often used for positions, texture coordinates, or colors without an alpha channel, while four-dimensional ones are used for colors with an alpha channel. We can also specify if they hold booleans, integers, or floating point values. The syntax to declare a vector is this:":"您还将看到使用{}vec{}作为关键字。这是用来标识着色器中的向量变量，你很快就会看到，向量是非常重要的，当使用着色器。这就是为什么它们在GLSL中被实现为基类型的原因。如果您不熟悉它们，它们是一个数学术语，表示为只有一列的矩阵。在编程中，我们通常将它们表示为一个数组，其中组件的数量与维度相对应。二维和三维向量通常用于位置、纹理坐标或没有Alpha通道的颜色，而四维向量用于具有Alpha通道的颜色。我们还可以指定它们是否保存布尔值、整数值或浮点值。声明vector的语法如下：",
    "]Ű\uFFFD\uFFFD\\]\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDV\uFFFD\u0017\uFFFDS\u0014\uFFFD\u0005\uFFFDN*Ku\u0014\uFFFD\uFFFD\u0015ۻ\u000E\u0002\u0005#A5w\uFFFD":"\\\uFFFD",
    "{}As explained above, {}v_vTexcoord{} gives us the absolute coordinates of the sprite within this entire texture page, but what we want is a value from 0.0 to 1.0 that only covers our current sprite. This process is called {}normalizing{} (getting a value and translating it to a 0 to 1 range). To normalize our horizontal values, we need to know the values of x0 and x1 in the picture above. Luckily, GameMaker has a function that gives us the location of every corner in our sprite within the texture page. First, we need to go to the Create Event and create a uniform to pass this data over to the shader:":"{}如上所述，{}v_vTexcoord{} 为我们提供了精灵在整个纹理页面内的绝对坐标，但我们想要的是一个仅覆盖当前精灵的 0.0 到 1.0 之间的值。 此过程称为{}标准化{}（获取值并将其转换为 0 到 1 的范围）。 为了标准化我们的水平值，我们需要知道上图中 x0 和 x1 的值。 幸运的是，GameMaker 有一个函数可以为我们提供纹理页面中精灵中每个角的位置。 首先，我们需要转到创建事件并创建一个制服以将此数据传递给着色器：",
    "{}As you might have guessed, this does not visually changing anything, as this is a simple pass-through shader. However the sections below outline some simple steps you can take to modify this and change the way the sprite will be drawn. Each of the section shows a different shader that you can create and use in your projects, explaining the steps required to create them and why we are doing things the way we are.":"{}当然你可能已经猜到了，这并不会在视觉上改变任何东西，因为这是一个简单的传递着色器。然而，下面的部分概述了一些简单的步骤，你可以采取修改这一点，并改变精灵的方式将绘制。每个部分都显示了一个不同的着色器，您可以在项目中创建和使用，解释了创建它们所需的步骤以及我们为什么要这样做。",
    "{}Attribute{}: These are variables passed in by OpenGL to the {}vertex {}shader. These can change per vertex and are read-only. These include information such as vertex position, texture coordinates, vertex color, and vertex normal.":"{}Attribute{}：这些是OpenGL传递给{}顶点{}着色器的变量。这些可以按顶点更改，并且是只读的。这些包括诸如顶点位置、纹理坐标、顶点颜色和顶点法线之类的信息。",
    "{}Black And White Shader{}{}Black And White Shader{}":"{}黑白着色器{}{}黑白着色器{}",
    "{}Colour Overlay Shader{}{}Colour Overlay Shader{}":"{}颜色叠加着色器{}{}颜色叠加着色器{}",
    "{}For the fragment shader, you can imagine the same loop as before, but this time it goes over every single pixel in your sprite, giving you information such as location and color of that pixel. In your fragment shader code, you perform operations and calculations to determine the color of that pixel to get the effect you want. For example, if you want a shader to make your sprite be black and white, then you’d calculate which shade of grey each pixel needs to be to create the effect.":"{}在片段着色器中，你可以想象和以前一样的循环，但这次它会遍历你的子画面中的每一个像素，给你诸如像素的位置和颜色等信息。在片段着色器代码中，可以执行操作和计算来确定该像素的颜色，以获得所需的效果。例如，如果您希望着色器使您的精灵是黑色和白色，那么您需要计算每个像素需要的灰色阴影来创建效果。",
    "{}Not exactly what we expected!&nbsp;What we need to remember is that every sprite is ultimately a rectangle, so unless we consider transparency - which we haven\u0027t -&nbsp;this is the result we’ll get.":"{}不完全符合我们的预期！ 我们需要记住的是，每个精灵最终都是一个矩形，因此除非我们考虑透明度（我们没有考虑），否则这就是我们将得到的结果。",
    "{}Now that’s what we were after! We have replaced the color of every pixel with red, but have kept the alpha channel intact.":"{}这就是我们所追求的！ 我们将每个像素的颜色替换为红色，但保持 Alpha 通道完好无损。",
    "{}Now the shader is much more useful and reusable. It’s up to you to add more functionality if you need it to set the color (using the variable {}_color{}) during runtime.":"{}现在，着色器更加有用且可重用。 如果您需要在运行时设置颜色（使用变量 {}_color{}），您可以添加更多功能。",
    "{}Rainbow Shader{}{}Rainbow Shader{}":"{}彩虹着色器{}{}彩虹着色器{}",
    "{}The reason shader code is usually executed by the GPU is that it is more efficient at it. Modern CPUs typically have between two to eight cores. Each core can perform one task at a time, so by taking advantage of multiple cores, we can perform that many tasks simultaneously. In contrast, modern GPUs can perform thousands, and even tens of thousands, of tasks running at the same time. This is helpful for shaders because we can execute the shader code of thousands of pixels concurrently. The limitation is that we only have access to the initial state of the sprite, so we don’t know about any modifications done to other pixels since we can’t know for sure the code has run on them yet.":"{}着色器代码通常由GPU执行的原因是它在这方面更有效。现代CPU通常具有两到八个内核。每个内核一次可以执行一个任务，因此通过利用多个内核，我们可以同时执行多个任务。相比之下，现代GPU可以同时执行数千甚至数万个任务。这对着色器很有帮助，因为我们可以同时执行数千个像素的着色器代码。限制是我们只能访问sprite的初始状态，因此我们不知道对其他像素的任何修改，因为我们不能确定代码是否已经在它们上运行。",
    "{}There we go! This is exactly what we wanted. We can see every color of&nbsp;the spectrum inside our sprite.":"{}好了！这正是我们想要的。我们可以看到精灵内部光谱的每一种颜色。",
    "{}This looks great already, right? Well, yes and no...&nbsp;there is a solution that is more “correct”, since instead of adding the components and dividing by three, we multiply each component by the standard NTSC values for black and white. Here’s the modified fragment shader code:":"{}这看起来已经很棒了，对吧？嗯，是也不是..",
    "{}To finish this shader, we will add a few more uniforms to customize it even further. The first two are to control the saturation and brightness. The next one we\u0027ll&nbsp;call&nbsp;\"section\" and its function is to allow the user to pass a number between zero and one to determine what percentage of the entire spectrum we see at a time. Last, we&nbsp;will add a variable called \"mix\", which will specify how much we want to mix our shader color with the original texture color (1.0 is all rainbow, 0.0 is all texture). As always, let’s start by adding the variables to the Create Event:":"{}为了完成此着色器，我们将添加更多uniforms以进一步自定义它。 前两个是控制饱和度和亮度。 下一个我们将称为“部分”，它的功能是允许用户传递 0 到 1 之间的数字来确定我们一次看到的整个光谱的百分比。 最后，我们将添加一个名为“mix”的变量，它将指定我们想要将着色器颜色与原始纹理颜色混合的程度（1.0 是所有彩虹，0.0 是所有纹理）。 与往常一样，我们首先将变量添加到创建事件中：",
    "{}Uniform{}: These are variables that change per object and are passed by the user to the shader. These can be used in both the vertex and fragment shaders, but are read-only.":"{}Uniform{}：这些变量随对象而变化，并由用户传递给着色器。这些着色器可以在顶点着色器和片段着色器中使用，但它们是只读的。",
    "{}Varying{}: These are variables used to pass data between the {}vertex {}and {}fragment {}shaders. These are available for writing in the vertex shader, but are read-only in the fragment shader.":"{}Varying{}：这些变量用于在{}顶点{}和{}片段{}着色器之间传递数据。这些可用于在顶点着色器中写入，但在片段着色器中是只读的。",
    "{}We are close to what we want, but there’s an issue: we are not seeing all the colors at once in every frame of the animation, and the colors seem to change randomly. The reason is that we assumed that {}v_vTexcoord{} gave us the coordinates of the sprite, starting at the top-left corner (0,0) and ending in the bottom right corner (1,1), which is standard in shaders. However, for optimization, GameMaker stuffs as many textures together as it can fit in what is called a {}texture page,{}&nbsp;and because of that, this is how our texture actually looks:":"{}我们已经接近我们想要的结果，但有一个问题：我们并没有在动画的每一帧中同时看到所有颜色，而且颜色似乎是随机变化的。 原因是我们假设 {}v_vTexcoord{} 为我们提供了精灵的坐标，从左上角 (0,0) 开始，到右下角 (1,1) 结束，这是着色器中的标准坐标 。 不过，为了优化，GameMaker 将尽可能多的纹理填充到所谓的{}纹理页面{}中，因此，这就是我们的纹理的实际外观：",
    "{}{}NOTE{}{}&nbsp;In the image above, the rectangle changes size&nbsp;because the base sprite has had the \"empty\" space around it cropped automatically when it was placed on the texture page by GameMaker, so each animation frame the triangles that make it up are different sizes to fit the cropped size of the frame. If you disable this option, then you\u0027d simply have a motionless red square on the screen.":"{}{}注意{}{}在上图中，矩形的大小发生了变化，因为当 GameMaker 将其放置在纹理页面上时，基础精灵已自动裁剪了其周围的“空白”空间，因此每个动画都将三角形框起来 组成它的尺寸不同，以适应框架的裁剪尺寸。 如果禁用此选项，那么屏幕上只会出现一个静止的红色方块。",
    "{}{}NOTE{}{}&nbsp;{}GameMaker{} allows users to write shaders in {}GLSL{} (OpenGL Shader Language), {}HLSL{} (High-level Shader Language, used when working with DirectX), and {}GLSL ES{} (a subset of GLSL which is common in mobile devices). Here we are&nbsp;using&nbsp;{}GLSL ES{} as the shader language since it’s the one that provides the best compatibility across target platforms. Generally this is the one you always want to use unless you have very specific needs and understand the limitation of the other shader languages. The math and techniques should be similar between all three languages however, save for a few syntax differences here and there.":"{}{}注意{}{} {}GameMaker{}允许用户使用{}GLSL{}(OpenGL着色器语言)、{}HLSL{}(高级着色器语言，在使用DirectX时使用)和{}GLSL ES{}(移动的设备中常见的GLSL子集)编写着色器。这里我们使用{}GLSL ES{}作为着色器语言，因为它是跨目标平台提供最佳兼容性的语言。一般来说，这是一个你总是想使用，除非你有非常具体的需求，并了解其他着色器语言的限制。然而，保存这里和那里的一些语法差异之外，所有三种语言之间的数学和技术应该是相似的。",
    "\uFFFD\u001Ax\uFFFDO%T\uFFFD\u001ETi\uFFFD+N\u0014.\u001C\uFFFD\uFFFD\uFFFD\u001F\u0016\u001C\uFFFD\u0012\uFFFDː\uFFFD\uFFFD\uFFFD\uFFFD\u0001\u001B\uFFFD\u0013\uFFFDcRհ\uFFFD\uFFFD\u000F\uFFFD\uFFFD%\uFFFD\uFFFD\uFFFD\uFFFD\u0002C$\uFFFDX\uFFFD\uFFFD-\u0000\uFFFD\uFFFD\uFFFD\uFFFD&\\\uFFFD":"\u0010iи\uFFFDs\\\uFFFD\uFFFD5ӕ#\uFFFD\u0014\u001AViw\uFFFD\u0027\uFFFD\uFFFD\uFFFD4\u0007H\uFFFDnk\uFFFDz\uFFFD8\uFFFD\u000F\uFFFDI\u0007p\uFFFD\u0006\uFFFDz\uFFFD{#"
}