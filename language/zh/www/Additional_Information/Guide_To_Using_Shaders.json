{
    "As explained before, the idea behind a fragment shader is to return the color of the current pixel. This is done by assigning the variable {}gl_FragColor{} the final color value. The {}texture2D{} function takes a texture and a {}vec2{} with the UV coordinates you want to check in that texture, which returns a {}vec4{} with the color. In the pass through shader, all we are doing is grabbing the color of the texture in the coordinate of this pixel and multiplying it by the color of the vertex associated with this pixel.":"如前所述，片段着色器背后的想法是返回当前像素的颜色。这通过将最终颜色值分配给变量{}gl_FragColor{}来完成。{}texture 2D{}函数接受一个纹理和一个{}vec 2{}，其中包含要在该纹理中检查的UV坐标，该函数返回一个{}vec4{}颜色。在穿透着色器中，我们所做的就是获取该像素坐标中的纹理颜色，并将其乘以与该像素关联的顶点的颜色。",
    "As you can see, we can use any combination of up to four letters to create a vector of that length. We cannot attempt to access a component that would be out of bounds (for example, trying to access w in {}secondVec{} or {}thirdVec{}, since they don’t have a fourth component). Also, we can repeat letters and use them in any order, as long as the vector variable it’s being assigned to is the same size as the number of letters used.":"正如你所看到的，我们可以使用最多四个字母的任何组合来创建一个长度相同的向量。我们不能尝试访问超出边界的组件(例如，尝试访问{}secondVec{}或{}thirdVec{}中的w，因为它们没有第四个组件)。此外，我们可以重复字母并以任何顺序使用它们，只要它被分配给的向量变量与所使用的字母数量相同。",
    "Creating A Shader":"创建着色器",
    "Each shader is made up of two separate components: a {}vertex shader {}and a {}fragment shader {}(also referred to as {}pixel shader{}). Let’s start with the vertex shader. Each sprite is formed by a rectangle, but computers like to draw triangles, so those rectangles are split into two triangles (sometimes called a {}quad{}). This leaves us with six vertices (corners)&nbsp;per sprite, but two of those are the same one, so we should only worry about four. Now, imagine we have a for loop that goes over every vertex and executes the code inside the vertex shader for each. This allows us to change the vertex position and color before passing it over to the fragment shader since the vertex shader is executed earlier.":"每个着色器由两个单独的组件组成：{}顶点着色器{}和{}片段着色器{}(也称为{}像素着色器{})。让我们从顶点着色器开始。每个精灵都由一个矩形组成，但计算机喜欢绘制三角形，因此这些矩形被分成两个三角形(有时称为{}quad{})。这使得我们每个精灵有六个顶点(角)，但其中两个是相同的，所以我们只需要担心四个。现在，假设我们有一个for循环，它遍历每个顶点，并为每个顶点执行顶点着色器中的代码。这允许我们在传递给片段着色器之前改变顶点的位置和颜色，因为顶点着色器是在前面执行的。",
    "Every draw call we make between {}{}shader_set(){}{}&nbsp;and {}{}shader_reset(){}{}&nbsp;will have the shader applied to it. Here, we are drawing the object sprite with our passthrough shader:":"我们在{}{}shader_set(){}{}和{}{}shader_reset(){}{}之间进行的每个绘制调用都将应用着色器。在这里，我们使用我们的穿透着色器绘制对象精灵：",
    "Finally we pass the vertex color and texture coordinate to the fragment shader through our varying variables.":"最后，我们通过我们的可变变量将顶点颜色和纹理坐标传递给片段着色器。",
    "First, we create a {}vec4{} and initialize it with the components of the position, adding one as the fourth component. In linear algebra, the convention is that we add a one to the fourth component if the vector is representing a point, or a zero if it represents an actual vector.":"首先，我们创建一个{}vec 4{}，并用位置的分量初始化它，添加一个作为第四个分量。在线性代数中，惯例是，如果向量表示一个点，我们就在第四个分量上加一个1，如果它表示一个实际的向量，我们就在第四个分量上加一个0。",
    "For obvious reasons, when using swizzle to set component values, you can’t use the same component twice. For example, the below is not valid as you are trying to set the same component to two different values:":"由于显而易见的原因，在使用swizzle设置组件值时，不能两次使用同一个组件。例如，下面的无效，因为您试图将同一组件设置为两个不同的值：",
    "Here’s how that would look:":"这看起来是这样的：",
    "However, there is another way to access the components with the following syntax:":"但是，还有另一种使用以下语法访问组件的方法：",
    "If you have created a shader in {}GameMaker{}, you might have noticed the following keywords in the default {}pass-through{} shader. These keywords help the shader understand the purpose and scope of each variable:":"如果您在{}GameMaker{}中创建了着色器，您可能已经注意到默认{}直通{}着色器中的以下关键字。这些关键字有助于着色器了解每个变量的用途和范围：",
    "It would look something like this:":"它看起来像这样：",
    "Last, we have been using {}xyzw{} as our swizzle mask, which is usually the case when dealing with positions. There are two more sets of masks you can use: {}rgba{} (used for colors), or {}stpq{} (used for texture coordinates). Internally, there is no difference between these masks, and we only use them to make the code clearer as to what the vector represents in that instance. Also, we can’t combine swizzle masks in the same operation, so this is invalid:":"最后，我们一直使用{}xyzw{}作为我们的混合掩码，这通常是处理头寸时的情况。还有两组面具可以用途：{}rgba{}(用于颜色)或{}stpq{}(用于纹理坐标)。在内部，这些掩码之间没有区别，我们只是使用它们来使代码更清楚地了解向量在该实例中表示的内容。此外，我们不能在同一个操作中联合收割机swizzle掩码，因此这是无效的：",
    "Let’s go through the code for a newly created shader asset and analyze it, starting with the vertex shader.":"让我们从顶点着色器开始，浏览新创建的着色器资源的代码并对其进行分析。",
    "Let’s take a quick look at the fragment shader now:":"现在让我们快速查看片段着色器：",
    "Next, we need to add this fourth component to multiply it with the {}MATRIX_WORLD_VIEW_PROJECTION{} matrix, which is a 4x4 matrix. This multiplication will project the world position of the vertex into screen coordinates.":"接下来，我们需要添加第四个分量，将其乘以{}MATRIX_WORLD_VIEW_PROJECTION{}矩阵，这是一个4x 4矩阵。这个乘法将顶点的世界位置投影到屏幕坐标中。",
    "Now that we have our first shader, all we have to do to test it is create an object and assign it a sprite, then in the {}Draw Event{}&nbsp;of the object you set the shader like this:":"现在我们有了第一个着色器，我们要做的就是创建一个对象并为其分配一个精灵，然后在对象的{}Draw Event{}中设置着色器如下：",
    "Outside of the main function, we see some variable declarations and their qualifiers. The attributes are given to us by GameMaker. The varying ones are created by the user to pass that information over to the fragment shader. Inside the main function, we have the calculations to find the screen position of the vertex:":"在main函数之外，我们看到一些变量声明和它们的限定符。这些属性是由GameMaker提供给我们的。变化的着色器由用户创建以将该信息传递到片段着色器。在main函数中，我们有计算来找到顶点的屏幕位置：",
    "Shader Variables":"着色器变量",
    "Shaders are often used to create beautiful graphical effects in games. They are also among the most advanced features offered by {}GameMaker{}, so it is necessary that you have a basic understanding of programming and how {}GameMaker{} works before getting started with them.":"着色器通常用于在游戏中创建漂亮的图形效果。它们也是{}GameMaker{}提供的最高级功能之一，因此在开始使用它们之前，您必须对编程以及{}GameMaker{}的工作原理有基本的了解。",
    "So, what is a shader?&nbsp;Initially they were created to provide shading for lighting (hence the name), but they are now used to produce a huge variety of effects. Shader code is similar to regular code, but it is (almost always) executed by the GPU, not the CPU. This difference comes with its own set of rules and limitations, but we’ll cover those later.":"那么，什么是着色器？最初，它们被创建为照明提供阴影(因此得名)，但现在它们被用来产生各种各样的效果。着色器代码类似于常规代码，但它(几乎总是)由GPU执行，而不是CPU。这种差异有它自己的一套规则和限制，但我们将在后面介绍。",
    "The vertex shader is executed first, and as we explained above, it deals with {}vertices{}. It is used to calculate positions, normals, and texture coordinates. These shaders are not particularly useful in 2D, since every sprite is usually a square, but it can be used to do some skewing, scaling, etc... It becomes much more useful in 3D for lighting calculations and mesh deformations. Fragment shaders are much more interesting and are what will be covered mostly here, since the fragment shader is where we get information about our textures and can tweak the final color of each pixel in our image.":"顶点着色器首先执行，正如我们上面解释的，它处理{}顶点{}。它用于计算位置、法线和纹理坐标。这些着色器在2D中不是特别有用，因为每个精灵通常都是正方形，但它可以用来做一些倾斜，缩放等。它在3D中对于照明计算和网格变形变得更加有用。片段着色器更有趣，也是这里主要讨论的内容，因为片段着色器是我们获取纹理信息的地方，可以调整图像中每个像素的最终颜色。",
    "This shader should be left alone if you are not planning to play with vertex positions and it will not be used in any of the examples given below&nbsp;because all the effects shown will be created using the fragment shader.":"如果您不打算使用顶点位置，则应单独使用此着色器，并且它不会在下面给出的任何示例中使用，因为显示的所有效果都将使用片段着色器创建。",
    "This uses the component names inside the vector to access them. You can use x, y, z, or w, to get the first, second, third, or fourth components, respectively. We refer to this method as {}swizzling {}because the following syntax is also valid:":"这将使用向量中的组件名称来访问它们。可以使用x、y、z或w分别获取第一、第二、第三或第四个分量。我们将此方法称为{}swizzling{}，因为以下语法也是有效的：",
    "Those were a lot of definitions and information, but knowing these things is necessary to understand shaders themselves.":"这些是很多定义和信息，但了解这些东西对于理解着色器本身是必要的。",
    "To initialize them, we can use the constructor to create the vector. You need to provide the same number of values as the length of the vector, but you can mix and match scalars and smaller vectors to reach the target length. Here are some examples of this:":"要初始化它们，我们可以使用构造函数来创建向量。您需要提供与向量长度相同数量的值，但您可以混合和匹配标量和较小的向量以达到目标长度。以下是一些例子：",
    "We can also assign them another vector of the same length (or {}swizzle {}the vector until it has the proper length, but we\u0027ll explain that in a moment):":"我们也可以给它们分配另一个相同长度的向量(或者{}swizzle{}向量，直到它有合适的长度，但我们稍后会解释)：",
    "When accessing vector components in GLSL, we have a few options. The most basic one is to treat the vector as an array and access the components using square brackets, like this:":"在GLSL中访问矢量分量时，我们有几个选项。最基本的方法是将向量视为数组，并使用方括号访问组件，如下所示：",
    "When you create a shader in {}GameMaker{}, it will open two files for you: a vertex shader ({}.vsh{}) and a fragment shader ({}.fsh{}). This is the most basic shader you can make, which takes a sprite, reads the texture, and colors each pixel with that color. If you specify vertex colors when drawing, those colors will blend with the texture.":"在{}GameMaker{}中创建着色器时，它将为您打开两个文件：顶点着色器({}.vsh{})和片段着色器({}.fsh{})。这是您可以制作的最基本的着色器，它获取精灵，读取纹理，并使用该颜色为每个像素着色。如果在绘制时指定顶点颜色，则这些颜色将与纹理混合。",
    "You\u0027ll also see the use of {}vec{} as a keyword. This is used to identify a vector variable in the shader and you\u0027ll soon see that&nbsp;vectors are very important when working with shaders. That is why they are implemented as a base type in GLSL. If you are unfamiliar with them, they are a mathematical term represented as a matrix with only one column. In programming, we usually represent them as an array where the number of components corresponds to the dimension. Two and three-dimensional vectors are often used for positions, texture coordinates, or colors without an alpha channel, while four-dimensional ones are used for colors with an alpha channel. We can also specify if they hold booleans, integers, or floating point values. The syntax to declare a vector is this:":"您还将看到使用{}vec{}作为关键字。这是用来标识着色器中的向量变量，你很快就会看到，向量是非常重要的，当使用着色器。这就是为什么它们在GLSL中被实现为基类型的原因。如果您不熟悉它们，它们是一个数学术语，表示为只有一列的矩阵。在编程中，我们通常将它们表示为一个数组，其中组件的数量与维度相对应。二维和三维向量通常用于位置、纹理坐标或没有Alpha通道的颜色，而四维向量用于具有Alpha通道的颜色。我们还可以指定它们是否保存布尔值、整数值或浮点值。声明vector的语法如下：",
    "]Ű\uFFFD\uFFFD\\]\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDV\uFFFD\u0017\uFFFDS\u0014\uFFFD\u0005\uFFFDN*Ku\u0014\uFFFD\uFFFD\u0015ۻ\u000E\u0002\u0005#A5w\uFFFD":"\\\uFFFD",
    "{}As you might have guessed, this does not visually changing anything, as this is a simple pass-through shader. However the sections below outline some simple steps you can take to modify this and change the way the sprite will be drawn. Each of the section shows a different shader that you can create and use in your projects, explaining the steps required to create them and why we are doing things the way we are.":"{}当然你可能已经猜到了，这并不会在视觉上改变任何东西，因为这是一个简单的传递着色器。然而，下面的部分概述了一些简单的步骤，你可以采取修改这一点，并改变精灵的方式将绘制。每个部分都显示了一个不同的着色器，您可以在项目中创建和使用，解释了创建它们所需的步骤以及我们为什么要这样做。",
    "{}Attribute{}: These are variables passed in by OpenGL to the {}vertex {}shader. These can change per vertex and are read-only. These include information such as vertex position, texture coordinates, vertex color, and vertex normal.":"{}Attribute{}：这些是OpenGL传递给{}顶点{}着色器的变量。这些可以按顶点更改，并且是只读的。这些包括诸如顶点位置、纹理坐标、顶点颜色和顶点法线之类的信息。",
    "{}For the fragment shader, you can imagine the same loop as before, but this time it goes over every single pixel in your sprite, giving you information such as location and color of that pixel. In your fragment shader code, you perform operations and calculations to determine the color of that pixel to get the effect you want. For example, if you want a shader to make your sprite be black and white, then you’d calculate which shade of grey each pixel needs to be to create the effect.":"{}在片段着色器中，你可以想象和以前一样的循环，但这次它会遍历你的子画面中的每一个像素，给你诸如像素的位置和颜色等信息。在片段着色器代码中，可以执行操作和计算来确定该像素的颜色，以获得所需的效果。例如，如果您希望着色器使您的精灵是黑色和白色，那么您需要计算每个像素需要的灰色阴影来创建效果。",
    "{}The reason shader code is usually executed by the GPU is that it is more efficient at it. Modern CPUs typically have between two to eight cores. Each core can perform one task at a time, so by taking advantage of multiple cores, we can perform that many tasks simultaneously. In contrast, modern GPUs can perform thousands, and even tens of thousands, of tasks running at the same time. This is helpful for shaders because we can execute the shader code of thousands of pixels concurrently. The limitation is that we only have access to the initial state of the sprite, so we don’t know about any modifications done to other pixels since we can’t know for sure the code has run on them yet.":"{}着色器代码通常由GPU执行的原因是它在这方面更有效。现代CPU通常具有两到八个内核。每个内核一次可以执行一个任务，因此通过利用多个内核，我们可以同时执行多个任务。相比之下，现代GPU可以同时执行数千甚至数万个任务。这对着色器很有帮助，因为我们可以同时执行数千个像素的着色器代码。限制是我们只能访问sprite的初始状态，因此我们不知道对其他像素的任何修改，因为我们不能确定代码是否已经在它们上运行。",
    "{}Uniform{}: These are variables that change per object and are passed by the user to the shader. These can be used in both the vertex and fragment shaders, but are read-only.":"{}Uniform{}：这些变量随对象而变化，并由用户传递给着色器。这些着色器可以在顶点着色器和片段着色器中使用，但它们是只读的。",
    "{}Varying{}: These are variables used to pass data between the {}vertex {}and {}fragment {}shaders. These are available for writing in the vertex shader, but are read-only in the fragment shader.":"{}Varying{}：这些变量用于在{}顶点{}和{}片段{}着色器之间传递数据。这些可用于在顶点着色器中写入，但在片段着色器中是只读的。",
    "{}{}NOTE{}{}&nbsp;{}GameMaker{} allows users to write shaders in {}GLSL{} (OpenGL Shader Language), {}HLSL{} (High-level Shader Language, used when working with DirectX), and {}GLSL ES{} (a subset of GLSL which is common in mobile devices). Here we are&nbsp;using&nbsp;{}GLSL ES{} as the shader language since it’s the one that provides the best compatibility across target platforms. Generally this is the one you always want to use unless you have very specific needs and understand the limitation of the other shader languages. The math and techniques should be similar between all three languages however, save for a few syntax differences here and there.":"{}{}注意{}{} {}GameMaker{}允许用户使用{}GLSL{}(OpenGL着色器语言)、{}HLSL{}(高级着色器语言，在使用DirectX时使用)和{}GLSL ES{}(移动的设备中常见的GLSL子集)编写着色器。这里我们使用{}GLSL ES{}作为着色器语言，因为它是跨目标平台提供最佳兼容性的语言。一般来说，这是一个你总是想使用，除非你有非常具体的需求，并了解其他着色器语言的限制。然而，保存这里和那里的一些语法差异之外，所有三种语言之间的数学和技术应该是相似的。",
    "\uFFFD\u001Ax\uFFFDO%T\uFFFD\u001ETi\uFFFD+N\u0014.\u001C\uFFFD\uFFFD\uFFFD\u001F\u0016\u001C\uFFFD\u0012\uFFFDː\uFFFD\uFFFD\uFFFD\uFFFD\u0001\u001B\uFFFD\u0013\uFFFDcRհ\uFFFD\uFFFD\u000F\uFFFD\uFFFD%\uFFFD\uFFFD\uFFFD\uFFFD\u0002C$\uFFFDX\uFFFD\uFFFD-\u0000\uFFFD\uFFFD\uFFFD\uFFFD&\\\uFFFD":"\u0010iи\uFFFDs\\\uFFFD\uFFFD5ӕ#\uFFFD\u0014\u001AViw\uFFFD\u0027\uFFFD\uFFFD\uFFFD4\u0007H\uFFFDnk\uFFFDz\uFFFD8\uFFFD\u000F\uFFFDI\u0007p\uFFFD\u0006\uFFFDz\uFFFD{#"
}