{
    "\n        {}\n        And the distribution curves (linear, gaussian, and inverse gaussian) are illustrated here:":"{}\n分布曲线(线性、高斯和逆高斯)如下所示：",
    "And for those of you that use GML Visual:":"对于那些使用GML Visual的人：",
    "And using GML Visual:":"或使用GML Visual：",
    "As mentioned at the start, once created, a particle system (and its particles, emitters etc...) are stored in memory for instant use. Great, but what happens when you restart the game? Or if your player dies and starts the room again? Well, if you don\u0027t manage the game right you get a {}memory leak{}. This is when something has been created and uses up memory, but has been \"de-referenced\" meaning that GameMaker no longer has access to it. This kind of thing will slowly eat up memory and cause lag in your game or even block the computer causing your game to crash, and it is a pretty common problem with first time users of particle systems.":"如开头所述，一旦创建，粒子系统(及其粒子、发射器等…)将存储在内存中以供即时使用。太好了，但是当你重新开始游戏时会发生什么？或者如果你的玩家死了，重新开始房间？如果你没有正确地管理游戏，你会得到一个{}内存泄漏{}。这是指某个东西已经创建并耗尽了内存，但已经被\"取消引用\"，这意味着GameMaker不再有权访问它。这种事情会慢慢消耗内存并导致游戏延迟，甚至阻塞计算机导致游戏崩溃，这是首次使用粒子系统的用户非常常见的问题。",
    "Before going any further, we should probably explain what a particle actually is... Basically, a particle is a graphic resource that has certain properties which are defined by a {}particle system{}. These properties cannot be manipulated directly for {}individual {}particles, but are changed collectively through the code or actions that are used to define the system that it belongs to. They are very useful for creating beautiful and flashy effects - or subtle and discreet ones -&nbsp;in a game without the CPU overhead that using instances has.":"在继续之前，我们可能应该解释一下粒子实际上是什么…基本上，粒子是具有由{}粒子系统{}定义的某些属性的图形资源。这些属性不能直接针对{}单个{}粒子进行操作，而是通过用于定义其所属系统的代码或操作集体更改。它们对于在没有使用实例的CPU开销的游戏中创建美丽而华丽的效果非常有用——或者微妙而谨慎的效果。",
    "Before setting up a system and creating particles, it\u0027s important to know a few things... First is that most of a particle systems code is {}only ever called once in the game{}, usually in some type of controller object in the first room or level - this is not always the case, but for the sake of simplicity, we\u0027ll be using this scenario for the following brief guide as it\u0027s the most common way to use particles. You do this because a particle system, once created, stays in memory and is ready to be used at any time, so if you create it more than once it can quickly increase the memory usage and cause serious lag, and even has the potential of crashing the game. For the sake of simplicity in this guide, you&nbsp;will make a {}global {}particle system that can be used by any instance in the game at any time.":"在建立一个系统和创造粒子之前，重要的是要知道一些事情…首先，大多数粒子系统代码{}在游戏中只被调用一次{}，通常是在第一个房间或关卡中的某种类型的控制器对象中——情况并非总是如此，但为了简单起见，我们将在以下简短指南中使用此场景，因为这是使用粒子的最常见方式。你这样做是因为粒子系统一旦创建，就会留在内存中，随时可以使用，所以如果你多次创建它，它会迅速增加内存使用量并导致严重的滞后，甚至有可能导致游戏崩溃。为了简单起见，在本指南中，您将制作一个{}全局{}粒子系统，可以被游戏中的任何实例随时使用。",
    "Below is an example of the code/actions required to define two emitters, which would normally go in the {}Create Event{} of a controller object, just after defining the particle system. One will be static and stream particles over the area of the whole room, while the other will be dynamic and follow the mouse and burst every 30 steps from a small ellipse:":"下面是定义两个发射器所需的代码/操作示例，通常会在定义粒子系统之后进入控制器对象的{}创建事件{}。一个是静态的，在整个房间的区域内流动粒子，而另一个是动态的，跟随鼠标，每隔30步从一个小椭圆爆发一次：",
    "But what if you want several objects to emit particles? A global emitter can only be in one place at a time, so you would need to create {}local {}emitters in each object. These emitters will still use the global particle system and any particles that are within it, but they can be different shapes and sizes and move with the object, making them ideal for rockets or bullets or things. The code you would use is exactly the same as above, but without the \"global\" prefix before the emitter names.":"但是如果你想让几个物体发出粒子呢？全局发射器一次只能在一个地方，因此您需要在每个对象中创建{}本地{}发射器。这些发射器仍将使用全球粒子系统和其中的任何粒子，但它们可以是不同的形状和大小，并随着物体移动，使它们成为火箭、子弹或其他东西的理想选择。您将使用的代码与上述完全相同，但在发射器名称前没有\"全局\"前缀。",
    "Guide To Using Particles":"使用粒子指南",
    "How do you avoid this? Well, {}GameMaker{} has GML Code functions and GML Visual actions to delete particle systems and their emitters and particles from memory when not in use, and with a little bit of planning when using the following code/actions, you can easily prevent this potential problem.":"你如何避免这种情况？好吧，{}GameMaker{}具有GML Code函数和GML Visual操作，可以在不使用时从内存中删除粒子系统及其发射器和粒子，并且在使用以下代码/操作时稍加规划，您可以轻松防止此潜在问题。",
    "Let\u0027s look at some code that defines a particle now:":"现在让我们来看一些定义粒子的代码：",
    "Now we have code/GML Visual to stream particles (these particles will be emitted every game step without us having to anything else), but we also want to add an {}A{}{}larm[0]{}&nbsp;{}Event{} to burst particles at specific intervals:":"现在我们有了 code/ GML Visual 来流动创建粒子(这些粒子将在每个游戏步骤中发射，我们无需执行任何其他操作)，但我们也想添加{}A{}{}larm[0]{} {}Event{}以特定间隔爆发粒子：",
    "Now you know the basics about particles, particle systems and emitters, so you can now add them into your game! But before rushing off and adding particle effects to everything, please note that while particles are less CPU hungry than instances, they are not the solution to everything as they will cause lag if you have thousands of them at a time. The best thing to do is experiment and use them carefully to \"flesh out\" visually a game and give it a bit more eye-candy without over doing it.":"现在你知道了粒子、粒子系统和发射器的基础知识，所以你现在可以把它们添加到你的游戏中了！但是在匆忙离开并为所有内容添加粒子效果之前，请注意，虽然粒子比实例更不需要CPU，但它们并不是所有内容的解决方案，因为如果您一次拥有数千个粒子，它们会导致延迟。最好的办法是实验并仔细使用它们来\"充实\"游戏的视觉效果，并在不过度的情况下给它更多的视觉效果。",
    "Now, before we present you the code for defining the particle, let\u0027s just talk about \"{}wiggle{}\" for a moment... Believe it or not, \"wiggle\" is a particle property and can be set for many of the above settings individually. When you see \"wiggle\" as an argument for a particle function or action, it means that if you place a number between 1 and 20 the particle will \"wiggle\" or fluctuate between the min and max values for the property, with 1 being a slow wiggle and 20 being very fast. So a particle speed minimum of 2 and maximum of 5 with a wiggle of 20 will oscillate very quickly between the min/max speeds for the lifetime of each particle created.":"现在，在我们向你介绍定义粒子的代码之前，让我们先谈一谈 \"{}wiggle{}\"...信不信由你，\"wiggle\" 是一个粒子属性，可以单独为上述许多设置进行设置。当你将 \"摆动\" 作为粒子函数或动作的参数时，这意味着如果你放置一个介于 1 到 20 之间的数字，则粒子将在该属性的最小值和最大值之间 \"摆动\" 或波动，其中 1 表示慢速摆动，20 表示非常快。因此，在创建的每个粒子的生命周期内，粒子速度最小为 2，最大为 5，摆动为 20，将在最小/最大速度之间快速振荡。",
    "Since we\u0027ve explained the easy way to create particles, let\u0027s now go the slightly more complex way, which is to use {}emitters{}. Emitters are another part of the particle system that has to be defined before being used, so we\u0027ll make a global emitter the same as we did for the system and the particles. We also have to decide whether to have a static (non-moving) emitter or not and whether we are going to {}burst {}or {}stream {}the particles, as well as decide over what area and what kind of distribution we are going to have the emitter use.":"既然我们已经解释了创建粒子的简单方法，现在让我们采用稍微复杂一点的方法，那就是使用{}发射器{}。发射器是粒子系统的另一个部分，在使用之前必须定义，所以我们将制作一个全球发射器，就像我们对系统和粒子所做的一样。我们还必须决定是否有静态(非移动)发射器，我们是要{}爆发{}还是{}流式{}粒子，以及决定我们将使用发射器的区域和类型的分布。",
    "So that\u0027s the system created, but what about the particles? We have to define them too or the system is useless and does nothing.":"这就是我们创建的系统，但是粒子呢？我们也必须定义它们，否则系统毫无用处，什么也做不了。",
    "That\u0027s the creation of particles dealt with but there is one more thing that\u0027s very important... Cleaning up when you are finished with them.":"这是粒子的创造，但还有一件事非常重要…当你用完它们后清理干净。",
    "The first thing you have to do is decide where you are going to create the system and how you will use it. You could create a global system in the {}Game Start Event{} of an object that is in your first room (like a menu or title screen), but this means that if you restart the game using the {}{}game_restart(){}{} function, it will be recreated and cause a memory leak. Or you could create a local system in an instance in any room, but again, if you leave the room then the system will be inaccessible and cause a memory leak. To avoid this you would need to have something like this in the {}{}Game End Event{}{} or the {}{}Clean Up Event{}{} of your object:":"你要做的第一件事是决定在哪里创建系统以及如何使用它。您可以在第一个房间(如菜单或标题屏幕)中的对象的{}游戏开始事件{}中创建一个全局系统，但这意味着如果您使用{}{}game_restart(){}{}函数重新启动游戏，它将被重新创建并导致内存泄漏。或者您可以在任何房间的实例中创建本地系统，但同样，如果您离开房间，系统将无法访问并导致内存泄漏。为了避免这种情况，您需要在对象的{}{}游戏结束事件{}{}或{}{}清理事件{}{}中设置类似的内容：",
    "The following images illustrate the different types of area shape available for emitters:":"以下图像说明了可用于发射器的不同类型的区域形状：",
    "There are a couple of ways to create particles, and each has its pros and cons. You can use {}emitters{} to {}burst {}or {}stream {}particles, or you can create particles {}directly {}at a point. Which one you use really depends on what you are trying to achieve and the effect you are wanting to create, but we\u0027ll start with the easiest of the two, which is creating particles directly. In GML we\u0027d use the following function:":"有几种方法可以创建粒子，每种方法都有其优点和缺点。你可以使用{}发射器{}来{}爆发{}或{}流式{}粒子，也可以{}直接{}在某个点创建粒子。你使用哪一个实际上取决于你想要实现的目标以及你想要创建的效果，但我们将从两个中最简单的方法开始，那就是直接创建粒子。在 GML 中，我们将使用以下函数：",
    "This guide is for those of you that want to understand how to use and create {}particles{}. This page will cover both the {}GameMaker Language functions{}&nbsp;and {}GML Visual actions{}&nbsp;for particles, so if you\u0027ve never used particles before, we hope that this guide can get you started as they are very useful and quite fun to make.":"本指南适用于那些想了解如何使用和创建{}粒子{}的人。本页将涵盖{}GameMaker语言函数{}和{}GML粒子的视觉动作{}，所以如果你以前从未使用过粒子，我们希望本指南能让你开始，因为它们非常有用，制作起来也很有趣。",
    "To create this same particle definition in GML Visual we\u0027d need these actions:":"要在 GML Visual 中创建相同的粒子定义，我们需要以下操作：",
    "To start with you need to define the particle system and give it a name so that you can use it. As this is going to be a global system that any object can use you would do this&nbsp;in a controller object or an initialisation function run at the start of the game. The GML would look like this:":"首先，您需要定义粒子系统并为其命名，以便您可以使用它。由于这将是一个任何对象都可以使用的全局系统，因此您可以在控制器对象或游戏开始时运行的初始化函数中执行此操作。GML看起来像这样：",
    "To use a particle in a system you have to first define its general properties. These are like object properties, but they only apply in a {}general {}way to individual particles. What this means is that if you give the particles a minimum movement speed of 1 and a maximum movement speed of 2, any particle created by the system will have a random speed between 1 and 2 pixels per step, and that overall they will have an average speed of 1.5. You should name and add your first particle to the system using the following GML in the same object that you used to create the system:":"要在系统中使用粒子，您必须首先定义其一般属性。这些类似于对象属性，但它们仅以{}一般{}方式应用于单个粒子。这意味着，如果你给粒子最小移动速度为1，最大移动速度为2，系统创建的任何粒子每步将有1到2个像素之间的随机速度，总的来说，它们的平均速度为1.5。您应该在用于创建系统的同一对象中使用以下GML命名并将您的第一个粒子添加到系统中：",
    "We have mentioned particle systems, so let\u0027s explain what that is before continuing. Think of a particle system like a container that you will use to hold your particles ready for use. You can use code or actions to define the visual aspect of the particles, and then they are placed in the \"container\" (the particle system) so that you can take it out and use it whenever and wherever you need it later.":"我们已经提到了粒子系统，所以让我们在继续之前解释一下它是什么。把粒子系统想象成一个容器，你将用它来容纳你的粒子，准备好使用。你可以使用代码或动作来定义粒子的视觉方面，然后将它们放置在\"容器\"(粒子系统)中，这样你就可以将它拿出来，并在以后无论何时何地需要它时使用它。",
    "What does all that mean? Well, a {}static {}emitter is one that you can define once and forget about as it will not be moving anywhere for the duration of the game, ie: think of a log fire - it doesn\u0027t move, it just emits flames and so is static, but a fireball would require a {}dynamic{} emitter and will move across the screen. As for bursting or streaming, a burst is a one off explosion of particles, whereas a stream is just that - a constant stream of particles every step. For area and distribution, with emitters you can define an area for emitting particles (which can be a rectangle, ellipse, diamond or line) as well as the distribution curve (gaussian, inverse gaussian, or linear).":"这都是什么意思？好吧，一个{}静态{}发射器是一个你可以定义一次就忘掉的发射器，因为它在游戏过程中不会移动到任何地方，即：想想一个木头火，它不会移动，只是发出火焰，所以是静态的，但一个火球需要一个{}动态{}发射器，会在屏幕上移动。至于爆裂或流，爆裂是一次性的粒子爆炸，而流就是这样--每一步都是持续的粒子流。对于面积和分布，对于发射器，你可以定义一个发射粒子的区域(可以是矩形、椭圆形、菱形或直线)，以及分布曲线(高斯、反高斯或线性)。",
    "You&nbsp;now have a system and a particle to put in it, but you\u0027re not ready yet to create your outstanding effects! You&nbsp;still have to define the properties of the particle, ie: how it looks - its speed, its rotation, its alpha etc... There are a lot of details that can be used to define a particle effect, so below is an overview of the most important settings and then a snippet of code and GML Visual that uses all of them:":"你现在有一个系统和一个粒子放在里面，但是你还没有准备好创造你杰出的效果！你仍然需要定义粒子的属性，即：它的外观——它的速度、旋转、阿尔法等…有很多细节可用于定义粒子效果，因此以下是最重要设置的概述，然后是使用所有这些设置的代码片段和GML Visual：",
    "and in GML Visual it\u0027d be:":"在GML Visual中，它将是：",
    "{}A particle burst is simply a one-off explosion of particles from the emitter, rather than a constant stream of them every game step.":"{}粒子爆发只是来自发射器的粒子的一次性爆炸，而不是每个游戏步骤都有源源不断的粒子流。",
    "{}Cleaning Up{}{}Cleaning Up{}":"{}清理{}{}清理{}",
    "{}Creating A Particle System{}{}Creating A Particle System{}":"{}创建粒子系统{}{}创建粒子系统{}",
    "{}Creating Particles Directly In-Game{}{}Creating Particles Directly In-Game{}":"{}直接在游戏中创建粒子{}{}直接在游戏中创建粒子{}",
    "{}Creating Particles With Emitters{}{}Creating Particles With Emitters{}":"{}使用发射器创建粒子{}{}使用发射器创建粒子{}",
    "{}Defining A Particle Type{}{}Defining A Particle Type{}":"{}定义粒子类型{}{}定义粒子类型{}",
    "{}NOTE{}: There are other minor particle properties too which we don\u0027t cover here, just to keep things as simple as possible to start with. See the appropriate pages for full details of particle properties.":"{}NOTE{}：还有其他一些细微的粒子特性，我们不在这里介绍，只是为了让事情一开始就尽可能简单。有关粒子属性的完整详细信息，请参阅相应页面。",
    "{}Note that the layer name supplied must be a valid layer in the room where the system will be used, otherwise no particles will be visible.&nbsp;Also note that we set the \"persistent\" flag (both in code and in GML Visual) to false. A persistent particle system is one that will \"persist\" across rooms without the need to destroy and re-create it for each room. However, to keep things simple for this guide, we\u0027ll not be using persistence.":"{}请注意，提供的图层名称必须是将使用系统的房间中的有效图层，否则将看不到粒子。另请注意，我们将\"持久\"标志(在代码和GML Visual中)设置为false。持续粒子系统是一种在房间里\"持续\"的系统，而不需要为每个房间破坏和重新创建它。但是，为了使本指南简单起见，我们将不使用持久性。",
    "{}Note that using GML Visual we also tick the {}blend {}option. This enables {}additive blending{} for the particle, which we\u0027ll discuss a bit further down.":"{}请注意，使用GML Visual，我们还勾选了{}混合{}选项。这使得{}可以为粒子添加混合{}，我们将在下面进一步讨论。",
    "{}So that\u0027s it! We have now defined our particles and they are ready to be used.":"{}原来如此！现在，我们已经定义了粒子，可以随时使用了。",
    "{}So, here we are creating two particle emitters that are assigned to the particle system we created at the start. The functions/actions to create these emitters permit us to define an area in the room over which they will emit particles, as well as give the particle type to emit, and the shape and distribution to use within the defined area. The functions/actions will return a numeric value, which is the emitter ID value, and we store this in a variable so that we can use further emitter functions to target those emitters.":"{}所以，这里我们创建了两个粒子发射器，它们分配给我们在开始时创建的粒子系统。创建这些发射器的功能/操作允许我们在房间中定义一个区域，它们将在该区域上发射粒子，并给出要发射的粒子类型，以及在定义区域内使用的形状和分布。函数/操作将返回一个数值，即发射器ID值，我们将其存储在一个变量中，以便我们可以使用更多的发射器函数来定位这些发射器。",
    "{}That single code/action above will create 10 particles at the given x/y coordinates of type \"Particle1\" from our global system. Simple! The great thing about that line of code/action is that it can be used anywhere without any fuss. For example if you place it in the {}Global Left Pressed{} event for the mouse in an object and change x/y values for the mouse_x/y position, it will create particles at the mouse position every time you press the button. Or if you have a rocket, then you could place this in the step event and have smoke particles coming every step (although 1 or 2 would probably be better than 10!). You can even have it create particles over an area by changing the x/y coordinates randomly, for example:":"{}上面的单一代码/动作将在我们的全局系统中，在给定的x/y坐标上创建10个类型为 \"Particle1 \"的粒子。很简单!这行代码/动作的好处是，它可以在任何地方使用，没有任何麻烦。例如，如果你把它放在{}全局左键{}事件中，并改变mouse_x/y位置的x/y值，它就会在你每次按下按钮时在鼠标位置创建粒子。或者如果你有一个火箭，那么你可以把它放在步骤事件中，让烟雾粒子每一步都出现(虽然1或2可能比10更好！)。你甚至可以让它通过随机改变x/y坐标在一个区域内产生粒子，例如。",
    "{}The above code will create 50 particles at a random position within a 40px square area.":"{}上面的代码将在40px正方形区域内的随机位置创建50个粒子。",
    "{}This will remove the defined particles, emitters, and then the system from memory ready for you to restart the game or change room. Just remember that after thinking about where would be the most suitable place to create the system, think about where would be the most suitable place to destroy the system too!":"{}这将删除定义的粒子、发射器，然后从内存中删除系统，以便您重新启动游戏或更换房间。只要记住，在思考过哪里最适合创建系统之后，再思考一下哪里也最适合摧毁系统！",
    "{}alpha{}:&nbsp;Sets the alpha value for the particle between a value of 0 and 1. If a single value is passed in this will be the alpha of the particle, if two or three values are passed in then the alpha will blend between these over the lifetime of the particle.":"{}alpha{}：将粒子的阿尔法值设置为 0 到 1 之间。如果传入单个值，这将是粒子的 alpha;如果传入了两个或三个值，则在粒子的生命周期内，alpha 将在这些值之间混合。",
    "{}blending{}:&nbsp;Sets whether to use {}additive {}blending or {}normal {}blending for the particle type. This is set in a function when using GML and as part of the particle initialisation when using GML Visual. Additive blending means that the particles will use the {}bm_add{} blend mode, giving them a \"glowing\" look where they overlap, and also blending them with anything drawn underneath (sprites, backgrounds, tiles, etc...) - very useful for fire and magic effects (for example), but best left off for something like smoke. Experiment to see the differences! Note that enabling this will break the texture batching when particles are created, and so more batches will be required per step to draw them - something to consider as it may affect performance, especially on mobile.":"{}blending{}：设置是使用{}添加{}混合还是{}默认{}混合作为粒子类型。这在使用 GML 时在函数中设置，使用 GML Visual 时作为粒子初始化的一部分进行设置。加法混合意味着粒子将使用{}bm_add{}混合模式，在它们重叠的地方给它们一个 \"发光\" 的外观，还可以将它们与下面绘制的任何东西(精灵、背景、图块等...)混合在一起-对于火焰和魔法效果(例如)非常有用，但最好不要用于烟雾之类的东西。试一试看差异！请注意，启用此功能将在创建粒子时中断纹理批处理，因此每步绘制粒子需要更多的批处理——这是需要考虑的，因为它可能会影响性能，尤其是在移动设备上。",
    "{}colour{}:&nbsp;Sets the colour for the particle if a single colour is used. If two or three colours are supplied this will be the colour blend, blending from one to the other over its lifetime.":"{}color{}：如果使用单一颜色，则设置粒子的颜色。如果提供两种或三种颜色，这将是混合颜色，在其使用寿命内从一种颜色混合到另一种颜色。",
    "{}direction{}:&nbsp;Sets the direction properties for the particle type. Again you specify a range of directions (in counterclockwise degrees - 0 indicates a motion to the right, 90 indicates a motion upwards, etc...). For example, to let the particle move in a random direction you\u0027d choose a minimum 0 and and a maximum of 360 as values. You can specify an increase in direction for each step too (can also be negative).":"{}direction{}：设置粒子类型的方向属性。同样，您可以指定方向范围(逆时针度数——0 表示向右运动，90 表示向上运动，依此类推...)。例如，要让粒子沿随机方向移动，可以选择最小值 0 和最大值 360 作为值。您也可以为每个步骤指定方向的增量(也可以为负数)。",
    "{}life{}:&nbsp;Sets the lifetime bounds, in steps (game frames) for the particle type. Like previous settings, this has a minimum and maximum value and particles will last a random number of steps within these values. So, a lifetime of 30 min and 30 max will have the particle existing for exactly 30 steps, but a lifetime of 20 min and 60 max will have each particle exists for a random number of steps between 20 and 60.":"{}life{}：为粒子类型设置生命周期，以步数(游戏帧)为单位。与之前的设置一样，它有最小值和最大值，粒子将在这些值内持续随机数步。因此，如果寿命为 30 分钟，最大值为 30 步，则粒子的存在时间正好为 30 步，但是如果寿命为 20 分钟和最长 60 步，则每个粒子将在 20 到 60 之间随机存在。",
    "{}orientation{}:&nbsp;Sets the orientation angle properties for the particle type. You specify the minimum angle, the maximum angle, and the increase in each step. You can also indicate whether the given angle should be relative to the current direction of motion or absolute, e.g: by setting all values to 0 but relative to true, the particle orientation will precisely follow the path of the particle.":"{}orientation{}：设置粒子类型的方向角度属性。您可以在每个步骤中指定最小角度、最大角度和增量。您还可以指明给定角度应该是相对于当前运动方向还是绝对角度，例如：通过将所有值设置为 0 但相对于 true，粒子方向将精确地遵循粒子的路径。",
    "{}shape{}:&nbsp;The shape of the particle is the built in sprite that it will use, with the default being the constant {}pt_shape_pixel{}. There is also a function to add a custom particle if required - {}{}part_type_sprite(){}{}&nbsp;- or the action {}Set Particle Sprite{}.":"{}shape{}：粒子的形状是它将使用的内置精灵，默认为常数{}pt_shape_pixel{}。如果需要，还有一个函数可以添加自定义粒子-{}{}part_type_sprite(){}{}-或者操作{}Set Particle Sprite{}。",
    "{}size{}:&nbsp;Sets the size parameters for the particle type. You specify the minimum starting size, the maximum starting size, and the size increase in each step (use a negative number for a decrease in size). This is a scalar value that will modify the base image x/y scale equally.":"{}size{}：设置粒子类型的大小参数。您可以在每个步骤中指定最小起始大小、最大起始大小和大小增加量(使用负数表示大小减小)。这是一个标量值，它将平等地修改基础图像的 x/ y 比例。",
    "{}speed{}:&nbsp;Sets the speed properties for the particle type. You specify a minimum and maximum speed and a random value between the given bounds is chosen when the particle is created. You can indicate a speed increase in each step, and even use a negative numbers to slow the particle down (the speed will never become smaller than 0).":"{}speed{}：设置粒子类型的速度属性。您可以指定最小和最大速度，并在创建粒子时选择给定边界之间的随机值。你可以表示每步的速度都有所提高，甚至可以使用负数来减慢粒子的速度(速度永远不会小于 0)。"
}