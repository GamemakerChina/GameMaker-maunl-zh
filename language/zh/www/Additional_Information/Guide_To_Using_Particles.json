{
    " {} And the distribution curves (linear, gaussian, and inverse gaussian) are illustrated here:":"{}分布曲线(线性、高斯和逆高斯)如下:",
    "And for those of you that use GML Visual:":"对于那些使用 GML Visual 的用户:",
    "And for those of you that use {}GML Visual{}:":"对于那些使用 {}GML 可视化{}的用户:",
    "And using GML Visual:":"使用 GML Visual:",
    "And using {}GML Visual{}:":"使用 {}GML 可视化{}:",
    "As mentioned at the start, once created, a particle system (and its particles, emitters etc...) are stored in memory for instant use. Great, but what happens when you restart the game? Or if your player dies and starts the room again? Well, if you don\u0027t manage the game right you get a {}memory leak{}. This is when something has been created and uses up memory, but has been \"de-referenced\" meaning that GameMaker no longer has access to it. This kind of thing will slowly eat up memory and cause lag in your game or even block the computer causing your game to crash, and it is a pretty common problem with first time users of particle systems.":"正如开头所提到的，一旦创建，粒子系统(及其粒子、发射器等)就会存储在内存中以供立即使用。很好，但是当你重新开始游戏时会发生什么呢?或者如果你的玩家死亡并重新开始这个房间?如果你没有正确地管理游戏，你就会出现{}内存泄漏{}。这是当某些东西已经创建并使用了内存，但已经被“丢失引用”，这意味着GameMaker不再能够访问它。这类事情会慢慢消耗内存，导致游戏延迟，甚至阻塞电脑导致游戏崩溃，这是粒子系统的第一次用户经常遇到的问题。",
    "As mentioned at the start, once created, a particle system (and its particles, emitters, etc.) are stored in memory for instant use. Great, but what happens when you restart the game? Or if your player dies and starts the room again? Well, if you don\u0027t manage the game right you get a {}memory leak{}. This is when something has been created and uses up memory, but has been \"de-referenced\" meaning that&nbsp;{}GameMaker{} no longer has access to it. This kind of thing will slowly eat up memory and cause lag in your game or even block the computer causing your game to crash, and it is a pretty common problem with first time users of particle systems.":"正如开头所提到的，一旦创建，粒子系统(及其粒子、发射器等)就会存储在内存中以供立即使用。很好，但是当你重新开始游戏时会发生什么呢?或者如果你的玩家死亡并重新开始这个房间?如果你没有正确地管理游戏，你就会出现{}内存泄漏{}。这是当某些东西已经创建并使用了内存，但已经被“丢失引用”，这意味着 {}GameMaker{} 不再能够访问它。这类事情会慢慢消耗内存，导致游戏延迟，甚至阻塞电脑导致游戏崩溃，这是粒子系统的第一次用户经常遇到的问题。",
    "Before going any further, we should probably explain what a particle actually is... Basically, a particle is a graphic resource that has certain properties which are defined by a {}particle system{}. These properties cannot be manipulated directly for {}individual {}particles, but are changed collectively through the code or actions that are used to define the system that it belongs to. They are very useful for creating beautiful and flashy effects - or subtle and discreet ones -&nbsp;in a game without the CPU overhead that using instances has.":"在进一步讨论之前，我们或许应该先解释一下粒子到底是什么……基本上，粒子是一种图形资源，它具有由{}粒子系统{}定义的某些属性。 这些属性不能直接针对{}单个{}粒子进行操作，而是通过用于定义其所属系统的代码或操作来集体更改。 它们对于在没有使用实例的 CPU 开销的游戏中创建美丽而华丽的效果（或微妙而谨慎的效果）非常有用。",
    "Before going any further, we should probably explain what a particle actually is... Basically, a {}{}particle is a graphic resource that has certain properties which are defined by a {}particle system{}. These properties cannot be manipulated directly for {}individual {}particles, but are changed collectively through the code or actions that are used to define the system that it belongs to. They are very useful for creating beautiful and flashy effects - or subtle and discreet ones -&nbsp;in a game without the CPU overhead that using instances has.":"在进一步讨论之前，我们或许应该先解释一下粒子到底是什么……基本上，{}{}粒子是一种图形资源，它具有由{}粒子系统{}定义的某些属性。 这些属性不能直接针对{}单个{}粒子进行操作，而是通过用于定义其所属系统的代码或操作来集体更改。 它们对于在没有使用实例的 CPU 开销的游戏中创建美丽而华丽的效果（或微妙而谨慎的效果）非常有用。",
    "Before setting up a system and creating particles, it\u0027s important to know a few things... First is that most of a particle systems code is {}only ever called once in the game{}, usually in some type of controller object in the first room or level - this is not always the case, but for the sake of simplicity, we\u0027ll be using this scenario for the following brief guide as it\u0027s the most common way to use particles. You do this because a particle system, once created, stays in memory and is ready to be used at any time, so if you create it more than once it can quickly increase the memory usage and cause serious lag, and even has the potential of crashing the game. For the sake of simplicity in this guide, you&nbsp;will make a {}global {}particle system that can be used by any instance in the game at any time.":"在建立一个系统和创建粒子之前，知道一些事情是很重要的……首先，大多数粒子系统代码在游戏中{}只被调用一次{}，通常是在第一个房间或关卡的某些类型的控制器对象中 -情况并非总是如此，但为了简单起见，我们将在以下简要指南中使用这种场景，因为这是使用粒子最常见的方式。你这样做是因为粒子系统一旦创建，就会停留在内存中，随时可以使用，所以如果你多次创建它，它就会迅速增加内存使用量，造成严重的延迟，甚至有可能导致游戏崩溃。为了简单起见，在本指南中，你将制作一个全局粒子系统，可以在任何时间被游戏中的任何实例使用。",
    "Before setting up a system and creating particles, it\u0027s important to know a few things... First is that most of a particle systems code is {}only ever called once in the game{}, usually in some type of controller object in the first room or level - this is not always the case, but for the sake of simplicity, we\u0027ll be using this scenario for the following brief guide as it\u0027s the most common way to use particles. You do this because a particle system, once created, stays in memory and is ready to be used at any time, so if you create it more than once it can quickly increase the memory usage and cause serious lag, and even has the potential of crashing the game. For the sake of simplicity in this guide, you&nbsp;will make a {}global{}{}&nbsp;{}particle system that can be used by any instance in the game at any time.":"在建立一个系统和创建粒子之前，知道一些事情是很重要的……首先，大多数粒子系统代码在游戏中{}只被调用一次{}，通常是在第一个房间或关卡的某些类型的控制器对象中 -情况并非总是如此，但为了简单起见，我们将在以下简要指南中使用这种场景，因为这是使用粒子最常见的方式。你这样做是因为粒子系统一旦创建，就会停留在内存中，随时可以使用，所以如果你多次创建它，它就会迅速增加内存使用量，造成严重的延迟，甚至有可能导致游戏崩溃。为了简单起见，在本指南中，你将制作一个{}全局{}{}{}粒子系统，可以在任何时间被游戏中的任何实例使用。",
    "Below is an example of the code/actions required to define two emitters, which would normally go in the {}Create Event{} of a controller object, just after defining the particle system. One will be static and stream particles over the area of the whole room, while the other will be dynamic and follow the mouse and burst every 30 steps from a small ellipse:":"下面是定义两个发射器所需的代码/操作的示例，通常在定义粒子系统之后进入控制器对象的{} 创建事件 {}。一个是静态的，粒子流遍布整个房间，而另一个是动态的，跟随鼠标，每30步从一个小椭圆爆发:",
    "But what if you want several objects to emit particles? A global emitter can only be in one place at a time, so you would need to create {}local {}emitters in each object. These emitters will still use the global particle system and any particles that are within it, but they can be different shapes and sizes and move with the object, making them ideal for rockets or bullets or things. The code you would use is exactly the same as above, but without the \"global\" prefix before the emitter names.":"但是如果你想让几个物体发射粒子呢？ 全局发射器一次只能位于一个位置，因此您需要在每个对象中创建{}局部{}发射器。 这些发射器仍将使用全局粒子系统和其中的任何粒子，但它们可以具有不同的形状和大小并随对象移动，使它们成为火箭或子弹或其他东西的理想选择。 您将使用的代码与上述代码完全相同，但发射器名称前没有“全局”前缀。",
    "Guide To Using Particles":"粒子使用指南",
    "How do you avoid this? Well, {}GameMaker{} has GML Code functions and GML Visual actions to delete particle systems and their emitters and particles from memory when not in use, and with a little bit of planning when using the following code/actions, you can easily prevent this potential problem.":"如何避免这种情况?{}GameMaker{}具有GML 代码函数和GML Visual操作，可以在不使用时从内存中删除粒子系统及其发射器和粒子，并且在使用以下代码/操作时进行一些规划，就可以很容易地防止这个潜在的问题。",
    "How do you avoid this? Well, {}GameMaker{} has&nbsp;{}GML Code{} functions and&nbsp;{}GML Visual{} actions to delete particle systems and their emitters and particles from memory when not in use, and with a little bit of planning when using the following code/actions, you can easily prevent this potential problem.":"如何避免这种情况? {}GameMaker{} 具有 {}GML 代码{}函数和 {}GML 可视化{}操作，可以在不使用时从内存中删除粒子系统及其发射器和粒子，并且在使用以下代码/操作时进行一些规划，就可以很容易地防止这个潜在的问题。",
    "If you already have a&nbsp;{}{}Particle System Asset{}{}, you can create it using the above function/action by passing the asset into the {}partsys{}/\"System\" argument.":"如果您已经拥有{}{}粒子系统资源{}{}，则可以使用上述函数/操作通过将资源传递到 {}partsys{}/\"system\" 参数来创建它。",
    "Let\u0027s look at some code that defines a particle now:":"现在让我们来看一些定义粒子的代码:",
    "Now we have code/GML Visual to stream particles (these particles will be emitted every game step without us having to anything else), but we also want to add an {}A{}{}larm[0]{}&nbsp;{}Event{} to burst particles at specific intervals:":"现在我们有代码/GML Visual 来流式传输粒子（这些粒子将在游戏的每个步骤中发射，我们无需执行任何其他操作），但我们还想添加{}一个{}{}larm[0]{}{}事件{} 以特定时间间隔爆发粒子：",
    "Now we have code/{}GML Visual{} to stream particles (these particles will be emitted every game step without us having to anything else), but we also want to add an {}A{}{}larm[0]{}&nbsp;{}Event{} to burst particles at specific intervals:":"现在我们有代码/{}GML 可视化{}来流式传输粒子（这些粒子将在游戏的每个步骤中发射，我们无需执行任何其他操作），但我们还想添加{}一个{}{}Alarm[0]{}{}事件{} 以特定时间间隔爆发粒子：",
    "Now you know the basics about particles, particle systems and emitters, so you can now add them into your game! But before rushing off and adding particle effects to everything, please note that while particles are less CPU hungry than instances, they are not the solution to everything as they will cause lag if you have thousands of them at a time. The best thing to do is experiment and use them carefully to \"flesh out\" visually a game and give it a bit more eye-candy without over doing it.":"现在您了解了粒子、粒子系统和发射器的基础知识，现在您可以将它们添加到您的游戏中了！ 但是在匆匆忙忙地为所有内容添加粒子效果之前，请注意虽然粒子比实例更节省 CPU，但它们并不是解决所有问题的方法，因为如果您一次有数千个粒子，它们会导致延迟。最好的做法是尝试并仔细使用它们去“充实”游戏，并在不过度的情况下赋予它更多视觉效果。",
    "Now, before we present you the code for defining the particle, let\u0027s just talk about \"{}wiggle{}\" for a moment... Believe it or not, \"wiggle\" is a particle property and can be set for many of the above settings individually. When you see \"wiggle\" as an argument for a particle function or action, it means that if you place a number between 1 and 20 the particle will \"wiggle\" or fluctuate between the min and max values for the property, with 1 being a slow wiggle and 20 being very fast. So a particle speed minimum of 2 and maximum of 5 with a wiggle of 20 will oscillate very quickly between the min/max speeds for the lifetime of each particle created.":"现在，在我们向您展示定义粒子的代码之前，让我们先讨论一下“{}摆动(wiggle){}”……不管你信不信，“wiggle”是一个粒子属性，可以为上面的许多设置单独设置。当你将“摆动”视为粒子函数或动作的参数时，这意味着如果你在1到20之间放置一个数字，粒子将“摆动”或在属性的最小值和最大值之间波动，1表示缓慢摆动，20表示非常快。因此，粒子速度最小值为2，最大值为5，波动为20，将在每个粒子生命周期的最小/最大速度之间快速振荡。",
    "Since we\u0027ve explained the easy way to create particles, let\u0027s now go the slightly more complex way, which is to use {}emitters{}. Emitters are another part of the particle system that has to be defined before being used, so we\u0027ll make a global emitter the same as we did for the system and the particles. We also have to decide whether to have a static (non-moving) emitter or not and whether we are going to {}burst {}or {}stream {}the particles, as well as decide over what area and what kind of distribution we are going to have the emitter use.":"既然我们已经解释了创建粒子的简单方法，现在让我们使用稍微复杂一点的方法，即使用{}发射器{}。发射器是粒子系统的另一部分，在使用之前必须定义它，所以我们将创建一个全局发射器，就像我们为系统和粒子所做的一样。我们还必须决定是否使用静态(不移动的)发射器，以及我们是否使用{}突发{}或{}流{}粒子，以及决定我们将使用发射器在什么区域和什么样的分布。",
    "So that\u0027s the system created, but what about the particles? We have to define them too or the system is useless and does nothing.":"这就是我们创造的系统，那么粒子呢？我们也必须对它们进行定义，否则这个系统将毫无用处，什么也不做。",
    "That\u0027s the creation of particles dealt with but there is one more thing that\u0027s very important... Cleaning up when you are finished with them.":"这就是粒子的产生，但还有一件事非常重要。用完后清理。",
    "The first thing you have to do is decide where you are going to create the system and how you will use it. You could create a global system in the {}Game Start Event{} of an object that is in your first room (like a menu or title screen), but this means that if you restart the game using the {}{}game_restart(){}{} function, it will be recreated and cause a memory leak. Or you could create a local system in an instance in any room, but again, if you leave the room then the system will be inaccessible and cause a memory leak. To avoid this you would need to have something like this in the {}{}Game End Event{}{} or the {}{}Clean Up Event{}{} of your object:":"您必须做的第一件事是决定在哪里创建系统以及如何使用它。你可以在第一个房间的对象(如菜单或标题屏幕)的{}游戏创建事件{}中创建一个全局系统，但这意味着如果你使用{}{}game_restart(){}{}函数重新启动游戏，它将被重新创建并导致内存泄漏。或者，您可以在任何房间的实例中创建本地系统，但是如果您离开房间，则系统将无法访问并导致内存泄漏。为了避免这种情况，你需要在对象的{}{}游戏结束事件{}{}或{}{}清理事件{}{}}中添加如下内容:",
    "The first thing you have to do is decide where you are going to create the system and how you will use it. You could create a global system in the {}Game Start Event{} of an object that is in your first room (like a menu or title screen), but this means that if you restart the game using the&nbsp;{}{}game_restart{}{} function, it will be recreated and cause a memory leak. Or you could create a local system in an instance in any room, but again, if you leave the room then the system will be inaccessible and cause a memory leak. To avoid this you would need to have something like this in the {}{}Game End Event{}{} or the {}{}Clean Up Event{}{} of your object:":"您必须做的第一件事是决定在哪里创建系统以及如何使用它。你可以在第一个房间的对象(如菜单或标题屏幕)的{}游戏创建事件{}中创建一个全局系统，但这意味着如果你使用 {}{}game_restart{}{} 函数重新启动游戏，它将被重新创建并导致内存泄漏。或者，您可以在任何房间的实例中创建本地系统，但是如果您离开房间，则系统将无法访问并导致内存泄漏。为了避免这种情况，你需要在对象的{}{}游戏结束事件{}{}或{}{}清理事件{}{}中添加如下内容:",
    "The following images illustrate the different types of area shape available for emitters:":"以下图像说明发射器可获得的不同类型的面积形状:",
    "There are a couple of ways to create particles, and each has its pros and cons. You can use {}emitters{} to {}burst {}or {}stream {}particles, or you can create particles {}directly {}at a point. Which one you use really depends on what you are trying to achieve and the effect you are wanting to create, but we\u0027ll start with the easiest of the two, which is creating particles directly. In GML we\u0027d use the following function:":"有几种方法可以创建粒子，每种方法都有其优缺点。您可以使用{}发射器{}来{}爆发(burst){}或{}流(stream){}粒子，或者您可以在一个点上直接{}创建粒子{}。你用哪一种取决于你想要达到的目的和你想要创造的效果，但我们将从两个中最简单的开始，它是直接创造粒子。在GML中，我们使用以下函数:",
    "This guide is for those of you that want to understand how to use and create {}particles{}. This page will cover both the {}GameMaker Language functions{}&nbsp;and {}GML Visual actions{}&nbsp;for particles, so if you\u0027ve never used particles before, we hope that this guide can get you started as they are very useful and quite fun to make.":"本指南适用于那些想要了解如何使用和创建{}粒子{}的人。 此页面将涵盖粒子的 {}GML 函数{} 和 {}GML 视觉操作{} ，因此如果您以前从未使用过粒子，我们希望本指南可以帮助您入门 非常有用，制作起来也很有趣。",
    "This guide is for those of you who want to understand how to use and create {}particles{}&nbsp;in GML. This page will cover both the {}{}GML Code{}&nbsp;functions{}&nbsp;and {}{}GML Visual{}&nbsp;actions{}&nbsp;for particles, so if you\u0027ve never used particles before, we hope that this guide can get you started as they are very useful and quite fun to make.":"本指南面向那些想要了解如何在 GML 中使用和创建{}粒子{}的用户。本页将涵盖粒子的 {}{}GML 代码{}{}函数{}和 {}{}GML 可视化{}操作，所以如果您以前从未使用过粒子，我们希望本指南可以帮助您入门，因为它们非常有用并且非常有趣。",
    "To create this same particle definition in GML Visual we\u0027d need these actions:":"要在 GML Visual 中创建同样的粒子定义，我们需要以下操作:",
    "To create this same particle definition in&nbsp;{}GML Visual{} we\u0027d need these actions:":"要在 {}GML 可视化{}中创建同样的粒子定义，我们需要以下操作:",
    "To start with you need to define the particle system and give it a name so that you can use it. As this is going to be a global system that any object can use you would do this&nbsp;in a controller object or an initialisation function run at the start of the game. The GML would look like this:":"首先，你需要定义一个粒子系统，并给它一个名字，这样你就可以使用它。因为这将是一个全局系统，任何对象都可以使用，你可以在控制器对象或者游戏开始时运行的初始化函数中做到这一点。GML 应该是这样的:",
    "To start with you need to define the particle system and give it a name so that you can use it. As this is going to be a global system that any object can use you would do this&nbsp;in a controller object or an initialisation function run at the start of the game. The&nbsp;{}GML Code{} would look like this:":"首先，你需要定义一个粒子系统，并给它一个名字，这样你就可以使用它。因为这将是一个全局系统，任何对象都可以使用，你可以在控制器对象或者游戏开始时运行的初始化函数中做到这一点。{}GML 代码{}应该是这样的:",
    "To use a particle in a system you have to first define its general properties. These are like object properties, but they only apply in a {}general {}way to individual particles. What this means is that if you give the particles a minimum movement speed of 1 and a maximum movement speed of 2, any particle created by the system will have a random speed between 1 and 2 pixels per step, and that overall they will have an average speed of 1.5. You should name and add your first particle to the system using the following GML in the same object that you used to create the system:":"要在系统中使用粒子，你必须首先定义它的一般性质。这些类似于对象属性，但它们只以{}一般{}的方式应用于单个粒子。这意味着，如果你给粒子一个1的最小移动速度和2的最大移动速度，系统创建的任何粒子每步将有一个1到2像素之间的随机速度，总体上它们的平均速度将是1.5。你应该在你用来创建系统的相同对象中使用以下GML命名并添加你的第一个粒子到系统:",
    "We have mentioned particle systems, so let\u0027s explain what that is before continuing. Think of a particle system like a container that you will use to hold your particles ready for use. You can use code or actions to define the visual aspect of the particles, and then they are placed in the \"container\" (the particle system) so that you can take it out and use it whenever and wherever you need it later.":"我们已经提到了粒子系统，所以在继续之前让我们解释一下这是什么。将粒子系统想象成一个容器，您将使用它来保存粒子以备使用。您可以使用代码或操作来定义粒子的可视化方面，然后将它们放置在“容器”(粒子系统)中，以便您可以将其取出，并在以后需要时随时随地使用它。",
    "We have mentioned particle systems, so let\u0027s explain what that is before continuing. Think of a {}{}particle system like a container that you will use to hold your particles ready for use. You can use code or actions to define the visual aspect of the particles, and then they are placed in the \"container\" (the particle system) so that you can take it out and use it whenever and wherever you need it later.":"我们已经提到了粒子系统，所以在继续之前让我们先解释一下它是什么。将{}{}粒子系统想象为一个容器，您将使用它来保存粒子以备使用。您可以使用代码或动作来定义粒子的视觉方面，然后将它们放置在\"容器\"(粒子系统)中，以便您可以在以后需要它的任何时间和任何地方将其取出并使用。",
    "What does all that mean? Well, a {}static {}emitter is one that you can define once and forget about as it will not be moving anywhere for the duration of the game, ie: think of a log fire - it doesn\u0027t move, it just emits flames and so is static, but a fireball would require a {}dynamic{} emitter and will move across the screen. As for bursting or streaming, a burst is a one off explosion of particles, whereas a stream is just that - a constant stream of particles every step. For area and distribution, with emitters you can define an area for emitting particles (which can be a rectangle, ellipse, diamond or line) as well as the distribution curve (gaussian, inverse gaussian, or linear).":"这一切意味着什么?{} 静态 {}发射器是一种你可以定义一次就忘记的东西，因为它在整个游戏过程中不会移动，比如:想想一根木头火 - 它不会移动，它只会发出火焰，静态也是如此，但火球需要{} 动态 {}发射器，它会在屏幕上移动。至于爆发或流，爆发是粒子的一次性爆炸，而流就是这样 - 每一步都是恒定的粒子流。 对于区域和分布，您可以使用发射器定义发射粒子的区域（可以是矩形、椭圆、菱形或直线）以及分布曲线（高斯、逆高斯或线性）。",
    "You&nbsp;now have a system and a particle to put in it, but you\u0027re not ready yet to create your outstanding effects! You&nbsp;still have to define the properties of the particle, ie: how it looks - its speed, its rotation, its alpha etc... There are a lot of details that can be used to define a particle effect, so below is an overview of the most important settings and then a snippet of code and GML Visual that uses all of them:":"你现在有了一个系统和一个放入其中的粒子，但你还没有准备好创建你的杰出效果!你仍然需要定义粒子的属性，例如:它的样子，它的速度，它的旋转，它的alpha等等。有很多细节可以用来定义粒子效果，所以下面是一个最重要的设置的概述，然后是一个代码片段和GML Visual使用所有这些:",
    "You&nbsp;now have a system and a particle to put in it, but you\u0027re not ready yet to create your outstanding effects! You&nbsp;still have to define the properties of the particle, ie: how it looks - its speed, its rotation, its alpha, etc. There are a lot of details that can be used to define a particle effect, so below is an overview of the most important settings and then a snippet of code and&nbsp;{}GML Visual{} that uses all of them:":"你现在有了一个系统和一个放入其中的粒子，但你还没有准备好创建你的杰出效果!你仍然需要定义粒子的属性，例如:它的样子，它的速度，它的旋转，它的alpha等等。有很多细节可以用来定义粒子效果，所以下面是一个最重要的设置的概述，然后是一个代码片段和 {}GML 可视化{}使用所有这些:",
    "and in GML Visual it\u0027d be:":"在 GML Visual 中，应该是:",
    "and in&nbsp;{}GML Visual{} it\u0027d be:":"在 {}GML 可视化{}中，应该是:",
    "{} And the distribution curves (linear, gaussian, and inverse gaussian) are illustrated here:":"{}分布曲线(线性、高斯和逆高斯)如下:",
    "{}A particle burst is simply a one-off explosion of particles from the emitter, rather than a constant stream of them every game step.":"{}粒子爆发只是来自发射器的一次性粒子爆炸，而不是每个游戏步骤的持续粒子流。",
    "{}Cleaning Up{}{}Cleaning Up{}":"{}清理事件{}{}清理事件{}",
    "{}Creating A Particle System{}{}Creating A Particle System{}":"{}创建粒子系统{}{}创建粒子系统{} ",
    "{}Creating Particles Directly In-Game{}{}Creating Particles Directly In-Game{}":"{}游戏中直接创建粒子{}{}游戏中直接创建粒子{}",
    "{}Creating Particles With Emitters{}{}Creating Particles With Emitters{}":"{}使用发射器创建粒子{}{}使用发射器创建粒子{}",
    "{}Defining A Particle Type{}{}Defining A Particle Type{}":"{}定义粒子类型{}{}定义粒子类型{}",
    "{}Guide To Using Particles{}":"{}粒子使用指南{}",
    "{}NOTE{}: There are other minor particle properties too which we don\u0027t cover here, just to keep things as simple as possible to start with. See the appropriate pages for full details of particle properties.":"{}注意{} : 还有其他一些次要的粒子属性我们在这里没有涉及，只是为了让事情尽可能简单地开始。有关粒子属性的详细信息，请参阅适当的页面。",
    "{}Note that the layer name supplied must be a valid layer in the room where the system will be used, otherwise no particles will be visible.&nbsp;Also note that we set the \"persistent\" flag (both in code and in GML Visual) to false. A persistent particle system is one that will \"persist\" across rooms without the need to destroy and re-create it for each room. However, to keep things simple for this guide, we\u0027ll not be using persistence.":"{}请注意，提供的层名称必须是系统将使用的房间中的有效层，否则将看不到任何粒子。另请注意，我们设置了“持久”标志（在代码和 GML Visual 中）) 为false。 持久粒子系统是一种可以“持续”跨越房间而不需要为每个房间销毁和重新创建它的系统。 但是，为了使本指南的内容简单化，我们不会使用持久性。",
    "{}Note that using GML Visual we also tick the {}blend {}option. This enables {}additive blending{} for the particle, which we\u0027ll discuss a bit further down.":"{}注意，使用 GML Visual 我们还会勾选{}混合{}选项。这为粒子启用了{}加法混合{} ，我们将在后面进一步讨论。",
    "{}So that\u0027s it! We have now defined our particles and they are ready to be used.":"{}就是这样! 我们现在已经定义了粒子，它们可以被使用了。",
    "{}So, here we are creating two particle emitters that are assigned to the particle system we created at the start. The functions/actions to create these emitters permit us to define an area in the room over which they will emit particles, as well as give the particle type to emit, and the shape and distribution to use within the defined area. The functions/actions will return a numeric value, which is the emitter ID value, and we store this in a variable so that we can use further emitter functions to target those emitters.":"{}因此，我们在这里创建两个粒子发射器，它们分配给我们在开始时创建的粒子系统。 创建这些发射器的函数/动作允许我们在房间中定义一个区域，它们将在该区域上发射粒子，并提供要发射的粒子类型，以及要在定义区域内使用的形状和分布。 函数/动作将返回一个数值，即发射器 ID 值，我们将其存储在一个变量中，以便我们可以使用更多的发射器函数来定位这些发射器。",
    "{}That single code/action above will create 10 particles at the given x/y coordinates of type \"Particle1\" from our global system. Simple! The great thing about that line of code/action is that it can be used anywhere without any fuss. For example if you place it in the {}Global Left Pressed{} event for the mouse in an object and change x/y values for the mouse_x/y position, it will create particles at the mouse position every time you press the button. Or if you have a rocket, then you could place this in the step event and have smoke particles coming every step (although 1 or 2 would probably be better than 10!). You can even have it create particles over an area by changing the x/y coordinates randomly, for example:":"{}上述单个代码/操作将在给定的x/y坐标类型为“Particle1”的全局系统中创建10个粒子。简单!这一行代码/动作的伟大之处在于，它可以在任何地方毫无争议地使用。例如，如果您将其放在对象中鼠标的{} 全局鼠标按下 {}事件中，并更改mouse_x/y位置的x/y值，它将在您每次按下按钮时在鼠标位置创建粒子。或者如果你有一个火箭，那么你可以把它放在步进事件中，让每一步都有烟雾颗粒出现(尽管1或2可能比10好!)你甚至可以让它通过随机改变x/y坐标在一个区域上创建粒子，例如:",
    "{}The above code will create 50 particles at a random position within a 40px square area.":"{}以上代码将在40px 平方区域内的随机位置创建50个粒子。",
    "{}This will remove the defined particles, emitters, and then the system from memory ready for you to restart the game or change room. Just remember that after thinking about where would be the most suitable place to create the system, think about where would be the most suitable place to destroy the system too!":"{}这将删除已定义的粒子，发射器，然后系统从内存中准备好让你重启游戏或改变房间。记住，在考虑了哪里是最适合创建系统的地方之后，还要考虑哪里是最适合摧毁系统的地方!",
    "{}alpha{}:&nbsp;Sets the alpha value for the particle between a value of 0 and 1. If a single value is passed in this will be the alpha of the particle, if two or three values are passed in then the alpha will blend between these over the lifetime of the particle.":"{}alpha{}: 将粒子的透明度值设置在 0 和 1 之间。如果传入单个值，这将是粒子的 透明度，如果传入两个或三个值，那么透明度将在粒子的生命周期中混合在这些值之间。",
    "{}blending{}:&nbsp;Sets whether to use {}additive {}blending or {}normal {}blending for the particle type. This is set in a function when using GML and as part of the particle initialisation when using GML Visual. Additive blending means that the particles will use the {}bm_add{} blend mode, giving them a \"glowing\" look where they overlap, and also blending them with anything drawn underneath (sprites, backgrounds, tiles, etc...) - very useful for fire and magic effects (for example), but best left off for something like smoke. Experiment to see the differences! Note that enabling this will break the texture batching when particles are created, and so more batches will be required per step to draw them - something to consider as it may affect performance, especially on mobile.":"{}blending{}: 设置粒子类型是使用{}加法{}混合还是{}普通{}混合。这在使用GML时设置在函数中，在使用GML Visual时作为粒子初始化的一部分。添加混合意味着粒子将使用{}bm_add{}混合模式，在它们重叠的地方赋予它们“发光”的外观，并将它们与下面绘制的任何东西(精灵、背景、图块等)混合——对于火和魔法效果非常有用(例如)，但最好不要使用像烟雾这样的效果。实验看看它们的区别!请注意，启用此功能将破坏创建粒子时的纹理批处理，因此每一步绘制它们将需要更多的批处理——这可能会影响性能，特别是在移动设备上。",
    "{}blending{}:&nbsp;Sets whether to use {}additive {}blending or {}normal {}blending for the particle type. This is set in a function when using&nbsp;{}GML Code{} and as part of the particle initialisation when using {}GML Visual{}. Additive blending means that the particles will use the {}bm_add{} blend mode, giving them a \"glowing\" look where they overlap, and also blending them with anything drawn underneath (sprites, backgrounds, tiles, etc.) - very useful for fire and magic effects (for example), but best left off for something like smoke. Experiment to see the differences! Note that enabling this will break the texture batching when particles are created, and so more batches will be required per step to draw them - something to consider as it may affect performance, especially on mobile.":"{}blending{}：设置粒子类型是使用{}加性{}混合还是使用{}普通{}混合。这是在使用 {}GML 代码{}时在函数中设置的，并在使用 {}GML 可视化{}时作为粒子初始化的一部分设置。加法混合意味着粒子将使用{}bm_add{}混合模式，在它们重叠的地方给它们一个\"发光\"的外观，并将它们与下面绘制的任何东西(精灵、背景、瓷砖等)混合--对于火和魔法效果非常有用(例如)，但最好不要用于烟雾之类的东西。来看看它们的不同之处吧！请注意，启用此选项将在创建粒子时中断纹理批处理，因此每个步骤将需要更多批处理来绘制它们-这一点需要考虑，因为它可能会影响性能，特别是在移动设备上。",
    "{}colour{}:&nbsp;Sets the colour for the particle if a single colour is used. If two or three colours are supplied this will be the colour blend, blending from one to the other over its lifetime.":"{}colour{}: 如果使用单一颜色，则设置粒子的颜色。 如果提供了两种或三种颜色，这将是颜色混合，在其生命周期内从一种颜色混合到另一种颜色。",
    "{}direction{}:&nbsp;Sets the direction properties for the particle type. Again you specify a range of directions (in counterclockwise degrees - 0 indicates a motion to the right, 90 indicates a motion upwards, etc...). For example, to let the particle move in a random direction you\u0027d choose a minimum 0 and and a maximum of 360 as values. You can specify an increase in direction for each step too (can also be negative).":"{}direction{}: 设置粒子类型的方向属性。再次指定一个方向范围(以逆时针方向为单位 - 0表示向右移动，90表示向上移动，等等)。例如，为了让粒子向随机方向移动，你可以选择最小值为0，最大值为360。您也可以为每一步指定一个增加的方向(也可以是负数)。",
    "{}direction{}:&nbsp;Sets the direction properties for the particle type. Again you specify a range of directions (in counterclockwise degrees - 0 indicates a motion to the right, 90 indicates a motion upwards, etc...). For example, to let the particle move in a random direction you\u0027d choose a minimum of 0 and a maximum of 360 as values. You can specify an increase in direction for each step too (can also be negative).":"{}direction{}: 设置粒子类型的方向属性。再次指定一个方向范围(以逆时针方向为单位 - 0表示向右移动，90表示向上移动，等等)。例如，为了让粒子向随机方向移动，你可以选择最小值为0，最大值为360。您也可以为每一步指定一个增加的方向(也可以是负数)。",
    "{}life{}:&nbsp;Sets the lifetime bounds, in steps (game frames) for the particle type. Like previous settings, this has a minimum and maximum value and particles will last a random number of steps within these values. So, a lifetime of 30 min and 30 max will have the particle existing for exactly 30 steps, but a lifetime of 20 min and 60 max will have each particle exists for a random number of steps between 20 and 60.":"{}life{}: 设置粒子类型的生命周期边界，以步骤(游戏帧)为单位。与前面的设置一样，这有一个最小值和最大值，粒子将在这些值内随机持续若干步。所以，30分钟和30秒最大值的生命周期会让粒子存在30步，但20分钟和60秒最大值的生命周期会让每个粒子存在20到60步之间的随机数量。",
    "{}orientation{}:&nbsp;Sets the orientation angle properties for the particle type. You specify the minimum angle, the maximum angle, and the increase in each step. You can also indicate whether the given angle should be relative to the current direction of motion or absolute, e.g: by setting all values to 0 but relative to true, the particle orientation will precisely follow the path of the particle.":"{}orientation{}: 为粒子类型设置方向角度属性。您可以指定每一步的最小角度、最大角度和增量。你也可以指示给定的角度是相对于当前的运动方向还是绝对的，例如:通过设置所有的值为0但相对于true，粒子的方向将精确地遵循粒子的路径。",
    "{}shape{}:&nbsp;The shape of the particle is the built in sprite that it will use, with the default being the constant {}pt_shape_pixel{}. There is also a function to add a custom particle if required - {}{}part_type_sprite(){}{}&nbsp;- or the action {}Set Particle Sprite{}.":"{}shape{}: 粒子的形状是它将使用的内建精灵，默认是常量{}pt_shape_pixel{}。如果需要，还有一个函数可以添加自定义粒子——{}{}part_type_sprite(){}{} ——或者动作{}Set particle Sprite{}。",
    "{}shape{}:&nbsp;The shape of the particle is the built in sprite that it will use, with the default being the constant {}pt_shape_pixel{}. There is also a function to add a custom particle if required -&nbsp;{}{}part_type_sprite{}{}&nbsp;- or the action {}Set Particle Sprite{}.":"{}shape{}: 粒子的形状是它将使用的内建精灵，默认是常量{}pt_shape_pixel{}。如果需要，还有一个函数可以添加自定义粒子 - {}{}part_type_sprite(){}{} - 或者动作{}设置粒子精灵{}。",
    "{}size{}:&nbsp;Sets the size parameters for the particle type. You specify the minimum starting size, the maximum starting size, and the size increase in each step (use a negative number for a decrease in size). This is a scalar value that will modify the base image x/y scale equally.":"{}size{}: 设置粒子类型的大小参数。您可以指定最小起始大小、最大起始大小和每一步中增大的大小(使用负数表示减小)。这是一个标量值，它将等量地修改基图像的x/y比例。",
    "{}speed{}:&nbsp;Sets the speed properties for the particle type. You specify a minimum and maximum speed and a random value between the given bounds is chosen when the particle is created. You can indicate a speed increase in each step, and even use a negative number to slow the particle down (the speed will never become smaller than 0).":"{}speed{}: 设置粒子类型的速度属性。当粒子被创建时，指定最小和最大速度和给定边界之间的随机值。你可以在每一步中增加一个速度，甚至使用一个负数来减慢粒子的速度(速度永远不会小于0)。",
    "{}speed{}:&nbsp;Sets the speed properties for the particle type. You specify a minimum and maximum speed and a random value between the given bounds is chosen when the particle is created. You can indicate a speed increase in each step, and even use a negative numbers to slow the particle down (the speed will never become smaller than 0).":"{}speed{}: 设置粒子类型的速度属性。当粒子被创建时，指定最小和最大速度和给定边界之间的随机值。你可以在每一步中增加一个速度，甚至使用一个负数来减慢粒子的速度(速度永远不会小于0)。",
    "{}{}NOTE{}{}&nbsp;The layer name supplied must be a valid layer in the room where the system will be used, otherwise no particles will be visible.&nbsp;Also note that we set the&nbsp;{}{}persistent{}{} flag (both in code and in {}GML Visual{}) to {}false{}. A persistent particle system is one that will \"persist\" across rooms without the need to destroy and re-create it for each room. However, to keep things simple for this guide, we\u0027ll not be using persistence.":"{}{}注意{}{} 提供的层名称必须是系统将使用的房间中的有效层，否则将看不到任何粒子。另请注意，我们设置了\"{}{}持久{}{}\"标志（在代码和 {}GML 可视化{}中) 为 {}false{}。 持久粒子系统是一种可以\"持续\"跨越房间而不需要为每个房间销毁和重新创建它的系统。 但是，为了使本指南的内容简单化，我们不会使用持久性。",
    "{}{}NOTE{}{}&nbsp;There are other minor particle properties too which we don\u0027t cover here, just to keep things as simple as possible to start with. See the appropriate pages for full details of particle properties.":"{}{}注意{}{}: 还有其他一些次要的粒子属性我们在这里没有涉及，只是为了让事情尽可能简单地开始。有关粒子属性的详细信息，请参阅适当的页面。",
    "{}{}NOTE{}{}&nbsp;Using&nbsp;{}GML Visual{} we also tick the {}blend {}option. This enables {}additive blending{} for the particle, which we\u0027ll discuss a bit further down.":"{}{}注意{}{} 使用 {}GML 可视化{}我们还会勾选{}混合{}选项。这为粒子启用了{}加法混合{} ，我们将在后面进一步讨论。",
    "{}{}TIP{}{}&nbsp;If you prefer a more visual approach to creating particles and don\u0027t need the extensive functionality that&nbsp;{}GML Code{}&nbsp;offers,&nbsp;you can also create a&nbsp;{}{}Particle System Asset{}{}&nbsp;using&nbsp;{}The Particle System Editor{}.":"{}{}提示{}{} 如果您喜欢使用更直观的方法创建粒子，并且不需要 {}GML 代码{}提供的大量功能，也可以使用{}粒子系统编辑器{}创建{}{}粒子系统资源{}{}。"
}