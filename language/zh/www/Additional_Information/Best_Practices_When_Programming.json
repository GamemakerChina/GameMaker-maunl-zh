{
    "Also note that arrays are {}passed by reference{}, but will copy the whole thing when a change is made (this behaviour is called {}copy on write{}). So, if you pass an array to a function, you are passing a {}reference {}to the original array and any values read from it will come from the original source. This is nice and fast, but if you need to modify any of the array values, the array itself is duplicated at the point of the write and any changes made {}need to be returned from the function or they will be lost{}. This is much slower and consumes more memory, so be careful how you use arrays in functions.":"还要注意，数组是通过{}引用{}传递的，但对于旧版项目或开启写时复制时，进行更改时将复制整个内容(这种行为称为{}写时复制{})。因此，如果你将一个数组传递给一个函数，你就是将一个{}引用{}传递给原始数组，从它中读取的任何值都将来自原始源。这很好也很快速，但是如果您需要修改任何数组值，数组本身会在写入时被复制，并且所做的任何更改{}都需要从函数中返回，否则它们将丢失{}。这要慢得多，并且消耗更多的内存，所以在函数中使用数组时要小心。",
    "Also note that while the script editor permits you to fold code at each of the open/close brackets, you can use {}#region{} and {}#endregion{}&nbsp;tags to section off parts of your code and greatly enhance readability, especially when dealing with larger scripts which contain multiple functions. Regions can be commented, too - see the Editing section of this page in the manual):":"还要注意的是，虽然脚本编辑器允许您在每个开/闭括号处折叠代码，但是您可以使用{}#region{}和{}#endregion{} 标记来分隔代码的一部分，并极大地增强可读性，特别是在处理包含多个函数的大型脚本时。区域也可以被注释-参见手册中该页的编辑部分):",
    "Alternatively, look into creating a{} tile-based collision system{}, which can be created using the {}tilemap functions{}&nbsp;or even a custom 2D array or DS grid. These will be very fast and will help boost your game\u0027s speed. However, if you are using irregular terrain or walls and objects that don\u0027t align to a grid they may not be appropriate. You can find a very simple tutorial on tilemap collisions from the following video link":"或者，考虑创建一个基于{}瓷砖的碰撞系统{}，它可以使用{} tilemap 函数{}甚至是一个自定义的2D数组或DS网格。这些将非常快，将有助于提高你的游戏速度。然而，如果你使用的是不规则的地形或墙壁和物体，它们可能不符合网格。你可以从下面的视频链接中找到一个非常简单的关于磁贴图碰撞的教程",
    "Another way to reduce these numbers is to disable the {}Separate Texture Page{} option for sprites unless absolutely necessary. Each image stored in this way is sent to its own texture page and batched differently, so having these images on a regular texture page is better. You can then get the UVS coordinates using the {}{}sprite_get_uvs(){}{}&nbsp;function and store them in variables for use later. It may be a small amount of extra code, but the boost you will get is worth it. Note that this method will not permit texture repeats!":"另一种减少这些数量的方法是禁用精灵的{} 单独的纹理页面 {}选项，除非绝对必要。以这种方式存储的每个图像都被发送到自己的纹理页面，并以不同的批处理方式进行处理，所以将这些图像放在常规的纹理页面上会更好。然后，您可以使用{}{}sprite_get_uvs(){}{} 函数获取UVS坐标，并将它们存储在变量中以供以后使用。这可能需要少量额外的代码，但您将得到的提升是值得的。注意这个方法不允许纹理重复!",
    "Apart from the main things mentioned above, there are other more general things that can help with performance and that are considered \"good practices\" too:":"除了上面提到的主要事情之外，还有其他更普遍的事情可以帮助提高性能，也被认为是“良好实践”:",
    "As with all these tips, if it makes your life more difficult to change it and your game runs fine, don\u0027t worry about it too much...":"就像所有这些建议一样，如果它让你的生活变得更加困难，而你的游戏却运行得很好，那就不要太担心了。",
    "But, as we mentioned at the start of the page, all these optimisations are optional and if your game runs fine with 60 vertex batches, 80 texture swaps, additive blending, etc., then don\u0027t worry about it too much! Just keep these things in mind when programming your next game...":"但是，正如我们在页面开始时所提到的，所有这些优化都是可选的，如果你的游戏能够顺利运行60个顶点批次，80个纹理交换，添加混合(additive blending)等等，那么你就不必太担心这些了!在编写你的下一款游戏时，请牢记这些内容。",
    "Continuing on from the above point about programming style, one thing that a lot of beginners do is to cram as much into one line of code as possible. For example:":"从上面关于编程风格的观点继续，很多初学者所做的一件事就是尽可能多地将代码塞进一行代码中。例如:",
    "Finally, we\u0027re going to touch briefly on using {}surfaces{}, as {}GameMaker{} has a fairly significant optimisation when using them in your games: the ability to switch on and off the {}depth buffer{}.":"最后，我们将简要介绍一下 {}表面{} 的使用，因为{}GameMaker{}在你的游戏中使用它们时有一个相当重要的优化:打开和关闭{}深度缓冲区{}的能力。",
    "However, you can avoid this copy on write behaviour by using the special array {}accessor{}&nbsp;{}@{}, as this gives direct access to the underlying array. For example:":"但是，您可以通过使用特殊的数组{}访问器{} {}@{}来避免这种写时复制行为，因为这提供了对底层数组的直接访问。例如:",
    "If you switch on the {}{}debug overlay{}{},&nbsp;you will see that there are two figures in brackets at the top of your screen when testing. The first is the number of {}texture swaps {}being done and the second is the number of {}vertex batches{}. A number of factors will influence these figures and you will never get them down to (0) (0) as the engine requires one or two of each every step, but you should aim to get these values down as low as possible.":"如果您打开{}{}调试覆盖{}{}，&nbsp;您将在测试时看到屏幕顶部的括号中有两个数字。第一个是正在进行的{}纹理交换{}的数量，第二个是{}顶点批次{}的数量。许多因素会影响这些数值，你不可能将其降低到(0)(0)，因为引擎每一步都需要1到2个数值，但你应该尽可能降低这些数值。",
    "If your game runs fine and you are happy with things as they are, then {}don\u0027t rush to change everything just to squeeze a few extra FPS out{}. You have to strike a balance between readable, flexible and modular code with the time and energy required to change things, as well as the overall gain at the end. Basically, if it isn\u0027t broken, don\u0027t fix it and keep what you learn here for your next project.":"如果你的游戏运行得很好，你对现状也很满意，那么{}就不要为了从{}中挤出一些额外的FPS而急于改变一切。你必须在可读、灵活和模块化的代码之间取得平衡，同时还要花时间和精力去修改内容，以及最终的整体收益。基本上，如果它没有坏，就不要修复它，把你学到的东西保留到下一个项目中。",
    "In this way, all the bullets will be drawn in the same batch. Judicious use of the functions {}{}gpu_set_blendenable(){}{}, {}{}gpu_set_alphatestref(){}{}, and {}{}gpu_set_alphatestenable(){}{}&nbsp;can greatly improve performance and can be enabled/disabled as required throughout your project code, although they may not be appropriate for all types of graphics or projects.":"这样，所有的子弹都将在同一批次中取出。明智地使用函数{}{}gpu_set_blendenable(){}{}， {}{}gpu_set_alphatestref(){}{}，和{}{}gpu_set_alphatestenable(){}{} 可以极大地提高性能，并且可以在整个项目代码中根据需要启用/禁用它们，尽管它们可能不适用于所有类型的图形或项目。",
    "In {}GameMaker{} {}data structures{} have been optimised to be a lot faster than previous GameMaker versions. They still need to be cleaned up (destroyed) when not used to free memory, and they can still be slower than, say, arrays, but the ease of use and the extra functions for dealing with the data they contain can often out-weigh the minimal speed difference, so don\u0027t be afraid to use them in your games.":"在 {}GameMaker{} 中，{}数据结构{}已经过优化，比以前的 GameMaker 版本快得多。 它们在不用于时仍然需要清理（销毁）释放内存，并且它们仍然可能比数组慢，但是易用性和处理它们包含的数据的额外功能通常可以胜过 最小的速度差异，所以不要害怕在游戏中使用它们。",
    "It should be noted that of all the data structures, DS Maps in particular are lighting fast, both to read from and write to, making them an excellent option for all types of tasks.":"应该注意的是，在所有的数据结构中，DS map的读和写速度特别快，这使它们成为所有类型任务的绝佳选择。",
    "Local variables are fast to process in-game, so make the most of them, and if an expression appears in a code block or script two or more times, think about creating a local variable for it. When using the {}YoYo Compiler (YYC){} targets, if you reference {}global{} or instance variables various times in a function or code block it is particularly beneficial to assign them to a local variable at the start of your code and then reference that local variable, as this will give much better performance.":"局部变量在游戏中处理起来很快，所以要充分利用它们，如果一个表达式在代码块或脚本中出现两次或两次以上，考虑为它创建一个局部变量。当使用{}YoYo Compiler (YYC){}目标时，如果在函数或代码块中多次引用{}全局{}或实例变量，那么在代码开始时将它们赋值给一个局部变量，然后再引用该局部变量是非常有益的，因为这将提供更好的性能。",
    "Note that on the non-WebGL HTML5 target, having multi-coloured, fading particles will require a lot of image caching and will be very slow. However, since particle sprites can be animated, you can create an animated sprite that has sub-images which change colour and then use that for the particle instead. It will still look like a gradual colour change, but not require the constant creation of cache images.":"注意，在非webgl的HTML5目标上，拥有多颜色、褪色的粒子将需要大量图像缓存，并且速度会非常慢。然而，因为粒子精灵可以被动画化，你可以创建一个带有改变颜色的子图像的动画精灵，然后将其用于粒子。它看起来仍然像一个渐变的颜色变化，但不需要不断创建缓存图像。",
    "On this page we are going to cover some \"best practices\" when programming your game, and at the same time explain a little bit about the inner workings of {}GameMaker{}. Before continuing, however, it is worth noting two very important points:":"在这一页，我们将介绍一些游戏编程的“最佳实践”，同时解释一下{}GameMaker{}的内部工作原理。然而，在继续之前，有两点值得注意:",
    "Previously we mentioned {}accessors{}&nbsp;for arrays, but they are also available for data structures, which can help clean up your code and make it much easier to read.":"之前我们提到了用于数组的{}访问器{}，但它们也可用于数据结构，这有助于清理您的代码并使其更易于阅读。",
    "So, if you have a number of bullet instances that draw using the {}bm_add{} blend mode - for example - you will be creating a new vertex batch for each one, which is definitely a bad thing! Instead, have a controller object in your game that draws all the bullets instead, like this:":"因此，如果您有许多使用{}bm_add{}混合模式绘制的项目实例—例如—您将为每个实例创建一个新的顶点批处理，这绝对是一件坏事!相反地，在你的游戏中设置一个能够绘制所有子弹的控制器对象，就像这样:",
    "That is not to say that you shouldn\u0027t use these functions, as they can be very handy. However, you should know which ones to use and when, as they all work slightly differently and will have different speeds. Rough rule of thumb is that the {}place_{} functions are faster than the {}instance_{} functions, which are faster than the {}collision_{} and {}point_{} functions, so read the pages in the manual for each of these types of functions and make sure to choose the most appropriate for every situation.":"这并不是说您不应该使用这些函数，因为它们可能非常方便。但是，您应该知道使用哪个和什么时候使用，因为它们的工作方式和速度都略有不同。根据经验，{}place_{}函数比{}instance_{}函数快，{}instance_{}函数又比{}collision_{}和{}point_{}函数快，所以请阅读手册中的每一种类型的函数，并确保选择最适合每种情况的函数。",
    "The memory and resources required to create those local variables are negligible, and are far outweighed by the instant benefit you (or anyone else reading the code later) gets from its clarity. The same idea should be applied to functions too, where you should assign sensible names to the input variables, and use clear formatting and local variables where required to make it as readable as possible.":"创建这些局部变量所需的内存和资源几乎可以忽略不计，而且您(或者稍后阅读代码的任何人)从其清晰性中获得的即时好处远远超过了这些内存和资源。同样的思想也应该应用于函数，在函数中，您应该为输入变量分配合理的名称，并在需要的地方使用明确的格式和局部变量，以使其尽可能具有可读性。",
    "There are many, many {}programming styles{}, and some would argue that theirs is the best one to use, but the truth is that almost any style is fine as long as you are {}consistent {}when using it and it is {}clear {}and {}obvious {}what everything is and does.":"{}有很多很多的{}编程风格，有些人会说他们的风格是最好的，但事实是，几乎任何风格都是可以的，只要你在使用它的时候是{}一致的{}，{}清晰的{}和{}明显的{}。",
    "There are {}multiple ways to deal with collisions{} in {}GameMaker{}, and most of them come with a bit of extra CPU overhead attached. The {}collision_{} and {}point_{} functions, {}place_{} functions, and {}instance_{} functions all rely on {}bounding box{} checks with all instances of a given type within the room, and while there is some optimisation built in to the engine to limit these checks, collisions are never the most effecient thing to deal with. If you start to use precise collisions, performance will also get noticably worse, as not only will you be doing bounding box checks, but you will also be doing per-pixel checks, which is very slow indeed.":"{2}GameMaker{3} 中有{}多种处理碰撞的方法{}，其中大多数都附带了一些额外的 CPU 开销。 {}collision_{} 和 {}point_{} 函数、{}place_{} 函数和 {}instance_{} 函数都依赖于对房间内给定类型的所有实例进行的{}边界框{}检查，并且 虽然引擎内置了一些优化来限制这些检查，但碰撞从来都不是最有效的处理方法。 如果您开始使用精确碰撞，性能也会明显变差，因为您不仅会进行边界框检查，还会进行逐像素检查，这确实非常慢。",
    "This allocates the memory for it in one \"chunk\" with all array values being set to the default value of 0 and helps keep things fast, as otherwise every time you add a new value to the array the entire memory has to be re-allocated again.":"这将在一个“块”中为它分配内存，并将所有数组值设置为默认值0，这有助于保持速度，否则每次向数组添加新值时，整个内存都必须重新分配。",
    "This function can be called before you create a surface to disable the depth buffer generation, and all surfaces created afterwards will not have a depth buffer created for them. You can enable/disable this function as required, and can even call it once at the start of the game to disable depth buffers for all subsequent surface calls (and in most 2D games this is fine). It won\u0027t give a major performance boost, but it\u0027s certainly something to keep in mind if your game relies heavily on surfaces and might stop your game running out of memory on lower-specced devices.":"这个函数可以在创建曲面之前调用，以禁用深度缓冲区生成，并且之后创建的所有曲面都不会为它们创建深度缓冲区。你可以根据需要启用/禁用这个功能，甚至可以在游戏开始时调用它一次，为所有后续的表面调用禁用深度缓冲(在大多数2D游戏中这是可以的)。它不会给你带来很大的性能提升，但如果你的游戏严重依赖于表面，这肯定是你需要记住的，可能会防止你的游戏在低规格设备上耗尽内存。",
    "This is a {}guide{}, and not the be-all-and-end-all-definitive-100%-perfect method to write your game! The things mentioned here are generally more on the organisational and micro-optimisation scale and should be incorporated into your programming habits when you feel comfortable with GML and think that they are appropriate.":"这是一个{}指南{}，而不是编写游戏的100%完美的方法!这里提到的东西通常更多地是在组织和微观优化的范围内，当您对GML感到舒服并认为它们是合适的时候，应该将它们纳入到您的编程习惯中。",
    "Tile Collisions In {}GameMaker{}":"GameMaker中的瓷砖碰撞",
    "Vertex information is sent in \"batches\" to the GPU for drawing, and in general the larger the batch the better. So \"breaking\" the batch should be avoided when drawing, as that will increase the number of vertex batches sent to the GPU. There are a number of things that will break the batch, with the main ones being {}blend modes{}, changing the&nbsp; {}shader{}, changing a uniform for a shader before drawing something, and drawing using&nbsp;the built-in shapes and primitives.":"顶点信息被“批量”发送到GPU进行绘图，通常批量越大越好。所以在绘图时应该避免“中断”批处理，因为这会增加发送到GPU的顶点批处理的数量。有许多事情会打破批处理，其中主要的是{}混合模式{}，改变 {}shader{}，在绘制一些东西之前更改着色器的uniform，以及使用内置的形状和原语进行绘制。",
    "When it comes to writing code everyone has a {}style{}. The style you program in is the way you place your brackets, how you indent the lines, and how you declare and name variables, etc., and is essential to making your code clear and readable to other people (and to your future self, when you have to come back to this project after a time on something else).":"在编写代码时，每个人都有一个{}风格{}。你编程的风格就是你放置方括号的方式，行的缩进方式，以及声明和命名变量的方式等等，这些对于让你的代码清晰可读是必不可少的(当你在其他事情上花费了一段时间后回到这个项目时，对于你未来的自己来说也是必不可少的)。",
    "When you just use surfaces as normal, {}GameMaker{} will actually create a surface and an accompanying depth buffer to ensure proper depth sorting when drawing anything in 3D. However, for most 2D games, this extra depth buffer is just not required and so is taking up extra memory space and processing time that could be used for other things. This is where the function {}{}surface_depth_disable(){}{}&nbsp;comes into play...":"当你只是像普通一样使用表面时，{}GameMaker{}实际上会创建一个表面和一个伴随的深度缓冲区，以确保在3D中绘制任何东西时正确的深度排序。然而，对于大多数2D游戏来说，这种额外的深度缓冲区是不需要的，它会占用额外的内存空间和处理时间，而这些时间本可以用于其他事情。这就是函数{}{}surface_depth_disable(){}{} 发挥作用的地方…",
    "While not completely unreadable, it is inefficient (the {}point_direction(){} function is called twice, for example) and it is messy and awkward to look at. It would be far better expressed as:":"虽然不是完全不可读，但效率很低(例如，point_direction()函数被调用了两次)，而且看起来很混乱，很难看。表述为:",
    "With that said, lets move on and look at some general tips for writing good GML code that you can apply at any time...":"说了这么多，让我们继续，看看编写好的GML代码的一些通用技巧，你可以在任何时候应用这些技巧……",
    "You can also free up the memory associated with an array by setting the variable used to equal 0. So, to clear the array from the code example above you would simply use:":"还可以通过将所用变量设置为0来释放与数组相关的内存。因此，要从上面的代码示例中清除数组，你可以简单地使用:",
    "You can find out more about particles from the page&nbsp;{}Guide To Using Particles{}.":"你可以从{}使用粒子指南{}页面找到更多关于粒子的信息。",
    "don\u0027t be afraid to use the trigonometric functions as (contrary to popular belief) they are pretty fast, especially when compared to particles, collisions, strings, etc...":"不要害怕使用三角函数，因为(与流行的观点相反)它们非常快，特别是与粒子、碰撞、字符串等相比……",
    "don\u0027t put code that is not for drawing things in the Draw events":"不要在绘制事件中放入非用于绘制事物的代码",
    "use an alarm to call any code that doesn\u0027t have to be called every step (rather than just adding this into the Step event anyway)":"使用一个警报来调用任何不需要每一步都调用的代码(而不是将其添加到步事件中)",
    "{}Arrays{} are fast to use and require less memory than data-structures, but they can be optimised further still. When you create an array, memory is allocated to it based on its size, so you should try to initialise an array to its maximum size first, even if you don\u0027t plan on filling it until later on. For example, if you know you need an array to hold a maximum of 100 values, you would initialise it to 100 slots straight away, using the {}{}array_create(){}{}&nbsp;function:":"{}数组{}使用起来很快，比数据结构需要更少的内存，但它们还可以进一步优化。当你创建一个数组时，内存会根据它的大小分配给它，所以你应该先尝试初始化一个数组到它的最大大小，即使你不打算在以后填充它。例如，如果你知道你需要一个数组来保存最多100个值，你可以直接将它初始化为100个槽，使用{}{}array_create(){}{} 函数:",
    "{}Arrays{}{}Arrays{}":"{}Arrays{}{}Arrays{} 数组",
    "{}Collisions{}{}Collisions{}":"{}Collisions{}{}Collisions{} 碰撞",
    "{}Data Structures{}{}Data Structures{}":"{}Data Structures{}{}Data Structures{} 数据结构",
    "{}For texture swaps, the best and most efficient way to do this is to optimise how your sprites and backgrounds are stored on the texture page. This is done from the {}sprite properties{}, and you can create texture pages in the {}Texture Group Editor{}. If you have a number of images that are only used in the main menu (for example), then put them together on a separate {}texture page{}. The same if you have level-specific images, or the player and the enemies, etc. Basically, you want to group them by use so that the swaps are reduced as much as possible. Additionally, to help keep {}VRAM{} optimised you can then use the different {}prefetch and flush{} functions&nbsp;to load and remove textures from memory as required.":"{}对于纹理交换，最好和最有效的方法是优化你的精灵和背景在纹理页面上的存储方式。这是通过{}精灵属性{}完成的，你可以在{}纹理组编辑器{}中创建纹理页面。如果你有一些只在主菜单中使用的图像(例如)，那么把它们放在一个单独的{}纹理页面{}上。如果你有特定关卡的图像，或者玩家和敌人等，也是如此。基本上，您希望按使用对它们进行分组，以便尽可能减少交换。此外，为了帮助保持{}VRAM{}的优化，你可以使用不同的{}预取和刷新{}函数 根据需要从内存中加载和删除纹理。",
    "{}NOTE{}&nbsp;As mentioned at the start of this page, if your game runs fine with a decent FPS then don\u0027t worry too much about texture swaps... especially when creating projects on the desktop targets. These optimisations are best when used with large games or on low-end mobile devices, and when used incorrectly can they actually negatively impact performance.":"{}注意{}正如本文开头所提到的，如果你的游戏运行良好，FPS也不错，那就不用太担心纹理交换了……特别是在桌面目标上创建项目时。这些优化在大型游戏或低端移动设备上使用时效果最好，如果使用不当，它们实际上会对性能产生负面影响。",
    "{}NOTE{}&nbsp;If you don\u0027t require the instance to draw itself when using a controller in this way then you can simply add a comment into the Draw Event to suppress the default drawing, or make the instance invisible (although this will prevent all code running for the instance in all draw events).":"{}注意{} 如果你用这种方式使用控制器时不要求实例绘制自己，那么你可以简单地在绘制事件中添加一个注释来抑制默认的绘制，或者使实例不可见(尽管这将阻止在所有绘制事件中为实例运行所有代码)。",
    "{}NOTE{}&nbsp;On the HTML5 target assigning arrays like this does not apply and your arrays should be initialised from 0 for this target! You can easily handle this by checking the os_browser variable, for example:":"{}注意{} 在HTML5目标上，这样分配数组是不适用的，你的数组应该从0开始初始化这个目标!你可以通过检查os_browser变量轻松地处理这个问题，例如:",
    "{}NOTE{}&nbsp;This doesn\u0027t just apply to using {}bm_add{} - any blending change will break the batch and will give a performance hit.":"{}注意{} 这不仅仅适用于使用{}bm_add{} -任何混合更改都会破坏批处理并会造成性能损失。",
    "{}Particles{} offer a very quick and efficient way to create dynamic effects in your game, and in general they give good performance. However, it\u0027s worth noting that using additive blending, alpha blending and colour blending on the particles may lower that performance, especially on mobile targets, so if you don\u0027t need it don\u0027t use it! Additive blending, in particular, can greatly increase the vertex batches and should be used with care.":"{}粒子{}提供了在游戏中创建动态效果的一种非常快速有效的方法，通常它们具有良好的性能。然而，值得注意的是，在粒子上使用添加混合，alpha混合和颜色混合可能会降低性能，特别是在移动目标上，所以如果你不需要它就不要使用它!特别是添加混合，可以大大增加顶点批次，应该谨慎使用。",
    "{}Particles{}{}Particles{}":"{}Particles{}{}Particles{} 粒子",
    "{}Programming Style{}{}Programming Style{}":"{}Programming Style{}{}Programming Style{} 编程风格",
    "{}Surfaces{}{}Surfaces{}":"{}Surfaces{}{}Surfaces{} 表面",
    "{}Texture Swaps And Vertex Batches{}{}Texture Swaps And Vertex Batches{}":"{}Texture Swaps And Vertex Batches{}{}Texture Swaps And Vertex Batches{} 纹理交换和顶点批次",
    "{}The above image is an example of a function declaration in a script to illustrate the above points. You can see that it uses the JSDoc style comments to clearly explain what it all does, and the coding style is consistent, with 4 space indents, underscores used for local vars, logged output, etc...":"上图是一个在脚本中声明函数的例子，用来说明上述几点。您可以看到，它使用JSDoc风格的注释清楚地解释了它所做的一切，并且编码风格是一致的，使用4个空格缩进、用于局部变量的下划线、日志输出等等……",
    "{}Use Local Variables{}{}Use Local Variables{}":"{}Use Local Variables{}{}Use Local Variables{} 使用局部变量",
    "{}When writing code, you should be aware that when compiling your final game, {}GameMaker{} strips out comments, removes unnecessary line breaks and whitespace, substitutes in constant/macro/enum values, and generally compresses your code down as part of the process. This means that you can add as much whitespace around your code as required and you don\u0027t need to worry about keeping your comments short or only using them sparingly.":"{}在编写代码时，您应该注意，在编译您的最终游戏时，{}GameMaker{} 会删除注释、删除不必要的换行符和空格、替换为常量/宏/枚举值，通常压缩你的代码作为过程的一部分。这意味着您可以根据需要在代码周围添加尽可能多的空白，而且您不需要担心保持注释的简短或只少量使用它们。"
}