{
    "\u0013U\uFFFD\u0004\u007Fܛ-\uFFFD\uFFFD1$":"\uFFFDk\uFFFD\uFFFDH\uFFFDǎ1\uFFFD\uFFFD\u000B\uFFFD!\uFFFD\uFFFD\uFFFD\uFFFDq\uFFFD\uFFFD7\uFFFD\uFFFD\uFFFD<c\uFFFD\uFFFD\uFFFD\uFFFDR\uFFFD\uFFFDg\uFFFD?\u0007\uFFFDLko\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDX\uFFFD\u001B\uFFFD*\u0BC5$\uFFFD",
    "Again, all the bits move on one, and that multiples by 2. So, how about a multiple by 4? Easy, we shift everything left by 2, rather than one. So how about 16, or 128? This would require a left shift of 4 bits, or 7 bits respectively. This is incredibly useful; it means we can do simple multiplications by simply moving bits around. To do this, we use the {}left shift{}&nbsp;operator {}&lt;&lt;{}. Here are some examples:":"同样，所有的位都移到1上，然后乘以2。那么，乘以4怎么样？很简单，我们把所有的东西都左移2，而不是1。那么16或128怎么样？这将分别需要左移4位或7位。这是非常有用的;这意味着我们可以通过简单地移动位来完成简单的乘法。为此，我们使用{}左移{}运算符{}&lt;&lt;{}。下面是一些例子：",
    "All the bits in this case have moved to the left by one, making it move from the 3rd bit, to the 4th, and changing the value from 4 to 8. How about a larger number?":"在这种情况下，所有的位都向左移动了一位，使它从第3位移动到第4位，并将值从4更改为8。",
    "As you can see, where there is a 1 in each value, the 1 is kept, and where there is a mix or 0\u0027s and 1\u0027s these are reset to 0. Here\u0027s the truth table for {}AND{}ing:":"正如你所看到的，每个值中有1的地方，1被保留，如果有0和1的混合，这些被重置为0。下面是{}AND{}的真值表：",
    "At the beginning of the computer era, {}binary{} and {}hex{} (hexadecimal) were a way of life, probably because high level languages (such as BASIC) were simply too slow to run. For example, multiplying 32 x 32 might have taken various CPU cycles to achieve using BASIC, but with binary it is done as a single operation in a single CPU cycle.":"在计算机时代的初期，{}二进制{}和{}十六进制{}(十六进制)是一种生活方式，可能是因为高级语言(如BASIC)运行太慢。例如，使用BASIC实现32 x 32可能需要不同的CPU周期，但使用二进制它是在单个CPU周期内完成的单个操作。",
    "Bitwise Operators And Binary":"按位运算符和二进制",
    "Clearing these bits (as we saw above) is simply a matter of using the NOT modifier, like this:":"清除这些位(正如我们上面看到的)只是使用NOT修饰符的问题，如下所示：",
    "Each 1 or 0 represents a single {}bit{} of data, and as you can see this means that in binary, 10 equals 2! Each bit is 2 times the previous value with the first bit being equal to 1. So bit 2 = 2, bit 3 = 4, bit 4 = 8 and so on (as shown below in this {}byte{} table):":"每个1或0代表一个{}位{}的数据，正如你所看到的，这意味着在二进制中，10等于2！每个位都是前一个值的2倍，第一个位等于1。所以位2 = 2，位3 = 4，位4 = 8等等(如下面的{}字节{}表所示)：",
    "Here\u0027s a quick bit of code to align to power of 2 numbers. (1,2,4,8,16 and so on). This can be very useful for memory allocation, or making sure you write data to proper boundaries. In this example, {}_val1{}&nbsp;needs to be aligned to {}_val2{} bytes, where {}_val2{} is a power of 2 number. This little function rounds UP to the next boundary of the desired number.":"这里有一段快速的代码来对齐2的幂。(1，2，4，8，16等等)。这对于内存分配或确保将数据写入正确的边界非常有用。在本例中，{}_val1{}需要与{}_val2{}字节对齐，其中{}_val2{}是2的幂。这个小函数向上舍入到所需数字的下一个边界。",
    "Here\u0027s what\u0027s known as a {}truth table{} for the OR operator:":"下面是OR运算符的{}真值表{}：",
    "How would we do this? Well pretty easily it turns out:":"我们要怎么做呢？很容易就能发现：",
    "If we start doing values outside of the range of a byte (which can store numbers from 0 to 255), it does start to get a little harder to track, however. For example, 217,361 is {}110101000100010001{} in binary. Or, {}1+16+256+etc...{} The rules are the same no matter what the value being expressed is - each number is created from adding multiple bits together.":"如果我们开始处理一个字节范围之外的值(它可以存储从0到255的数字)，但是，它确实开始变得有点难以跟踪。例如，217，361在二进制中是{}110101000100010001{}。或者，{}1+16+256+等.{}无论表示的值是什么，规则都是相同的-每个数字都是通过将多个位相加而创建的。",
    "If we wanted the key to open door 1 and 3, then the key would have the MASK value of 5 (which is 101 in binary). If we perform an {}AND{} of this, and it comes out \"not zero\", then we know that the key can open the door. You could also have keys that opened nothing by having a MASK of 0. See the code below for the actual check:":"如果我们想让钥匙打开门1和3，那么钥匙的MASK值应该是5(二进制中是101)。如果我们执行{}AND{}，结果是\"非零\"，那么我们知道钥匙可以打开门。你也可以通过MASK为0来让钥匙什么也开不了。请参阅下面的代码来进行实际检查：",
    "If we wanted to align to the right, then we\u0027d do the above, but then add 32 to move it into the next tile. Simple. All this makes the whole collision code monumentally faster, and lets you spend the CPU time where you really need it.":"如果我们想向右对齐，那么我们可以执行上面的操作，但是添加32将其移动到下一个图块。很简单。所有这些都使整个冲突代码非常快，并且让您将CPU时间花在真正需要的地方。",
    "It\u0027s obviously harder to see here, but the overflows ripple along until there are no ones in a column.&nbsp;It\u0027s worth noting, that computers can only add (or subtract, multiply or divide) 2 numbers at once.&nbsp;Take {}19 + 19 + 19{}. Being human, we can add all the 9\u0027s together, carry the 2 and then on we go! But computers can\u0027t do that - what they can do is this:{} (19 + 19) + 19{}. So they\u0027ll do each calculation in blocks of 2.":"显然这里很难看到，但溢出会一直蔓延，直到一列中没有溢出为止。 值得注意的是，计算机一次只能对 2 个数字进行加（或减、乘或除）。 取 {}19 + 19 + 19{}。 作为人类，我们可以将所有 9 加在一起，携带 2，然后继续！ 但计算机无法做到这一点 - 它们能做到的是：{}(19 + 19) + 19{}。 因此他们将以 2 为一组进行每次计算。",
    "Just like normal additions, we add numbers together and then we overflow into the next column, but unlike a normal decimal addition, we can only go from 0&nbsp;to 1, not 0 to 9. So adding a {}1+1{} means we overflow into {}10{}. So let\u0027s look at a more complex example.":"就像普通的加法一样，我们把数字加在一起，然后溢出到下一列，但与普通的十进制加法不同，我们只能从0到1，而不是从0到9。所以添加{}1+1{}意味着我们溢出到{}10{}。让我们看一个更复杂的例子。",
    "Let\u0027s look at the most basic binary theory first - how numbers are created. Take a look at this table:":"让我们先来看看最基本的二进制理论--数字是如何产生的。看看这个表：",
    "Let\u0027s say we want a simple animation counter, going from 0 to to 15 (as we have 16 frames of animation).&nbsp;Normally you would do an increment, and then do an {}if{} check to wrap the number, but for this example let\u0027s use the {}AND(&amp;){} operator:":"假设我们想要一个简单的动画计数器，从0到15(因为我们有16帧动画)。通常你会做一个增量，然后做一个{}if{}检查来包装数字，但是在这个例子中，让我们使用{}AND(){}运算符：",
    "Now, aside from being very useful for fast/simple multiplications, it\u0027s also very useful for setting specific bits, without having to figure out the bit value. Let\u0027s say we wanted to set bit 27, what number is that? (67108864 by the way!), well we can use the syntax above to easily set flags like this:":"现在，除了对于快速/简单的乘法非常有用之外，它对于设置特定的位也非常有用，而不必计算位值。假设我们想要设置位27，那是什么数字？(顺便说一下，67108864！)，那么我们可以使用上面的语法来轻松地设置标志如下：",
    "Now, how do we perform mathematical operations on these values?&nbsp;Let\u0027s say you want to store {}true{} or {}false{} as a value. Usually compilers will use an {}INT{} (an {}INT{} is usually defined as a signed 32bit number - signed just means it can a positive or negative value, while unsigned means it can only be positive) and then simply assign it to {}0{} or {}1{}. Having only 2 states, a {}true{} / {}false{} value is ideal to store in a bit, and if we did this we could store 32 {}true{} / {}false{} bits for each {}INT{} rather than just one, since an {}INT{} is made up of 32 bits.":"现在，我们如何对这些值进行数学运算？ 假设您想要将 {}true{} 或 {}false{} 存储为值。 通常编译器会使用 {}INT{}（{}INT{} 通常定义为带符号的 32 位数字 - 带符号仅表示它可以是正值或负值，而无符号表示它只能是正值），然后简单地赋值 将其设置为 {}0{} 或 {}1{}。 由于只有 2 个状态，{}true{} / {}false{} 值非常适合存储在位中，如果我们这样做，我们可以为每个 { 存储 32 个 {}true{} / {}false{} 位 }INT{} 而不仅仅是一位，因为 {}INT{} 由 32 位组成。",
    "Now, let\u0027s take a quick look at how you do division, and why it\u0027s going to be so useful. Division is done by shifting the bits {}right{}&nbsp;using the {}right shift{}&nbsp;operator {}&gt;&gt;{}. Let\u0027s take a simple number - 64 - and divide it by 32:":"现在，让我们快速了解一下如何进行除法，以及为什么它会如此有用。除法是通过使用{}right shift{}运算符{}{}将位{}右移{}来完成的。让我们取一个简单的数字- 64 -并将其除以32：",
    "Now, you might have noticed we\u0027ve used multiple lines of code here (as is so often the case), but this is still only a couple of very fast instructions. But why the 31? Well, as bit 5 is 32, then all the bits below would be 31, and that\u0027s the maximum remainder so that\u0027s what we {}AND{} with (we could also use {}(1 &lt;&lt; 5) - 1{}&nbsp;which would make {}32 - 1 = 31{}). Now, if I were to do this without understanding binary, it would look like this:":"现在，你可能已经注意到我们在这里使用了多行代码(这是经常发生的情况)，但这仍然只是几个非常快的指令。但是为什么是31？嗯，因为第5位是32，那么下面的所有位都是31，这是最大的余数，所以这就是我们{}AND{}的内容(我们也可以使用{}(1 5)- 1{}，这将使{}32 - 1 = 31{})。现在，如果我在不理解二进制的情况下这样做，它看起来像这样：",
    "Okay... so actually this would be bit 26 the way we\u0027ve been describing things so far (as bits have been starting at one), but actually... bits start at bit 0, and go upwards, not at bit 1. So while there are 32 bits in an INTEGER, the bits range from 0 to 31, not 1 to 32. This is actually pretty useful, as we can now set up constants&nbsp;for bit numbers.":"好的，实际上这是第26位，我们到目前为止描述的方式(因为位从1开始)，但实际上.位从0开始，向上，而不是从1开始。因此，虽然INTEGER中有32位，但位的范围是从0到31，而不是1到32。这实际上非常有用，因为我们现在可以为位数设置常数。",
    "Say you have a level with a few doors, and a key for each. How can you easily mark a key for a specific door? Well, normally you\u0027d just assign an ID to the key and the door. So what if you wanted a key to open 2 or 3 doors? Easy. You use a MASK. The door would have a single bit&nbsp;assigned like so:{} &nbsp;":"假设你有一个有几扇门的关卡，每个门都有一把钥匙。你怎么能轻松地为特定的门标记一把钥匙呢？嗯，通常你只会为钥匙和门分配一个ID。那么如果你想要一把钥匙打开2或3扇门呢？很简单。你使用MASK。门会像这样分配一个位：{}",
    "Since 16 is a power of 2, we can reduce that number by 1 and use it as a mask,&nbsp;which we can then use to wrap our counter value. If the counter moves up from 15 to 16, we end up with bit pattern {}10000{}, and if we {}AND{}&nbsp;that with 15 (bit pattern {}01111{}) we end up with {}00000{} (simply zero). This means that the above code is useful for wrapping values within the range of a power of 2.":"由于16是2的幂，我们可以将该数字减少1并将其用作掩码，然后我们可以使用该掩码来包装计数器值。如果计数器从15上升到16，我们最终得到位模式{}10000{}，如果我们{}AND{}与15(位模式{}01111{})，我们最终得到{}00000{}(简单的零)。这意味着上面的代码对于包装2的幂范围内的值很有用。",
    "Since this can be quite a complex concept to grasp and then apply to real-world programming situations, you can find below a series of short examples that could be applied to any game made with {}GameMaker{}.":"由于这可能是一个相当复杂的概念，难以掌握，然后应用于现实世界的编程情况，您可以在下面找到一系列简短的示例，这些示例可以应用于任何使用{}GameMaker{}制作的游戏。",
    "So - {}OR{} ({}|{}), {}AND{}({}&amp;{}), {}NOT{}({}~{}) and {}EOR{}({}^{}) let us manipulate bits with relative ease, allowing us, at the simplest level, to control multiple bits at once. We can obviously use these operations for other things when developing our games, like masking sprites, doing integer {}MOD{} operations (using {}AND{}) or doing nice looping counters.":"因此 - {}OR{} ({}|{})、{}AND{}({}&amp;{})、{}NOT{}({}~{}) 和 {}EOR{}({}^{}）让我们相对轻松地操作位，使我们能够在最简单的层面上同时控制多个位。 显然，我们在开发游戏时可以将这些操作用于其他用途，例如屏蔽精灵、执行整数 {}MOD{} 操作（使用 {}AND{}）或执行良好的循环计数器。",
    "So if we had the number 51 ({}110011{}) what does this do? Well, we get this... {}110011 &amp; 110010{}, which obviously leaves us with {}false{}, as there are lots of bits&nbsp;left after the {}AND{}. If we had 64 ({}1000000{}), then it becomes this... {}1000000 &amp; 0111111{} which {}does{} leave us 0, so it\u0027s {}true{}.":"那么，如果我们有数字 51 ({}110011{})，它会做什么？ 好吧，我们得到了这个...{}110011 &amp; 110010{}，这显然给我们带来了 {}false{}，因为 {}AND{} 之后还剩下很多位。 如果我们有 64 ({}1000000{})，那么它会变成这样...{}1000000 &amp; 0111111{}，这{}确实{}剩下 0，所以它是{}正确的{}。",
    "So let\u0027s say Bit 27 is an active flag, and bit 0 is an exploding flag. How can we set both?":"假设第27位是一个有效标志，第0位是一个爆炸标志，我们如何同时设置这两个标志？",
    "So there you go…. It\u0027s exactly the same. The bits we shift down are simply lost. This is actually really useful, because when dividing down if we need the remainder, there\u0027s an even easier way to get it, which we\u0027ll get to in a moment. But first, let\u0027s take a practical example. I have an X and Y position, and I want to get the grid cell this falls in, where the grid is 32x32 in size. This method allows is to store objects, collisions, flags – all manner of things, and access them very quickly. So here we go:":"这就是了.其中网格大小为32 x32。此方法允许存储对象，冲突，标志-所有类型的东西，并非常快速地访问它们。所以我们开始：",
    "So there you shift the single bit down by 5 (which is the number of shifts required for 32 – look above), which gives us 2. But what happens if here are other bits in there? Well let\u0027s take a look:":"因此，您将单个位向下移动5(这是32所需的移位次数-如上所述)，这使我们得到2。但是如果这里有其他位会发生什么？让我们来看看：",
    "So this happily lets us set and clear any bits we\u0027d like, and it also lets us compress out data structures massively. Compressing data structures is a good thing, because if you use less memory, you get less cache misses, and your code just runs faster. Put it this way, what\u0027s quicker, copying 32Mb&nbsp;or data, or 4Mb? Well, quite clearly 4 is. So if you can pack all yours flags down into a single memory access, this is good!":"所以这让我们很高兴地设置和清除任何我们想要的位，它也让我们大规模地压缩数据结构。压缩数据结构是一件好事，因为如果你使用更少的内存，你会得到更少的缓存未命中，你的代码会运行得更快。这样说吧，复制32 Mb或数据，还是4 Mb，哪个更快？很明显，4是。所以如果你能把所有的标志都打包到一个内存访问中，这很好！",
    "So where there is a value with 2 zeros, it\u0027ll stay zero. The advantage of using bits like this as a {}true{}/{}false{} state, is they you can set several bits as \"flags\" in one operation, something you simply couldn\u0027t do with a normal boolean value. For example, let\u0027s say bit 1 is an \"active\" flag, and bit 3 is a \"visible\" flag. We could set both by doing this:":"因此，如果有一个值有两个零，它将保持为零。使用这样的位作为{}true{}/{}false{}状态的好处是，您可以在一个操作中设置几个位作为\"标志\"，这是您无法使用普通布尔值完成的。例如，假设位1是\"活动\"标志，位3是\"可见\"标志。我们可以通过这样做来设置两者：",
    "So why is this much worse? Well, in order to divide by 32, we have to execute a floating point divide - which obviously takes time, but in order to do the {}mod 32{}, you actually have to do another one! If we were doing this in assembler, we actually get BOTH values in one divide, but you don\u0027t get this in high level languages (well… not very often), and so you have to do all the work twice. This adds up, especially if you\u0027re doing a tight loop with lots of calculations like this. Integer divides using bit shifting&nbsp;as shown above really help optimising your game.":"那么，为什么这更糟糕呢？好吧，为了除以32，我们必须执行一个浮点除法-这显然需要时间，但是为了做{}mod 32{}，你实际上必须做另一个！如果我们在汇编中这样做，我们实际上会在一次除法中得到两个值，但你不会在高级语言中得到这个(嗯.不经常)，所以你必须做所有的工作两次.这加起来，特别是如果你正在做一个紧密的循环与大量的计算像这样.",
    "So, only when there is a bit in each place will it be kept. What this means, is that just as you are able to set multiple flags at once, you can also clear multiple flags at once. For example, let\u0027s take the case above, but this time clear them. We want to clear bits 1 and 3 (giving us the value 5), but in remembering the truth table above, what we want to do is keep all the other bits, and clear bits 1 and 3. This would be a binary \"mask\" of 11111111111111111111111111111010 (32bits). This mask keeps all bits currently set, but clears the two bits we actually want cleared. So if had a value of 1000111011 and I wanted to clear bits 1 and 3 using the mask above, it&nbsp;would end up as this...":"因此，只有当每个位置都有一个位时，它才会被保留。这意味着，正如您可以一次设置多个标志一样，您也可以一次清除多个标志。例如，让我们以上面的情况为例，但这次要清除它们。我们要清除位1和3(给我们值5)，但是在记住上面的真值表时，我们要做的是保留所有其他位，并且清除位1和3。这将是11111111111111111111111010(32位)的二进制\"掩码\"。该掩码保持当前设置的所有位，但是清除了我们实际上想要清除的两个位。所以如果有一个值1000111011，我想用上面的掩码清除第1位和第3位，结果会是这样的。",
    "So, we can do simply bitwise operations, but let\u0027s look at the more complex stuff, starting with the question, how does a computer add? Let\u0027s look at a very simple example: {}1+1{}.":"所以，我们可以做简单的按位运算，但让我们看看更复杂的东西，从问题开始，计算机如何加法？让我们看一个非常简单的例子：{}1+1{}。",
    "So, what if we wanted the remainder? Perhaps this remainder is used as some kind of order flag or something.&nbsp;Whatever the reason, getting a remainder is as simple as doing an {}AND{}:":"那么，如果我们想要余数呢？也许这个余数被用作某种顺序标志或其他东西。不管是什么原因，获得余数就像做{}AND{}一样简单：",
    "So, what\u0027s the faster way to do this? Well, if we use proper power-of-2 tiles, then we have a very simple method that\u0027s also lightning fast. If we are moving right, and we\u0027ve moved into a collision block, then as we know everything is aligned to 32, so we need to also align the sprite to a 32 pixel boundary - preferably the one to the left - so the sprite is moved OUT of the collision. This is really easy, knowing the rules we\u0027ve used above to get the remainder, and knowing how to get the inverse of bits, we can simply do this:":"有什么更快的方法吗？好吧，如果我们使用适当的2的幂瓷砖，那么我们有一个非常简单的方法，也是闪电般的快。如果我们向右移动，我们已经移动到一个碰撞块，那么我们知道一切都对齐32，所以我们还需要将精灵与32像素的边界对齐-最好是左边的边界-这样精灵就被移出了碰撞。这真的很容易，知道了我们上面用来求余数的规则，知道了如何求位的倒数，我们可以简单地这样做：",
    "That\u0027s fine if you want numbers that are a power of 2, but how do we create more complex numbers? Well a single binary number can only store a 0 or 1, and that\u0027s it, so for more complex numbers we need to add bits together. If for example we wanted to make 6, we would add 4 and 2 together like so.":"如果你想要2的幂的数，这很好，但是我们如何创建更复杂的数呢？一个二进制数只能存储0或1，仅此而已，所以对于更复杂的数，我们需要将位加在一起。例如，如果我们想得到6，我们将4和2加在一起，就像这样。",
    "That\u0027s right, that\u0027s ALL that it takes to align to a 32 pixel boundary. By changing the 31 we can align to anything we like – as long as it\u0027s a power of 2. (This is the equivalent of dividing by 32, then multiplying by 32, thereby removing the lower bits.)":"没错，这就是对齐到32像素边界所需的全部内容。通过改变31，我们可以对齐到任何我们喜欢的东西-只要它是2的幂。(这相当于除以32，然后乘以32，从而删除低位。)",
    "The \"{}|{}\" operator is a bitwise {}OR{}, and this means the above instruction {}ORs{} 1 into the value held in the variable {}flags{}. If you remember from earlier, using a 1 will set the first bit. If we wanted to set the second bit, we would do this:":"该\"{}|{}\"运算符是按位的{}OR{}，这意味着上面的指令{}将{}1与变量{}flags{}中的值进行OR。如果你还记得前面的话，使用1将设置第一位。如果我们想设置第二位，我们会这样做：",
    "The answer is definitely \"yes, you should\". While it\u0027s true you can still get some speed ups - and sometimes these can be significant - using binary and hex leads to a better understanding of how the&nbsp;CPU operates and can also lead to writing better code, being able to pack data better, and making some tasks a lot simpler. This page is going to explain a bit about what binary is as well as how it can be used when making your games.":"答案肯定是\"是的，你应该\"。虽然这是真的，你仍然可以得到一些速度提升-有时这些可能是显着的-使用二进制和十六进制导致更好地了解CPU如何运作，也可以导致编写更好的代码，能够更好地打包数据，这一页将解释什么是二进制以及如何在制作游戏时使用它。",
    "The binary calculations that are of most interest to us as programmers&nbsp;are multiplication and division. Computers only multiply in 2s, and to do more it\u0027ll break a number apart, and then add all the results together. Let\u0027s take some very simple examples first. {}4 * 2 = 8{}. Now to multiply by 2 in binary, we {}shift {}all the bits to the LEFT by one. Like this:":"作为程序员，我们最感兴趣的二进制计算是乘法和除法。计算机只在2秒内相乘，要做更多的运算，它会将一个数字分开，然后将所有结果加在一起。让我们先看一些非常简单的例子。{}4 * 2 = 8{}。现在要在二进制中乘以2，我们{}将{}所有位向左移1。像这样：",
    "The last operator we want to look at is \"{}^{}\" {}EOR{} ({}Exclusive OR{}, sometimes called {}XOR{}), this operator flips the bits set in both values. Here\u0027s the {}EOR{} truth table:":"我们要看的最后一个运算符是\"{}^{}\"{}EOR{}({}异或{}，有时称为{}XOR{})，该运算符翻转两个值中设置的位。下面是{}EOR{}真值表：",
    "The others would be something like:{} &nbsp;":"其他的类似于：{}",
    "The {}NOT{} operator is just what it says - {}not{} those bits. Here\u0027s a truth table for {}NOT{}.":"{}NOT{}运算符就是它所说的-{}not{}那些位。这里有一个{}NOT{}的真值表。",
    "These days however, with the power of even a basic PC, you no longer have to worry about this and you can do things the \"long way\", since the speed of the machine and its more complex CPU construction will make up for any short comings this approach has. This is great news of course, since it means that you no longer have to optimise every line of code you write, but if this is the case - should you really care about binary at all?":"然而，如今，即使是一台基本的PC，你也不再需要担心这一点，你可以做\"长路\"的事情，因为机器的速度和更复杂的CPU结构将弥补这种方法所带来的任何短时间的浪费。这当然是一个好消息，因为它意味着你不再需要优化你编写的每一行代码，但如果是这样的话-你真的应该关心二进制吗？",
    "This is a curious one, but incredibly useful. For example, let\u0027s say we want a counter that simply counts from 0 to 1 and back to 0 (toggling between 0 and 1), we could add one and do an {}IF{} to see if it\u0027s gotten to 2, and then reset it back to 1. Or...we could add 1 and then {}AND{} it with 1 (since {}01+01 = 10{}, and {}10 &amp; 01 = 0{}) or we can do this:":"这是一个奇怪的问题，但是非常有用。例如，假设我们想要一个计数器，它可以简单地从0到1再回到0(在0和1之间切换)，我们可以添加1并执行{}IF{}以查看它是否达到2，然后将其重置为1。或者.我们可以添加1，然后{}与{}和1(因为{}01+01 = 10{}，{}10&amp; 01 = 0{})或者我们可以这样做：",
    "This is because 5 is {}00000101{} in binary, and following the rule above, the variable \"flags\" will get both these 2 bits merged with its own. So even if bit 1 was already set, the operation still works and bit 3 will now also be set.":"这是因为5在二进制中是{}00000101{}，并且遵循上述规则，变量\"flags\"将使这2个位与其自身合并。因此，即使位1已经被设置，操作仍然有效，并且位3现在也将被设置。",
    "This is great, but if we had to work this out every time we needed to clear flags, it would become tiresome. What we need is a way to flip bits easily (and preferably without CPU cost). Fortunately there is an easy way of doing this by using the \" {}~{}\" {}NOT{} operator.":"这很好，但是如果我们每次需要清除标志时都要解决这个问题，这会变得很烦人。我们需要的是一种轻松翻转位的方法(最好没有CPU成本)。幸运的是，有一种简单的方法可以通过使用\"{}~{}\"{}NOT{}操作符来实现。",
    "This is true of {}all {}binary numbers, and how the computer makes up any number internally. Let\u0027s take a slightly more complicated number as a further example: 23. The number 23 is actually made up of {}1+2+4+16{} or {}00010111{}. How about a much more complex example: 196? Well, that\u0027s made from {}128+64+4{} or {}11000100{}. So actually it\u0027s not that complex really!":"这适用于{}所有{}二进制数，也适用于计算机如何在内部组成任何数字。让我们举一个稍微复杂一点的数字作为进一步的例子：23。数字23实际上是由{}1+2+4+16{}或{}00010111{}组成的。一个更复杂的例子：196怎么样？嗯，那是由{}128+64+4{}或{}11000100{}组成的。所以实际上它并不那么复杂！",
    "This may look like a lot of code, but if these numbers are constants, the compiler will pre-compile these operations into a single value so that we end up with this as actual code.":"这可能看起来像很多代码，但如果这些数字是常量，编译器将把这些操作预编译成一个值，这样我们就可以得到实际的代码。",
    "This operator makes removing flags very simple, and better yet, it\u0027s usually a compile time optimisation meaning if you\u0027re using a constant number (i.e. not a variable) then the compiler will flip the bits automatically for you. Take this statement where we want to clear bits 1 and 3 again:":"这个操作符使得移除标志变得非常简单，更好的是，它通常是一个编译时优化，这意味着如果你使用常量(即不是变量)，那么编译器将自动为你翻转位。在我们想要再次清除位1和3的地方使用这个语句：",
    "This will actually compile down to just \"{}a &amp; 11111111111111111111111111111010{}\". This makes life pretty simple in terms of clearing flags.":"这实际上将编译为\"{}a &amp; 11111111111111111111010{}\"。这使得清除标志的过程非常简单。",
    "We {}OR{} in 2, because the bit pattern {}00000010{} is equal to 2. So what exactly does the binary {}OR{} operator do? Well, it merges all the bits together into a single value, like this:":"我们在2中{}OR{}，因为位模式{}0000010{}等于2。那么二进制{}OR{}运算符到底做什么呢？它将所有位合并为一个值，如下所示：",
    "What about clearing flags? Well this is where the bitwise \"{}&amp;{}\"&nbsp;{}AND{}&nbsp;operation comes in. When you {}AND{} something, the bits that are set in the mask are kept, while the bits that are clear in the mask, are removed - like this:":"那么清除标志呢？这就是按位\"{}&amp;{}\"{}AND{}操作的用武之地。当您执行{}AND{}操作时，掩码中设置的位将保留，而掩码中清除的位将被删除-如下所示：",
    "What if you wanted to check to see if something was a power of 2? Well, here\u0027s a neat little trick.. This will return {}true{} if the given value&nbsp;is a power of 2:":"如果你想检查某个值是否是2的幂呢？好吧，这里有一个巧妙的小技巧。.如果给定的值是2的幂，这将返回{}true{}：",
    "What this does the first time it\u0027s run is {}0 ^ 1 = 1{}, then the second time {}1 ^ 1 = 0{}, thereby toggling things back and forth from 0 to 1.":"它第一次运行时的情况是{}0 ^ 1 = 1{}，第二次运行时是{}1 ^ 1 = 0{}，从而在0和1之间来回切换。",
    "]\u0010\uFFFD\uFFFD\uFFFDL-\u0001\uFFFD{\uFFFD\uFFFD\u0002\\Bg\uFFFDbQ\uFFFDr\uFFFDW8\u0002vDz\uFFFD\uFFFD_\uFFFD4b\uFFFD\uFFFD":"Q\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDX\u001C\uFFFD\uFFFD\uFFFD\u001Cg\u0001\uFFFDZI\uFFFD\uFFFDeY\b\uFFFDo\uFFFD\uFFFD8\uFFFD\uFFFD\u001F\uFFFD\"\u0013\u0016D\uFFFD0%\u0004\uFFFDt\\\uFFFD\u038B\uFFFD&\uFFFD\u0027\uFFFD-q\u0000L\u0017\u0000\uFFFD\uFFFD\uFFFDEN`78fe\uFFFD\u0003\uFFFD\uFFFD\f\u0000\uFFFDs\uFFFD@\uFFFD\uFFFDB\uFFFD\u0019\uFFFD\uFFFDv\u0014b\uFFFD\uFFFD>\uFFFD\u0005\uFFFD\u00000\uFFFD\uFFFD$!W@\uFFFD\uFFFD(\uFFFD\uFFFDKmt|\uFFFD\uFFFDw\uFFFD\uFFFDq|\uFFFD\u0019\u0007Rm\uFFFDb\uFFFD1\uFFFD",
    "]K\uFFFD\uFFFD\uFFFD\uFFFDc\uFFFDG\uFFFDM\uFFFD\uFFFDL\uFFFD{T\uFFFD\u001E\uFFFDI\uFFFD]\u001Fڂ\uFFFD\u00007\uFFFD(ʢ\uFFFDKe\uFFFD_\uFFFDI\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD":"\fZ\uFFFD\u0013\uFFFD\uFFFD\uFFFDz\u0015\uFFFDڪ9\u0016\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u007F\u007F.\uFFFD\uFFFDa\uFFFDV7\uFFFD\u001D\uFFFD\uFFFD\uFFFD\u0004τ\uFFFDME\u000B\uFFFDj\f\uFFFD\u0014wM\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD:\uFFFD>\uFFFD\uFFFD0\uFFFDn\uFFFD\uFFFD:xH",
    "]\uFFFD\u0027T\u000FAI\uFFFDL\uFFFD\uFFFD\uFFFD(\uFFFD":"",
    "a\uFFFD\uFFFD\uFFFD\u0002\uFFFD\u0012k\uFFFDO\uFFFD\uFFFD8\uFFFD\uFFFD\uFFFD\u0016M\uFFFD\uFFFDȪG\u0004\uFFFDC\uFFFD\u0019\u0014":"\u000B\uFFFD4\uFFFD&_\uFFFDj\uFFFD~\uFFFD\uFFFDK\uFFFD\u001D\uFFFD\u0352\uFFFDk\u001AI\uFFFDz\uFFFD\u001F\uFFFD\u0007Zc\u0013\uFFFD\uFFFD\uFFFDJ\uFFFD7\uFFFD\uFFFD\u000BG\uFFFDf -l`\uFFFD\uFFFD\uFFFDf\uFFFD\uFFFDSȍ\uFFFD\uFFFDo\uFFFD+3s\uFFFD",
    "{}GameMaker{} developers&nbsp;often use the function {}place_free(){}, and then when a collision is found, try to slowly move the object out by either looping around an {}x{} or {}y{} position while continuing to execute that function, or by using the {}move_outside_all(){} function.":"{}GameMaker{} 开发者经常使用函数 {}place_free(){}，然后当发现碰撞时，尝试通过围绕 {}x{} 或 {}y{} 位置循环来缓慢移出对象 继续执行该函数，或使用 {}move_outside_all(){} 函数。",
    "{}Index Alignment{}{}Index Alignment{}":"{}索引对齐{}{}索引对齐{}",
    "{}Keys And Doors{}{}Keys And Doors{}":"{}钥匙和门{}{}钥匙和门{}",
    "{}Looping Counters{}{}Looping Counters{}":"{}循环计数器{}{}循环计数器{}",
    "{}Power Of 2 Check{}{}Power Of 2 Check{}":"{}2次幂校验{}{}2次幂校验{}",
    "{}Tile Alignment{}{}Tile Alignment{}":"{}平铺对齐{}{}平铺对齐{}",
    "{}{}NOTE{}{}&nbsp;To write binary literals in GML, prefix them with {}0b{}&nbsp;(e.g. {}0b0010{}). See&nbsp;{}Data Types{}&nbsp;for more information.":"{}{}注意{}{}要在GML中写入二进制文字，请在其前面加上{}0b{}(例如{}0b0010{})。有关详细信息，请参阅{}数据类型{}。",
    "\uFFFD\u0016\u0014\uFFFD\uFFFD?\uFFFD\u02D2\uFFFD\u0018\uFFFDL\uFFFDP^zc\u000F":"\uFFFDG\uFFFD",
    "\uFFFD\u001C\uFFFD\uFFFDT\uFFFD\uFFFD|0c\uFFFDpQ\uFFFD\u001B@5\u0002\uFFFD\uFFFD":"",
    "\uFFFDH\u0015\uFFFDj\uFFFD\u001F":"_\uFFFD{\uFFFD\uFFFD\u0017\uFFFD\uFFFD\uFFFD\uFFFD=\uFFFD\uFFFD~\u0013\uFFFD\uFFFD8\uFFFD\uFFFDu\uFFFD<琟\uFFFDn\uFFFD\uFFFD?\uFFFD\u0003",
    "\uFFFDd\uFFFD\uFFFDp\uFFFD\u0010y":"\f_\uFFFD\uFFFD\uFFFD\uFFFD\u001D\uFFFD\uFFFD_`&z\u036FPs\uFFFD\uFFFD\uFFFDr\u000E\uFFFD\u000F\uFFFD\u0002\uFFFDƜ&\uFFFDi\uFFFD\uFFFD\uFFFD\uFFFD\u001E\u02BA\uFFFD\uFFFD\uFFFD\uFFFD樼\u0016\uFFFD@f\uFFFD\uFFFD\u0005\\\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDA7\uFFFDOs<\uFFFDO\uFFFD",
    "\uFFFD\uFFFD\u0016\uFFFD\uFFFD\uFFFDw\uFFFDŴ\uFFFDV\uFFFDu":"\u000B\uFFFDb\u074A\uFFFD\u0019VV\u0017\u0005\uFFFD\uFFFD\u000E\u0018\uFFFD\uFFFD",
    "\uFFFD\uFFFDw\uFFFD\uFFFD\uFFFD9\uFFFDr\uFFFD\uFFFD\uFFFDO+\uFFFD\uFFFD>\uFFFD\uFFFDX\uFFFD\uFFFDu\uFFFD\uFFFD\uFFFDF\uFFFD\u001D\uFFFD\\\uFFFD\u001B?v":"jvJ\u0014\u0014\uFFFD\uFFFD\"\uFFFDghΰ\uFFFDT\uFFFD\uFFFD\\\uFFFD\u0016\uFFFD\uFFFD\bw",
    "\uFFFD\uFFFD\uFFFD\u0004Zi\uFFFD\uFFFD\uFFFD2\uFFFD\u0014\uFFFD!":"\uFFFDL1q4\uFFFDb\uFFFD->4\uFFFD\uFFFD\uFFFDiemg\uFFFD\uFFFD\u0017|\uFFFD\uFFFD~\uFFFD\uFFFD\u0004\uFFFD+_\uFFFD\u000E\uFFFD\uFFFD:=\uFFFD?F$\uFFFD\"\uFFFD\u001AMB\uFFFDv$\uFFFD\t\uFFFD\uFFFD\u0013\uFFFD\uFFFDy\uFFFD\uFFFD7\uFFFDM4\tB2{b\uFFFD\uFFFD0\uFFFD\uFFFD[\uFFFDP\u0007\uFFFD*\uFFFD\uFFFDN\uFFFD\uFFFDwI\uFFFD\uFFFD\uFFFDA\\b\uFFFD^)\uFFFDݰ8\uFFFD<d\u001B\u0007F\uFFFDd\uFFFDGgc\uFFFD\uFFFD\f\uFFFD\uFFFDF2\uFFFDt\u0000\uFFFD\uFFFD-\uFFFD\uFFFD\uFFFDYJ0=\uFFFD\uFFFDQ\uFFFDB\uFFFD\\\uFFFD1\uFFFDb\u001B\uFFFD\uFFFD\u0002|\uFFFDrF{"
}