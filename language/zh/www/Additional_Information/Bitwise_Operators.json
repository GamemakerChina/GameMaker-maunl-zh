{
    "Again, all the bits move on one, and that multiples by 2. So, how about a multiple by 4? Easy, we shift everything left by 2, rather than one. So how about 16, or 128? This would require a left shift of 4 bits, or 7 bits respectively. This is incredibly useful; it means we can do simple multiplications by simply moving bits around. To do this, we use the {}left shift{}&nbsp;operator {}&lt;&lt;{}. Here are some examples:":"同样，所有的位都移动到1，然后乘以2。那么乘以4呢?很简单，所有东西向左移2，而不是1。那么16或128呢?这将需要分别左移4位或7位。这是非常有用的;这意味着我们可以通过移动位元来做简单的乘法。为此，我们使用{}左移{}&nbsp;操作符{}<<{}。下面是一些例子:",
    "All the bits in this case have moved to the left by one, making it move from the 3rd bit, to the 4th, and changing the value from 4 to 8. How about a larger number?":"在这种情况下，所有位都向左移动了一个位，使其从第3位移动到第4位，并将值从4改为8。要不要更大的数字？",
    "As you can see, where there is a 1 in each value, the 1 is kept, and where there is a mix or 0\u0027s and 1\u0027s these are reset to 0. Here\u0027s the truth table for {}AND{}ing:":"如您所见，如果每个值中有一个 1，则保留 1，如果有 0 和 1 的混合，这些值将重置为 0。以下是 {}AND{} 的真值表：",
    "At the beginning of the computer era, {}binary{} and {}hex{} (hexadecimal) were a way of life, probably because high level languages (such as BASIC) were simply too slow to run. For example, multiplying 32 x 32 might have taken various CPU cycles to achieve using BASIC, but with binary it is done as a single operation in a single CPU cycle.":"在计算机时代初期，{}binary{}(二进制) 和 {}hex{}（十六进制）是一种生活方式，可能是因为高级语言（例如 BASIC）运行速度太慢。 例如，使用 BASIC 乘以 32 x 32 可能需要多个 CPU 周期才能实现，但对于二进制，它是在单个 CPU 周期中作为单个操作完成的。",
    "Bitwise Operators And Binary":"位运算和二进制",
    "Clearing these bits (as we saw above) is simply a matter of using the NOT modifier, like this:":"清除这些位(如上所述)只需使用NOT修饰符，如下所示:",
    "Each 1 or 0 represents a single {}bit{} of data, and as you can see this means that in binary, 10 equals 2! Each bit is 2 times the previous value with the first bit being equal to 1. So bit 2 = 2, bit 3 = 4, bit 4 = 8 and so on (as shown below in this {}byte{} table):":"每个1或0代表一{}位(bit){}的数据，正如您所看到的，这意味着在二进制中，10等于2! 每个位是前一个值的2倍，第一个位等于1。所以 比特 2 = 2， 比特 3 = 4，比特 4 = 8，以此类推(如下面的{}字节(byte){}表所示):",
    "Here\u0027s a quick bit of code to align to power of 2 numbers. (1,2,4,8,16 and so on). This can be very useful for memory allocation, or making sure you write data to proper boundaries. In this example, {}_val1{}&nbsp;needs to be aligned to {}_val2{} bytes, where {}_val2{} is a power of 2 number. This little function rounds UP to the next boundary of the desired number.":"这里有一段快速代码，用于对齐 2 的幂。 （1、2、4、8、16 等）。 这对于内存分配或确保将数据写入正确的边界非常有用。 在此示例中，{}_val1{}需要与 {}_val2{} 字节对齐，其中 {}_val2{} 是 2 的幂数。 这个小函数向上舍入到所需数字的下一个边界。",
    "Here\u0027s what\u0027s known as a {}truth table{} for the OR operator:":"以下是 OR 运算符的{}真值表{}：",
    "How would we do this? Well pretty easily it turns out:":"我们该怎么做呢? 很容易就会发现:",
    "If we start doing values outside of the range of a byte (which can store numbers from 0 to 255), it does start to get a little harder to track, however. For example, 217,361 is {}110101000100010001{} in binary. Or, {}1+16+256+etc...{} The rules are the same no matter what the value being expressed is - each number is created from adding multiple bits together.":"但是，如果我们开始处理字节范围之外的值(可以存储从0到255的数字)，跟踪就会变得有点困难。例如，217,361的二进制格式是{}1101010001000100010001{}。或者,{}1 + 16 + 256 +等等……{}无论要表示的值是什么，规则都是一样的 --每个数字都是由多个位相加而成。",
    "If we wanted the key to open door 1 and 3, then the key would have the MASK value of 5 (which is 101 in binary). If we perform an {}AND{} of this, and it comes out \"not zero\", then we know that the key can open the door. You could also have keys that opened nothing by having a MASK of 0. See the code below for the actual check:":"如果我们想让钥匙打开门1和3，那么钥匙的蒙版值将为5(二进制值为101)。如果我们执行这个的{}AND{}，结果是\"非零\"，那么我们就知道这个钥匙可以开门。您也可以通过蒙版为0来拥有不打开任何内容的钥匙。查看下面的代码进行实际检查:",
    "If we wanted to align to the right, then we\u0027d do the above, but then add 32 to move it into the next tile. Simple. All this makes the whole collision code monumentally faster, and lets you spend the CPU time where you really need it.":"如果我们想要向右对齐，那么我们可以执行上面的操作，但添加32将其移动到下一个贴图。简单。所有这些都使整个碰撞代码大大加快，并让您将CPU时间花在真正需要它的地方。",
    "It\u0027s obviously harder to see here, but the overflows ripple along until there are no ones in a column.&nbsp;It\u0027s worth noting, that computers can only add (or subtract, multiply or divide) 2 numbers at once.&nbsp;Take {}19 + 19 + 19{}. Being human, we can add all the 9\u0027s together, carry the 2 and then on we go! But computers can\u0027t do that - what they can do is this:{} (19 + 19) + 19{}. So they\u0027ll do each calculation in blocks of 2.":"此处显然更难看到，但溢出会一直波动，直到列中没有任何数字。值得注意的是，计算机一次只能加（或减、乘或除）2 个数字。以 {} 19 + 19 + 19{}为例，作为人类，我们可以将所有 9 加在一起，带着 2，然后继续！ 但计算机无法做到这一点 - 它们可以做到的是：{} (19 + 19) + 19{}。 所以他们将以 2 个为一组进行每个计算。",
    "Just like normal additions, we add numbers together and then we overflow into the next column, but unlike a normal decimal addition, we can only go from 0&nbsp;to 1, not 0 to 9. So adding a {}1+1{} means we overflow into {}10{}. So let\u0027s look at a more complex example.":"就像普通的加法一样，我们将数字加在一起然后溢出到下一列，但与普通的十进制加法不同的是，我们只能从 0&nbsp;到 1，而不是 0 到 9。因此添加 {}1+1{} 意味着我们溢出到 {}10{}。 那么让我们看一个更复杂的例子。",
    "Let\u0027s say we want a simple animation counter, going from 0 to to 15 (as we have 16 frames of animation).&nbsp;Normally you would do an increment, and then do an {}if{} check to wrap the number, but for this example let\u0027s use the {}AND(&amp;){} operator:":"假设我们想要一个简单的动画计数器，从 0 到 15（因为我们有 16 帧动画）。通常你会做一个增量，然后做一个 {}if{} 检查来包装数字，但是 对于此示例，让我们使用 {}AND(&){} 运算符：",
    "Now, aside from being very useful for fast/simple multiplications, it\u0027s also very useful for setting specific bits, without having to figure out the bit value. Let\u0027s say we wanted to set bit 27, what number is that? (67108864 by the way!), well we can use the syntax above to easily set flags like this:":"现在，除了对于快速/简单的乘法非常有用之外，它对于设置特定的位也非常有用，而不需要计算位值。假设我们要设置位27，那是多少?(顺便说一下，67108864 !)，我们可以使用上面的语法像这样轻松地设置标志:",
    "Now, how do we perform mathematical operations on these values?&nbsp;Let\u0027s say you want to store {}true{} or {}false{} as a value. Usually compilers will use an {}INT{} (an {}INT{} is usually defined as a signed 32bit number - signed just means it can a positive or negative value, while unsigned means it can only be positive) and then simply assign it to {}0{} or {}1{}. Having only 2 states, a {}true{} / {}false{} value is ideal to store in a bit, and if we did this we could store 32 {}true{} / {}false{} bits for each {}INT{} rather than just one, since an {}INT{} is made up of 32 bits.":"现在，我们如何对这些值执行数学运算呢?假设您想将{}true{}或{}false{}存储为值。通常编译器会使用{}INT{} ({}INT{}通常被定义为有符号的32位数 --有符号仅仅意味着它可以是正的或负的值，而无符号意味着它只能是正的)，然后简单地将它赋值给{}0{}或{}1{}。由于只有2个状态，{}true{} / {}false{}值理想地存储在一个位中，如果我们这样做，我们可以为每个{}INT{}存储32个 {}true{} / {}false{} 位，而不是只有一个，因为{}INT{}由32个位组成。",
    "Now, let\u0027s take a quick look at how you do division, and why it\u0027s going to be so useful. Division is done by shifting the bits {}right{}&nbsp;using the {}right shift{}&nbsp;operator {}&gt;&gt;{}. Let\u0027s take a simple number - 64 - and divide it by 32:":"现在，让我们快速看一下如何做除法，以及为什么它会这么有用。除法是通过使用{}右移{}&nbsp;操作符{}>>{}移动位{}右移{}&nbsp;来完成的。让我们取一个简单的数字 -64 -除以32:",
    "Now, you might have noticed we\u0027ve used multiple lines of code here (as is so often the case), but this is still only a couple of very fast instructions. But why the 31? Well, as bit 5 is 32, then all the bits below would be 31, and that\u0027s the maximum remainder so that\u0027s what we {}AND{} with (we could also use {}(1 &lt;&lt; 5) - 1{}&nbsp;which would make {}32 - 1 = 31{}). Now, if I were to do this without understanding binary, it would look like this:":"现在，您可能已经注意到我们在这里使用了多行代码(这是很常见的情况)，但这仍然只是几个非常快速的指令。但为什么是31?因为第5位是32，那么下面的所有位都是31，这就是最大余数所以我们用{}和{}(我们也可以用{}(1 <<5) - 1{}&nbsp;使{}32 - 1 = 31{})。现在，如果我在不理解二进制的情况下做这个，它会是这样的:",
    "Okay... so actually this would be bit 26 the way we\u0027ve been describing things so far (as bits have been starting at one), but actually... bits start at bit 0, and go upwards, not at bit 1. So while there are 32 bits in an INTEGER, the bits range from 0 to 31, not 1 to 32. This is actually pretty useful, as we can now set up constants&nbsp;for bit numbers.":"好吧……所以实际上这应该是26位，就像我们之前描述的那样(因为比特都是从1开始的)，但是实际上…位从位0开始，然后往上走，而不是位1。因此，虽然INTEGER中有32位，但位的范围从0到31，而不是1到32。这实际上是非常有用的，因为我们现在可以为位数设置常数。",
    "Say you have a level with a few doors, and a key for each. How can you easily mark a key for a specific door? Well, normally you\u0027d just assign an ID to the key and the door. So what if you wanted a key to open 2 or 3 doors? Easy. You use a MASK. The door would have a single bit&nbsp;assigned like so:{} &nbsp;":"假设你有一层有几扇门，每扇门都有一把钥匙。如何方便地标记特定门的钥匙?通常你只需要给钥匙和门分配一个ID。那么，如果你想要一把钥匙打开2或3扇门呢?一件容易的事。你使用一个面具。门将有一个位像这样分配:{},",
    "Since 16 is a power of 2, we can reduce that number by 1 and use it as a mask,&nbsp;which we can then use to wrap our counter value. If the counter moves up from 15 to 16, we end up with bit pattern {}10000{}, and if we {}AND{}&nbsp;that with 15 (bit pattern {}01111{}) we end up with {}00000{} (simply zero). This means that the above code is useful for wrapping values within the range of a power of 2.":"由于 16 是 2 的幂，我们可以将该数字减 1 并将其用作掩码，然后我们可以使用它来循环我们的计数器值。 如果计数器从 15 上升到 16，我们以位模式 {}10000{} 结束，如果我们 {}AND{}&nbsp;15（位模式 {}01111{}），我们以 {} 结束 00000{}（简单为零）。 这意味着上面的代码对于将值循环在 2 的幂范围内很有用。",
    "Since this can be quite a complex concept to grasp and then apply to real-world programming situations, you can find below a series of short examples that could be applied to any game made with {}GameMaker{}.":"由于这可能是一个非常复杂的概念，要掌握然后应用到现实世界的编程情况，您可以在下面找到一系列简短的示例，这些示例可以应用于使用 {}GameMaker{} 制作的任何游戏。",
    "So - {}OR{} ({}|{}), {}AND{}({}&amp;{}), {}NOT{}({}~{}) and {}EOR{}({}^{}) let us manipulate bits with relative ease, allowing us, at the simplest level, to control multiple bits at once. We can obviously use these operations for other things when developing our games, like masking sprites, doing integer {}MOD{} operations (using {}AND{}) or doing nice looping counters.":"所以 - {}OR{} ({}|{})、{}AND{}({}&amp;{})、{}NOT{}({}~{}) 和 {}EOR{}({} ^{}) 让我们相对轻松地操作位，允许我们在最简单的级别上一次控制多个位。 在开发游戏时，我们显然可以将这些操作用于其他事情，例如精灵遮罩、执行整数 {}MOD{} 操作（使用 {}AND{}）或执行漂亮的循环计数器。",
    "So if we had the number 51 ({}110011{}) what does this do? Well, we get this... {}110011 &amp; 110010{}, which obviously leaves us with {}false{}, as there are lots of bits&nbsp;left after the {}AND{}. If we had 64 ({}1000000{}), then it becomes this... {}1000000 &amp; 0111111{} which {}does{} leave us 0, so it\u0027s {}true{}.":"那么，如果我们有数字 51 ({}110011{})，它会做什么？ 好吧，我们明白了……{}110011 &amp; 110010{}，这显然给我们留下了 {}false{}，因为在 {}AND{} 之后还有很多位&nbsp;。 如果我们有 64 ({}1000000{})，那么它就变成了这个……{}1000000 &amp; 0111111{} 它{}确实{}给我们留下了 0，所以它是{}true{}。",
    "So let\u0027s look at the most basic binary theory first - how numbers are created. Take a look at this table:":"让我们先来看看最基本的二进制理论 --数字是如何产生的。看看这张表:",
    "So let\u0027s say Bit 27 is an active flag, and bit 0 is an exploding flag. How can we set both?":"所以我们说第27位是一个 active 标志，第0位是一个 exploding 标志。如何同时设置两者?",
    "So there you go…. It\u0027s exactly the same. The bits we shift down are simply lost. This is actually really useful, because when dividing down if we need the remainder, there\u0027s an even easier way to get it, which we\u0027ll get to in a moment. But first, let\u0027s take a practical example. I have an X and Y position, and I want to get the grid cell this falls in, where the grid is 32x32 in size. This method allows is to store objects, collisions, flags – all manner of things, and access them very quickly. So here we go:":"这就是....完全一样。我们向下移动的比特就这样丢失了。这其实很有用，因为在除法的时候如果我们需要余数，还有一种更简单的方法，我们马上就会讲到。但首先，让我们看一个实际的例子。我有一个X和Y的位置，我想要得到它所在的网格单元格，网格的大小是32x32。这种方法允许存储对象, 碰撞, 标志 -所有的东西，并非常快速地访问它们。所以我们开始:",
    "So there you shift the single bit down by 5 (which is the number of shifts required for 32 – look above), which gives us 2. But what happens if here are other bits in there? Well let\u0027s take a look:":"因此，在这里，您将单个位向下移动5(这是32所需的移动数-看上面)，得到2。但是如果这里还有其他的比特呢?让我们来看看:",
    "So this happily lets us set and clear any bits we\u0027d like, and it also lets us compress out data structures massively. Compressing data structures is a good thing, because if you use less memory, you get less cache misses, and your code just runs faster. Put it this way, what\u0027s quicker, copying 32Mb&nbsp;or data, or 4Mb? Well, quite clearly 4 is. So if you can pack all yours flags down into a single memory access, this is good!":"这让我们可以设置和清除我们想要的任何位，也让我们可以大规模地压缩数据结构。压缩数据结构是一件好事，因为如果您使用更少的内存，缓存丢失就会更少，代码运行得更快。这么说吧，哪个更快，复制32mb数据还是4Mb数据?很明显，4是。因此，如果您可以将所有标记打包到一个内存访问中，这是很好的!",
    "So where there is a value with 2 zeros, it\u0027ll stay zero. The advantage of using bits like this as a {}true{}/{}false{} state, is they you can set several bits as \"flags\" in one operation, something you simply couldn\u0027t do with a normal boolean value. For example, let\u0027s say bit 1 is an \"active\" flag, and bit 3 is a \"visible\" flag. We could set both by doing this:":"所以当一个值有两个0时，它将保持为0。使用这样的位作为{}true{}/{}false{}状态的好处是，你可以在一个操作中设置多个位作为“flags”，这是用普通布尔值无法做到的。例如，我们假设位1是一个“active”标志，位3是一个“visible”标志。我们可以通过这样做来设置两者:",
    "So why is this much worse? Well, in order to divide by 32, we have to execute a floating point divide - which obviously takes time, but in order to do the {}mod 32{}, you actually have to do another one! If we were doing this in assembler, we actually get BOTH values in one divide, but you don\u0027t get this in high level languages (well… not very often), and so you have to do all the work twice. This adds up, especially if you\u0027re doing a tight loop with lots of calculations like this. Integer divides using bit shifting&nbsp;as shown above really help optimising your game.":"那么为什么会更糟呢？ 那么，为了除以 32，我们必须执行浮点除法 - 这显然需要时间，但为了执行 {}mod 32{}，您实际上必须执行另一个！ 如果我们在汇编程序中执行此操作，我们实际上会在一次除法中获得两个值，但您不会在高级语言中获得此值（好吧……不经常），因此您必须将所有工作做两次。 这会累加起来，尤其是当您正在执行一个包含大量此类计算的紧密循环时。 如上所示，使用位移位进行整数除法确实有助于优化您的游戏。",
    "So, only when there is a bit in each place will it be kept. What this means, is that just as you are able to set multiple flags at once, you can also clear multiple flags at once. For example, let\u0027s take the case above, but this time clear them. We want to clear bits 1 and 3 (giving us the value 5), but in remembering the truth table above, what we want to do is keep all the other bits, and clear bits 1 and 3. This would be a binary \"mask\" of 11111111111111111111111111111010 (32bits). This mask keeps all bits currently set, but clears the two bits we actually want cleared. So if had a value of 1000111011 and I wanted to clear bits 1 and 3 using the mask above, it&nbsp;would end up as this...":"所以，只有当每个地方都有一个比特时，它才会被保留。 这意味着，就像您可以一次设置多个标志一样，您也可以一次清除多个标志。 例如，让我们以上面的案例为例，但这次清除它们。 我们想清除位 1 和位 3（给我们值 5），但记住上面的真值表，我们要做的是保留所有其他位，并清除位 1 和位 3。这将是一个二进制“掩码” \" 的 1111111111111111111111111111010（32 位）。 此掩码保留当前设置的所有位，但清除我们实际要清除的两个位。 因此，如果值为 1000111011 并且我想使用上面的掩码清除位 1 和位 3，它最终会变成这样......",
    "So, we can do simply bitwise operations, but let\u0027s look at the more complex stuff, starting with the question, how does a computer add? Let\u0027s look at a very simple example: {}1+1{}.":"所以，我们可以做简单的位运算，但让我们看看更复杂的东西，从这个问题开始，计算机如何加？ 我们来看一个非常简单的示例：{}1+1{}。",
    "So, what if we wanted the remainder? Perhaps this remainder is used as some kind of order flag or something.&nbsp;Whatever the reason, getting a remainder is as simple as doing an {}AND{}:":"如果我们想要余数呢?也许这个余数被用作某种顺序标志或其他东西。无论什么原因，获得一个余数就像执行{}AND{}一样简单:",
    "So, what\u0027s the faster way to do this? Well, if we use proper power-of-2 tiles, then we have a very simple method that\u0027s also lightning fast. If we are moving right, and we\u0027ve moved into a collision block, then as we know everything is aligned to 32, so we need to also align the sprite to a 32 pixel boundary - preferably the one to the left - so the sprite is moved OUT of the collision. This is really easy, knowing the rules we\u0027ve used above to get the remainder, and knowing how to get the inverse of bits, we can simply do this:":"那么，更快的方法是什么呢?如果我们使用合适的2次方瓦片，那么我们就有了一个非常简单的方法，而且速度非常快。如果我们向右移动，我们已经移动到一个碰撞块，那么我们知道所有东西都对齐为32，所以我们也需要将精灵对齐为32像素的边界 -最好是左边的一个 -这样精灵就会移出碰撞。这真的很简单，知道了上面我们用来求余数的规则，也知道了如何求位的取反，我们可以简单地这样做:",
    "That\u0027s fine if you want numbers that are a power of 2, but how do we create more complex numbers? Well a single binary number can only store a 0 or 1, and that\u0027s it, so for more complex numbers we need to add bits together. If for example we wanted to make 6, we would add 4 and 2 together like so.":"如果你想要的是2的幂，这没问题，但是我们如何创造更复杂的数呢?一个二进制数只能存储0或1，就是这样，所以对于更复杂的数，我们需要将位相加。例如，如果我们想要6，我们就像这样把4和2相加。",
    "That\u0027s right, that\u0027s ALL that it takes to align to a 32 pixel boundary. By changing the 31 we can align to anything we like – as long as it\u0027s a power of 2. (This is the equivalent of dividing by 32, then multiplying by 32, thereby removing the lower bits.)":"没错，这就是对齐 32 像素边界所需的全部。 通过更改 31，我们可以对齐任何我们喜欢的东西 --只要它是 2 的幂。（这相当于除以 32，然后乘以 32，从而删除低位。）",
    "The \"{}|{}\" operator is a bitwise {}OR{}, and this means the above instruction {}ORs{} 1 into the value held in the variable {}flags{}. If you remember from earlier, using a 1 will set the first bit. If we wanted to set the second bit, we would do this:":"“{}|{}” 运算符是按位{}或(OR){}，这意味着上述指令将 1 与变量{}flags{}中保存的值进行{4} or {5}运算。 如果您还记得之前的内容，使用 1 将设置第一位。 如果我们想设置第二位，我们会这样做：",
    "The answer is definitely \"yes, you should\". While it\u0027s true you can still get some speed ups - and sometimes these can be significant - using binary and hex leads to a better understanding of how the&nbsp;CPU operates and can also lead to writing better code, being able to pack data better, and making some tasks a lot simpler. This page is going to explain a bit about what binary is as well as how it can be used when making your games.":"答案肯定是“是的，你应该”。虽然这是真的，你仍然可以得到一些速度 -有时可能是显著的 -使用二进制和十六进制可以更好地理解CPU如何运行，也可以写更好的代码，能够更好地打包数据，并使一些任务更简单。本文将解释什么是二进制文件，以及如何在制作游戏时使用它。",
    "The binary calculations that are of most interest to us as programmers&nbsp;are multiplication and division. Computers only multiply in 2s, and to do more it\u0027ll break a number apart, and then add all the results together. Let\u0027s take some very simple examples first. {}4 * 2 = 8{}. Now to multiply by 2 in binary, we {}shift {}all the bits to the LEFT by one. Like this:":"作为程序员，我们最感兴趣的二进制计算是乘法和除法。计算机只能乘2次幂，如果要做更多，它会把一个数字拆开，然后把所有结果加在一起。让我们先看一些非常简单的例子。{}4 * 2 = 8{}。现在要在二进制中乘以2，我们{}将{}的所有位左移1。是这样的:",
    "The last operator we want to look at is \"{}^{}\" {}EOR{} ({}Exclusive OR{}, sometimes called {}XOR{}), this operator flips the bits set in both values. Here\u0027s the {}EOR{} truth table:":"我们要查看的最后一个运算符是“{}^{}”{}EOR{}（{}异或{}，有时称为 {}XOR{}），此运算符翻转两个值中设置的位。 这是 {}EOR{} 真值表：",
    "The others would be something like:{} &nbsp;":"其他的应该是:{}",
    "The {}NOT{} operator is just what it says - {}not{} those bits. Here\u0027s a truth table for {}NOT{}.":"位反 {}NOT{} 运算符正如它所说的那样 -{}取反{} 这些位。 这是 {}NOT{} 的真值表。",
    "These days however, with the power of even a basic PC, you no longer have to worry about this and you can do things the \"long way\", since the speed of the machine and its more complex CPU construction will make up for any short comings this approach has. This is great news of course, since it means that you no longer have to optimise every line of code you write, but if this is the case - should you really care about binary at all?":"然而，如今，即使是基本 PC 的能力，您也不必再担心这一点，您可以“长途跋涉”，因为机器的速度及其更复杂的 CPU 结构将弥补这种方法的任何缺点。 这当然是个好消息，因为这意味着您不再需要优化您编写的每一行代码，但如果是这样的话 --您真的应该关心二进制吗？",
    "This is a curious one, but incredibly useful. For example, let\u0027s say we want a counter that simply counts from 0 to 1 and back to 0 (toggling between 0 and 1), we could add one and do an {}IF{} to see if it\u0027s gotten to 2, and then reset it back to 1. Or...we could add 1 and then {}AND{} it with 1 (since {}01+01 = 10{}, and {}10 &amp; 01 = 0{}) or we can do this:":"这是一个奇怪的，但非常有用。 例如，假设我们想要一个简单地从 0 计数到 1 再计数到 0（在 0 和 1 之间切换）的计数器，我们可以加一个并执行 {}IF{} 以查看它是否达到 2，然后 将其重置回 1。或者...我们可以加 1，然后将其与 1 {}AND{}（因为 {}01+01 = 10{}，并且 {}10 &amp; 01 = 0{}）或者我们 可以这样做：",
    "This is because 5 is {}00000101{} in binary, and following the rule above, the variable \"flags\" will get both these 2 bits merged with its own. So even if bit 1 was already set, the operation still works and bit 3 will now also be set.":"这是因为5在二进制中是{}00000101{}，按照上面的规则，变量“flags”将得到这两个位与其自己的位合并。因此，即使位1已经被设置，操作仍然有效，位3现在也将被设置。",
    "This is great, but if we had to work this out every time we needed to clear flags, it would become tiresome. What we need is a way to flip bits easily (and preferably without CPU cost). Fortunately there is an easy way of doing this by using the \" {}~{}\" {}NOT{} operator.":"这很好，但如果我们每次需要清除标志时都必须解决这个问题，那将变得很烦人。 我们需要的是一种轻松翻转位的方法（最好是没有 CPU 成本）。 幸运的是，通过使用“{}~{}”{}NOT{} 运算符，有一种简单的方法可以做到这一点。",
    "This is true of {}all {}binary numbers, and how the computer makes up any number internally. Let\u0027s take a slightly more complicated number as a further example: 23. The number 23 is actually made up of {}1+2+4+16{} or {}00010111{}. How about a much more complex example: 196? Well, that\u0027s made from {}128+64+4{} or {}11000100{}. So actually it\u0027s not that complex really!":"{}所有{}二进制数都是如此，计算机如何在内部组成任何数字也是如此。让我们举一个稍微复杂一点的数字作为进一步的例子:23。数字23实际上是由{}1+2+4+16{}或{}00010111{}组成的。再举一个更复杂的例子:196?这是由{}128+64+4{}或{}11000100{}组成的。所以实际上它没有那么复杂!",
    "This may look like a lot of code, but if these numbers are constants, the compiler will pre-compile these operations into a single value so that we end up with this as actual code.":"这看起来可能有很多代码，但是如果这些数字是常量，编译器将预先将这些操作编译为单个值，这样我们就得到了实际的代码。",
    "This operator makes removing flags very simple, and better yet, it\u0027s usually a compile time optimisation meaning if you\u0027re using a constant number (i.e. not a variable) then the compiler will flip the bits automatically for you. Take this statement where we want to clear bits 1 and 3 again:":"这个运算符使删除标志变得非常简单，而且更好的是，它通常是编译时优化，这意味着如果您使用常量（即不是变量），那么编译器会自动为您翻转这些位。 在我们要再次清除位 1 和位 3 的地方使用此语句：",
    "This will actually compile down to just \"{}a &amp; 11111111111111111111111111111010{}\". This makes life pretty simple in terms of clearing flags.":"这实际上将编译为“{}11111111111111111111111111111010{}”。 就清除标志而言，这使生活变得非常简单。",
    "We {}OR{} in 2, because the bit pattern {}00000010{} is equal to 2. So what exactly does the binary {}OR{} operator do? Well, it merges all the bits together into a single value, like this:":"我们在 2 中进行 {}OR{}，因为位模式 {}00000010{} 等于 2。那么二进制 {}OR{} 运算符到底做了什么？ 好吧，它将所有位合并为一个值，如下所示：",
    "What about clearing flags? Well this is where the bitwise \"{}&amp;{}\"&nbsp;{}AND{}&nbsp;operation comes in. When you {}AND{} something, the bits that are set in the mask are kept, while the bits that are clear in the mask, are removed - like this:":"清除标志呢?这就是 位 和 \"{}&{}\" {}AND{} 运算出现的地方。当你{} AND {}某物时，掩码中设置的位将被保留，而掩码中明确的位将被删除——像这样:",
    "What if you wanted to check to see if something was a power of 2? Well, here\u0027s a neat little trick.. This will return {}true{} if the given value&nbsp;is a power of 2:":"如果你想检查某物是否是 2 的幂怎么办？ 好吧，这里有一个巧妙的小技巧。如果给定值是 2 的幂，这将返回 {}true{}：",
    "What this does the first time it\u0027s run is {}0 ^ 1 = 1{}, then the second time {}1 ^ 1 = 0{}, thereby toggling things back and forth from 0 to 1.":"它第一次运行时的作用是 {}0 ^ 1 = 1{}，第二次运行时是 {}1 ^ 1 = 0{}，从而在 0 和 1 之间来回切换。",
    "{}GameMaker{} developers&nbsp;often use the function {}place_free(){}, and then when a collision is found, try to slowly move the object out by either looping around an {}x{} or {}y{} position while continuing to execute that function, or by using the {}move_outside_all(){} function.":"{}GameMaker{} 开发者通常使用 {}place_free(){} 函数，然后在发现碰撞时尝试通过围绕 {}x{} 或 {}y{} 循环慢慢移出对象 位置，同时继续执行该函数，或使用 {}move_outside_all(){} 函数。",
    "{}Index Alignment{}{}Index Alignment{}":"{}Index Alignment{}{}Index Alignment{} 索引对齐",
    "{}Keys And Doors{}{}Keys And Doors{}":"{}Keys And Doors{}{}Keys And Doors{} 钥匙和门",
    "{}Looping Counters{}{}Looping Counters{}":"{}Looping Counters{}{}Looping Counters{} 循环计数器",
    "{}Power Of 2 Check{}{}Power Of 2 Check{}":"{}Power Of 2 Check{}{}Power Of 2 Check{} 检查2的次方",
    "{}Tile Alignment{}{}Tile Alignment{}":"{}Tile Alignment{}{}Tile Alignment{} 图块对齐",
    "{}{}NOTE{}{}&nbsp;To write binary literals in GML, prefix them with {}0b{}&nbsp;(e.g. {}0b0010{}). See&nbsp;{}Data Types{}&nbsp;for more information.":"{}{}注意{}{} 要用 GML 编写二进制文字，请在它们前面加上 {}0b{}( 例如，{}0b0010{})。有关详细信息，请参阅{}数据类型{}。"
}