{
    "3D Position":"3D Position 3D位置",
    "An example of a single triangle primitive being built is shown in the following code:":"下面的代码显示了构建单个三角形图元的示例:",
    "And here\u0027s a chunk of code which sets up a vertex format compatible with this shader:":"下面是一段代码，它建立了与这个着色器兼容的顶点格式:",
    "And now the associated shader attributes:":"现在是相关的着色器属性:",
    "And the shader code would look something like this:":"着色器代码应该是这样的:",
    "Any primitives that you build are held in a {}vertex buffer{}. This must be created beforehand and then referenced by the functions that are used to build your primitive. The vertex buffer can be re-used as many times as necessary to create different primitives, or it can be \"frozen\" to maintain a specific primitive type for the duration of your game or level (which is the fastest approach, so if you know that a primitive you build will not change then you should always use this option).":"你构建的任何图元都保存在{}顶点缓冲区{}中。这必须事先创建，然后由用于构建图元的函数引用。顶点缓冲区可以根据需要多次重用以创建不同的图元，或者它可以“冻结”以在你的游戏或关卡期间保持特定的图元类型(这是最快的方法，所以如果你知道你所构建的图元不会改变，那么你应该总是使用这个选项)。",
    "As we have already mentioned above, vertex formats are built up by using together the following 5 attribute types (added via the appropriate {}vertex_format_add_*{} function):":"正如我们在上面已经提到的，顶点格式是通过同时使用以下 5 种属性类型构建的（通过适当的 {}vertex_format_add_*{} 函数添加）：",
    "Colour":"Colour 颜色",
    "Guide To Primitives And Vertex Building":"图元和顶点构建指南",
    "Here we have first create&nbsp;our&nbsp;vertex buffer in the Create Event of the instance, then we begin the definition of the different vertices that make up our triangle primitive, giving the position, the colour, and the texture UV coordinate for each of the three points that we want to use. We then end the vertex definition, and we know that the vertex buffer with this vertex data is stored in the variable \"v_buff\".&nbsp;&nbsp;":"在这里，我们首先在实例的创建事件中创建了我们的顶点缓冲区，然后我们开始定义组成我们的三角形图元的不同顶点，为我们想要使用的三个点中的每个点提供位置、颜色和纹理UV坐标。然后结束顶点定义，我们知道包含这个顶点数据的顶点缓冲区存储在变量\"v_buff\"中。",
    "However, if you are only using (for example) a shader to manipulate the position of the vertex, then there would be no need to pass through colour or texture data. In this case you would create your own format as so:":"然而，如果你只是使用(例如)着色器来操作顶点的位置，那么就不需要传递颜色或纹理数据了。在这种情况下，你将创建自己的格式如下:",
    "In general when you start working with 3D, special effects, complex drawing processes or shaders you don\u0027t need not worry too much about the vertex format being used, since {}GameMaker{} will automatically set up and pass through the {}vertex{} data for you. However, sometimes it is necessary to create your own vertex data and format it to suit, especially when you need to boost speed, or wish to pass in extra information. For example the standard vertex format includes an x, y, z 3D position, colour (with alpha), and UV texture coordinates, which, if you were creating it yourself, would look something like:":"一般来说，当您开始使用 3D、特效、复杂的绘图过程或着色器时，您不必太担心所使用的顶点格式，因为 {}GameMaker{} 会自动设置并通过{}顶点 {} 数据。 然而，有时需要创建您自己的顶点数据并对其进行格式化以适应，尤其是当您需要提高速度或希望传递额外信息时。 例如，标准顶点格式包括 x、y、z 3D 位置、颜色（带 alpha）和 UV 纹理坐标，如果您自己创建它，将类似于：",
    "In general you must&nbsp;{}always{}&nbsp;provide position or 3D position as part of the format, but all the others are optional.":"通常情况下，您必须{} 始终 {}提供位置或3D位置作为格式的一部分，但其他所有都是可选的。",
    "In this case {}in_Colour0{} maps to the first {}vertex_format_add_colour(){} and {}in_Colour1{} maps to the second.":"在这种情况下，{}in_Colour0{} 映射到第一个 {}vertex_format_add_colour(){}，{}in_Colour1{} 映射到第二个。",
    "In this example, {}in_myTexcoord{}, {}in_TextureCoord{} and {}in_Something{} map to the three successive texture coordinate attributes defined in the vertex format.":"在此示例中，{}in_myTexcoord{}、{}in_TextureCoord{} 和 {}in_Something{} 映射到顶点格式中定义的三个连续纹理坐标属性。",
    "In total there are five different vertex attributes that you can use when defining a vertex format:":"在定义顶点格式时，总共可以使用五种不同的顶点属性:",
    "Normal":"Normal 法线",
    "Now, how does the shader attribute get matched to the vertex format type? It\u0027s just based on the naming convention:":"现在，shader 属性是如何与顶点格式类型匹配的? 它只是基于变数命名原则:",
    "Now, this might look odd as it seems that we can specify more attribute kinds in our vertex format than we can in the vertex shader. However, in the shader {}Position{} and {}3D Position{} are treated as the {}same {}attribute, except that {}Position{} is expected to have only \"x\" and \"y\" coordinates whereas {}3D Position{} has “x”, “y” and “z” coordinates. So how do you map what\u0027s in your vertex format to how you define attributes in your shader? Let\u0027s start by looking at a typical set of attributes from the default shader:":"现在，这可能看起来很奇怪，因为我们似乎可以在顶点格式中指定比在顶点着色器中更多的属性种类。 但是，在着色器中，{}Position{} 和 {}3D Position{} 被视为{}相同的{}属性，除了 {}Position{} 预计只有“x”和“y”坐标，而 {}3D 位置{}具有“x”、“y”和“z”坐标。 那么如何将顶点格式中的内容映射到着色器中定义属性的方式呢？ 让我们从默认着色器的一组典型属性开始：",
    "One final important point to note when using your own vertex buffers in this way is how it affects the vertex batches that are sent to the GPU. When you create a vertex buffer you are creating the lowest level of graphics data, so when you draw all that happens is that {}GameMaker{} sends your buffer directly to the graphics card. Because of this, if you want better batching, you must work it out yourself and store the things you want to batch inside the same buffer.":"以这种方式使用您自己的顶点缓冲区时要注意的最后一点是它如何影响发送到 GPU 的顶点批次。 创建顶点缓冲区时，您创建的是最低级别的图形数据，因此当您绘制时，{}GameMaker{} 会将您的缓冲区直接发送到显卡。 因此，如果你想要更好的批处理，你必须自己解决并将你想要批处理的东西存储在同一个缓冲区中。",
    "Position":"Position 位置",
    "Primitives&nbsp;And Vertex Formats":"图元和顶点格式",
    "Texture coordinate":"Texture coordinate 纹理坐标",
    "Texture coordinates are handled slightly differently to colour. Basically, anything which isn\u0027t called {}in_Position{}, {}in_Normal{} or one of the {}in_Colour[0 ... ]{} attributes is treated as a texture coordinate. The order they are defined in, in the list of attributes in the shader, is what denotes which attribute in the vertex format they map to. See the following GML example:":"纹理坐标的处理方式与颜色略有不同。 基本上，任何未称为 {}in_Position{}、{}in_Normal{} 或 {}in_Colour[0 ... ]{} 属性之一的都被视为纹理坐标。 它们在着色器的属性列表中定义的顺序表示它们映射到顶点格式中的哪个属性。 请参阅以下 GML 示例：",
    "This guide briefly covers how to build and use {}primitives{} using custom {}vertex formats{} and {}vertex buffers{}.&nbsp;":"本指南简要介绍了如何使用自定义{}顶点格式{}和{}顶点缓冲区{}构建和使用{}图元{}。",
    "We then draw the contents of the vertex buffer in the Draw Event using a shader. This is a very simple example, and is basically how {}GameMaker{} works internally, ie: When you draw a sprite, GameMaker creates a vertex buffer with four vertices creating two triangles (which make a square, also called a \"quad\"), and textures these two triangles with the sprite image. When we draw this sprite, we are submitting the vertex buffer and its contents are drawn to the screen.":"然后我们使用着色器在绘制事件中绘制顶点缓冲区的内容。这是一个非常简单的例子，基本上就是{}GameMaker{}内部工作的方式，例如:当你绘制一个精灵时，GameMaker创建一个顶点缓冲区，四个顶点创建两个三角形(构成一个正方形，也称为“quad”)，并将这两个三角形与精灵图像纹理化。当我们绘制这个精灵时，我们提交了顶点缓冲区，它的内容被绘制到屏幕上。",
    "When adding additional colour attributes to your shader, a number needs to be added to the end of the shader attribute to indicate which particular entry in the vertex format the attribute maps to. Here\u0027s an example - first the vertex format:":"向着色器添加其他颜色属性时，需要在着色器属性的末尾添加一个数字，以指示该属性映射到顶点格式中的哪个特定条目。 这是一个示例 - 首先是顶点格式：",
    "Within the GLSL ES shader, these kinds are recognised using the following 4 attributes:":"在 GLSL ES 着色器中，使用以下4个属性可以识别这些类型:",
    "You can find a full list of all the functions required to create vertex formats, vertex buffers and primitives from the following page:":"您可以从以下页面找到创建顶点格式、顶点缓冲区和图元所需的所有函数的完整列表：",
    "You should note that once you have created your vertex format, the order in which you have defined the vertex attributes&nbsp;{}must be honoured{} when building your {}primitives{}. So, if you have defined a vertex format as position, colour, and texture coordinate, then {}you {}must{} add these attributes to the primitive in the same order otherwise you will get an error{}. Also note that like any other dynamic resource, a vertex format requires memory and therefore should be removed when not needed using the function {}{}vertex_format_delete(){}{}.":"您应该注意，一旦创建了顶点格式，在构建{2}图元{3}时，{}必须遵守{}定义顶点属性的顺序。所以，如果你已经定义了一个顶点格式作为位置，颜色和纹理坐标，那么{}你{}必须{}以相同的顺序将这些属性添加到原语中，否则你将得到一个错误{}。还要注意，像任何其他动态资源一样，顶点格式需要内存，因此在不需要时应该使用函数{}{}vertex_format_delete(){}{}删除顶点格式。",
    "You\u0027ll notice when we submit the vertex buffer for drawing, we supply a primitive type. The type of primitive you use can be a point, a line list&nbsp;or strip, or a triangle list&nbsp;or strip, but you are {}not{} permitted triangle fans since most mobile hardware will not accept that primitive type. Don\u0027t forget to format your vertex buffer correctly for the type of primitive that is going to be used to draw it. For example, drawing a two triangle primitive as a triangle list requires 6 points, but as a triangle strip it only requires 4 points. Which type you use is up to you and will depend on what you are wanting to draw and the effect that you want to achieve.":"你会注意到，当我们提交绘图的顶点缓冲区时，我们提供了一个图元类型。你使用的图元类型可以是一个点，一个行列表或条，或一个三角形列表或条(point,line list or strip,triangle list or strip)，但是{} 不 {}允许使用三角扇形(triangle fans)，因为大量移动硬件不接受这种图元类型。不要忘记为将要用来绘制它的图元类型正确地格式化你的顶点缓冲区。例如，将两个三角形图元绘制为一个三角形列表需要6个点，但作为一个三角扇(triangle strip)只需要4个点。你使用哪种类型是由你自己决定的，这取决于你想要画什么和你想要达到的效果。",
    "{}\"in_Colour\"{} maps to {}{}vertex_format_add_colour(){}{}":"{}\"in_Colour\"{} 映射到 {}{}vertex_format_add_colour(){}{}",
    "{}\"in_Position\"{} maps to {}{}vertex_format_add_position{}/{}_3d(){}{}":"{}\"in_Position\"{} 映射到 {}{}vertex_format_add_position{}/{}_3d(){}{}",
    "{}\"in_TextureCoord\"{} maps to {}{}vertex_format_add_texcoord(){}{}":"{}\"in_TextureCoord\"{} 映射到 {}{}vertex_format_add_texcoord(){}{}",
    "{}NOTE{}: If the contents of the buffer are going to be updated constantly, the buffer would be created, given the vertex data, and then be destroyed again - after it\u0027s been drawn -&nbsp;all in the same step.":"{}注意{}：如果要不断更新缓冲区的内容，则会在给定顶点数据的情况下创建缓冲区，然后再次销毁 - 在绘制之后 - 所有这些都在同一步骤中进行。",
    "{}{}{}{}{} {}Now, things get trickier when you have multiple attributes of the same kind, but things are still based on the same naming convention. We\u0027ll look at supplying additional {}colour{} and {}texture coordinates{} now, as there can only be {}one{} Position and {}one{} Normal attribute in the shader or vertex format, but there&nbsp;{}can{}&nbsp;be multiple colour or texture attributes.":"{}{}{}{}{} {}现在，当您拥有多个同类属性时，事情会变得更加棘手，但事情仍然基于相同的命名约定。 我们现在将考虑提供额外的{}颜色{}和{}纹理坐标{}，因为在着色器或顶点格式中只能有{}一个{}位置和{}一个{}法线属性，但有&nbsp; {}可以{}&nbsp;是多个颜色或纹理属性。"
}