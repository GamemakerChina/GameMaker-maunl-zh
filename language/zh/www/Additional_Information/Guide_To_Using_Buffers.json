{
    "A buffer (in programming) is basically a space within the system memory that is used to store small packets of data for just about anything (for example: data transfer, collisions, colour data etc...). Since it is held in system memory it is very fast to access, and a buffer would generally be used for very short-term storage, like receiving network information before processing it, or for storing a checkpoint in your game (this is explained in the example given further down the page).":"缓冲区(在编程中)基本上是系统内存中的一个空间，用于存储几乎任何东西的小包数据(例如：数据搬迁、碰撞、颜色数据等…)。由于它保存在系统内存中，因此访问速度非常快，缓冲区通常用于非常短期的存储，例如在处理之前接收网络信息，或者用于在游戏中存储检查点(这在页面下方给出的示例中进行了解释)。",
    "A simple example of how a buffer can be used in any {}GameMaker{} game for any platform, is the function {}{}game_save_buffer(){}{}. This function will take a \"snapshot\" of the current game state and save it to a pre-defined buffer, which can then be read from to load the game at that point again.":"如何在任何平台的任何{}GameMaker{}游戏中使用缓冲区的一个简单示例是函数{}{}game_save_buffer(){}{}. 此函数将获取当前游戏状态的\"快照\"并将其保存到预定义的缓冲区，然后可以从中读取以在该点再次加载游戏。",
    "As you can see, you read out information in the same order that you read it into the buffer. For further information on how to add and remove data from the buffer please see the examples given below.":"如您所见，您读出信息的顺序与您读入缓冲区的顺序相同。有关如何从缓冲区中添加和删除数据的更多信息，请参阅下面给出的示例。",
    "Basically, what this means is that alignment will only affect {}where {}things are written to, so if you do a buffer tell after you write something, it\u0027ll return the current write position which immediately follows the data you\u0027ve previously written. Note, however, that if you then write another piece of data, internally the buffer will move the write position along to the next multiple of the alignment size before actually writing the piece of data.":"基本上，这意味着对齐只会影响写入{}内容的{}位置，因此，如果在写入某些内容之后执行缓冲区指令，它将返回当前写入位置，该位置紧跟在您之前写入的数据之后。但请注意，如果随后写入另一个数据片段，则在实际写入数据片段之前，内部缓冲区将沿着对齐大小的下一倍数移动写入位置。",
    "Before writing to the buffer we have set the \"tell\" to the start of the buffer as networking always takes the data from the start of a buffer. We then write the check value (this will be used by the server to determine the type of event to be processed), then the key being used, and then the state of the key (in this case true for pressed). This buffer is then sent as a data packet by the network function. Note that we do not send the whole buffer! We only send the data written, using the buffer_tell function to return the current read/write position of the buffer (remember that writing to the buffer moves the \"tell\" to the end of what has been written). This is simply to avoid sending more bytes than is necessary.":"在写入缓冲区之前，我们已经将\"告诉\"设置为缓冲区的开头，因为网络总是从缓冲区的开头获取数据。然后我们写入校验值(服务器将使用它来确定要处理的事件类型)，然后写入正在使用的键，然后写入键的状态(在本例中，按下时为true)。然后，网络功能将此缓冲区作为封包发送。请注意，我们不发送整个缓冲区！我们只发送写入的数据，使用buffer_tell函数返回缓冲区的当前读/写位置(请记住，写入缓冲区会将\"告诉\"移动到已写入内容的末尾)。这只是为了避免发送比必要更多的字节。",
    "Below we have a couple of examples of how to use buffers in a project:":"下面我们有几个如何在项目中使用缓冲区的示例：",
    "Buffers are written to (and read from) {}sequentially{}, in that one piece of data is written after another, with each piece of data being of a set type. This means that you should ideally be aware of what data you are writing to the buffer at all times. These data types are defined in GML by the following constants:":"缓冲区{}按顺序{}写入(和读取)，因为一条数据被一个接一个地写入，每条数据都是一组类型的。这意味着理想情况下，您应该始终了解您正在向缓冲区写入哪些数据。这些数据类型在GML中由以下常量定义：",
    "Guide To Using Buffers":"使用缓冲区指南",
    "However, if you write another piece of data, also 1 byte in size, {}then {}do a buffer tell, you\u0027ll get an offset of 5 bytes (even though you have only written 2 bytes of data) as the alignment has padded the data to align it with the 4 byte buffer alignment.":"但是，如果您写入另一个数据片段(同样是1字节大小)，{}然后{}执行缓冲区指令，您将得到5字节的偏移量(即使您只写入2字节的数据)，因为对齐方式已填充数据以使其与4字节缓冲区对齐方式对齐。",
    "If you have been reading through this page you will have seen references to the {}byte-alignment {}of a buffer. This basically refers to the position that new data will stored at within a given buffer. How does this work? Well, for a single byte aligned buffer, each piece of data is written to the buffer sequentially, with each new data piece being added directly after the previous. However a 2 byte aligned buffer will write each piece of data to intervals of 2 bytes, so that even if your initial write is 1 byte of data, the next write will be moved to align to two bytes:":"如果您一直在阅读此页面，您将看到对缓冲区{}字节对齐{}的引用。这基本上是指新数据将存储在给定缓冲区中的位置。这是如何工作的？好吧，对于单字节对齐的缓冲区，每条数据都按顺序写入缓冲区，每条新数据直接添加在前一条数据之后。但是，2字节对齐的缓冲区会将每条数据写入2字节的间隔，因此即使您的初始写入是1字节的数据，下一次写入也会移动到对齐为两个字节：",
    "Next we would add a {}Keypress Event{} (for example) in which we will save the current game state to the created buffer:":"接下来我们将添加一个{}键盘事件{}(例如)，我们将在其中将当前游戏状态保存到创建的缓冲区中：",
    "Now, let\u0027s say that we want our client to send data to the server. For that we need to create a buffer \"packet\", and in this example we are going to send a {}Key Press Event{}, like when the player presses {}Left Arrow {}to move around the game. To do this we write the necessary data to the buffer first then send it off:":"现在，假设我们希望我们的客户端将数据发送到服务器。为此，我们需要创建一个缓冲区\"数据包\"，在本例中，我们将发送一个{}按键事件{}，就像玩家按下{}左箭头{}在游戏中移动一样。为此，我们首先将必要的数据写入缓冲区，然后将其发送出去：",
    "So, say you have created a buffer and you want to write information to it, then you would use something like the following code:":"因此，假设您创建了一个缓冲区并想向其写入信息，那么您将使用以下代码：",
    "The above will first set the control variable to {}true {}(so that this is saved when we save the game to the buffer) and then seek to the start of the buffer before writing the current save state into it. Why do we use {}{}buffer_seek(){}{}? Well, as mentioned already on this page, you read and write to a buffer from the last position that data was added to it. This means that if you don\u0027t set the buffer tell back to the start then when you save you will be adding the data into the buffer at the current buffer read/write position.&nbsp;So, we use the function {}buffer_seek(){} to move the tell to the buffer start.":"上面将首先将控制变量设置为{}true{}(以便在我们将游戏保存到缓冲区时保存它)，然后在将当前保存状态写入缓冲区之前查找缓冲区的开头。为什么我们使用{}{}buffer_seek(){}{}? 正如本页已经提到的，您从添加数据的最后一个位置读取和写入缓冲区。这意味着，如果您不将缓冲区告诉设置回开始，那么当您保存时，您将在当前缓冲区读/写位置将数据添加到缓冲区中。因此，我们使用函数{}buffer_seek(){}将告诉移动到缓冲区开始。",
    "The actual code to create a buffer would look something like this:":"创建缓冲区的实际代码如下所示：",
    "The asynchronous event will contain a special temporary DS map {}async_load{} (it is removed from memory at the end of the event automatically) which contains different information depending on the type of incoming data from the network. In this case, we are assuming that the map has been checked and found to be a buffer data packet sent from a client. We now check the first piece of data that is in the buffer to see what kind of event has been sent - in this case the value \"1\" represents a key event, however when coding these things you should define constants to hold these values to simplify things - and then store the key being pressed and its state ({}true{} = pressed, {}false{} = released). This information would then be used to update all the clients with the new status of the sending client player.":"异步事件将包含一个特殊的临时DS映射{}async_load{}(它会在事件结束时自动从内存中删除)，其中包含不同的信息，具体取决于来自网络的传入数据的类型。在这种情况下，我们假设映射已被检查并发现是从客户端发送的缓冲区封包。我们现在检查缓冲区中的第一条数据，看看发送了什么样的事件——在这种情况下，值\"1\"代表一个键事件，但是在编码这些东西时，您应该定义常量来保存这些值以简化事情——然后存储正在按下的键及其状态({}true{}=被按下，{}false{}=被释放)。然后，该信息将用于使用发送客户端播放器的新状态更新所有客户端。",
    "The final thing to add to the controller object is some&nbsp;\"clean up\" code. Buffers are stored in memory and as such if you do not clean up when you are finished with them, you can get memory leaks that will eventually lag and crash your game. So you would probably add a {}Room End Event{} (from the {}Other{} event category) with:":"最后要添加到控制器对象的是一些\"清理\"代码。缓冲区存储在内存中，因此，如果您在完成它们时不清理它们，您可能会遇到内存泄漏，最终会滞后并导致游戏崩溃。因此，您可能会添加{}房间结束事件{}(来自{}其他{}事件类别)：",
    "The first line creates a grow buffer (since we don\u0027t know the final size of the saved data) of 1024 bytes and aligned to 1 byte. A variable is then created to check against and see if the game has been saved or not (this will be used for loading).":"第一行创建一个1024字节的增长缓冲区(因为我们不知道保存数据的最终大小)并与1字节对齐。然后创建一个变量来检查并查看游戏是否已保存(这将用于加载)。",
    "The first thing we need to do is create a new object to control the saving and loading, so you would make one and give it a {}Create Event{}. In this event, you could place the following code:":"我们需要做的第一件事是创建一个新对象来控制保存和加载，因此您可以创建一个并给它一个{}创建事件{}。在这种情况下，您可以放置以下代码：",
    "The first thing we will show is the creation and use of a buffer for the client side of the network connection. This buffer will be used to create small data packets that can then be sent to the server, so in the {}Create Event{} of an instance we would assign a buffer like this:":"我们将展示的第一件事是为网络连接的客户端创建和使用缓冲区。此缓冲区将用于创建小数据包，然后可以将其发送到服务器，因此在实例的{}创建事件{}中，我们将分配如下缓冲区：",
    "The game will then be loaded at the end of the event in which you place the above code.":"游戏将在您放置上述代码的事件结束时加载。",
    "This object can now be placed into a room and on a key press save and load the room state from a buffer.":"现在可以将此对象放置到房间中，然后按一下键保存并从缓冲区加载房间状态。",
    "Those are the buffer types available to you when using {}GameMaker{}, and which one you choose will greatly depend on the use you wish to put it to. For example, a grow buffer would be used for storing a \"snapshot\" of data to create a save game since you do not know the actual amount of data that is going to be placed in it, or a fast buffer would be used when you know that the values you are working with are all between 0 and 255 or -128 and 127, for example when processing {}ARGB{}&nbsp;data from an image.":"这些是使用{}GameMaker{}时可用的缓冲区类型，您选择哪一种将在很大程度上取决于您希望将其用于的用途。例如，增长缓冲区将用于存储数据的\"快照\"以创建保存游戏，因为您不知道将放置在其中的实际数据量，或者当您知道您正在处理的值都在0到255或-128到127之间时，将使用快速缓冲区，例如在处理图像中的{}ARGB{}数据时。",
    "We have now saved the current game state to a buffer. The next step would be to code how to load it, probably in another {}Keypress Event{}:":"我们现在已经将当前游戏状态保存到缓冲区中。下一步将是编写如何加载它的代码，可能在另一个{}键盘事件{}中：",
    "We make the buffer small (256 bytes) - as it is not intended for holding large amounts of data - then&nbsp;we make it a grow buffer to ensure no errors should we need to add more data to be sent at any time, and the alignment is set to one for convenience.":"我们使缓冲区变小(256字节)-因为它不是用来保存大量数据的-然后我们使它成为一个增长缓冲区，以确保如果我们需要在任何时候添加更多要发送的数据，没有错误，并且为了方便起见，对齐设置为一个。",
    "What about receiving the data on the server? The received data packet that must be written into the buffer on the server and then used to update the game. For that we would use the {}Networking Asynchronous Event{} in the network controller object of the server, as this simplified code below shows:":"在服务器上接收数据呢？收到的封包必须写入服务器上的缓冲区，然后用于更新游戏。为此，我们将在服务器的网络控制器对象中使用{}网络异步事件{}，如下面的简化代码所示：",
    "When reading and writing data to a buffer, you do it in \"chunks\"&nbsp;of data defined by their \"data type\". The \"data type\"&nbsp;sets the number of bytes allocated within the buffer for the value being written, and it is essential that you get this correct otherwise you will get some very strange results (or even errors) for your code.":"将数据读写到缓冲区时，您会在由其\"数据类型\"定义的\"数据块\"中执行此操作。\"数据类型\"设置了在缓冲区中为正在写入的值分配的字节数，您必须正确地做到这一点，否则您将为您的代码得到一些非常奇怪的结果(甚至错误)。",
    "When working with the {}GameMaker{} {}networking functions{}, you have to use buffers to create the data packet that is being sent over the network connection. This example intends to show how this is done, but due to the scope of the networking possibilities, it is only designed to show how to use the buffers themselves, and not the full networking system.":"使用{}GameMaker{}{}网络功能{}时，您必须使用缓冲区来创建通过网络连接发送的封包。此示例旨在展示如何做到这一点，但由于网络可能性的范围，它仅旨在展示如何使用缓冲区本身，而不是完整的网络系统。",
    "looking at the example above you can see that you can write different types of data to a buffer at the same time (you are only limited to a specific data type when using the {}fast {}buffer type), and this data will be added into the buffer sequentially (although its actual position in the buffer will depend on its byte-alignment, explained below). This is the same for reading information from the buffer too, and in the case of the example given above, you would read from the buffer in the same order that you wrote the data, checking for the same data type, eg:":"查看上面的示例，您可以看到您可以同时将不同类型的数据写入缓冲区(当使用{}快速{}缓冲区类型时，您仅限于特定的数据类型)，并且这些数据将按顺序添加到缓冲区中(尽管它在缓冲区中的实际位置将取决于它的字节对齐方式，如下所述)。从缓冲区读取信息也是如此，在上面给出的示例中，您将按照写入数据的相同顺序从缓冲区读取信息，检查相同的数据类型，例如：",
    "{}\n          A 16bit floating point number. This can be a positive or negative value within the range of +/- 65504. {}(Not currently supported!){}":"{}\n一个16位浮点数。这可以是+/-65504范围内的正值或负值。{}(当前不支持！){}",
    "{}\n          A 32bit floating point number. This can be a positive or negative value within the range of +/-16777216.":"{}\n32位浮点数。这可以是+/-16777216范围内的正值或负值。",
    "{}\n          A 64bit floating point number.":"{}\n64位浮点数。",
    "{}\n          A 64bit unsigned integer value.{}(Not currently supported by all buffer functions!){}":"{}\n64位无符号整数值。{}(当前并非所有缓冲区函数都支持！){}",
    "{}\n          A boolean value. Can only be either 1 or 0 ({}true{} or {}false{})":"{}\n一个布尔值。只能是1或0({}true{}或{}false{})",
    "{}\n          A buffer of a fixed size in bytes. The size is set when the buffer is created and cannot be changed again.":"{}\n以字节为单位的固定大小的缓冲区。大小在创建缓冲区时设置，不能再次更改。",
    "{}\n          A buffer that will {}grow{} dynamically as data is added. You create it with an initial size (which should be an approximation of the size of the data expected to be stored), and then it will expand to accept further data that overflows this initial size.":"{}\n随着数据的添加，{}将动态增长{}的缓冲区。您使用初始大小创建它(应该是预期存储的数据大小的近似值)，然后它将扩展以接受溢出此初始大小的更多数据。",
    "{}\n          A buffer where the data will {}wrap{}. When the data being added reaches the limit of the buffer size, the overwrite will be placed back at the start of the buffer, and further writing will continue from that point.":"{}\n数据将{}包装{}的缓冲区。当添加的数据达到缓冲区大小的限制时，覆盖将放回缓冲区的开头，并从该点继续进一步写入。",
    "{}\n          A signed, 16bit integer. This can be a positive or negative value from -32,768 to 32,767 (0 is classed as positive).":"{}\n一个有符号的16位整数。这可以是从-32,768到32,767的正值或负值(0被归类为正值)。",
    "{}\n          A signed, 32bit integer. This can be a positive or negative value from -2,147,483,648 to 2,147,483,647 (0 is classed as positive).":"{}\n一个有符号的32位整数。这可以是从-2,147,483,648到2,147,483,647的正值或负值(0被归类为正值)。",
    "{}\n          A signed, 8bit integer. This can be a positive or negative value from -128 to 127 (0 is classed as positive).":"{}\n一个有符号的8位整数。这可以是-128到127之间的正值或负值(0被归类为正值)。",
    "{}\n          An unsigned, 16bit integer. This is a positive value from 0 - 65,535.":"{}\n一个无符号的16位整数。这是从0-65,535的正值。",
    "{}\n          An unsigned, 32bit integer. This is a positive value from 0 to 4,294,967,295.":"{}\n一个无符号的32位整数。这是从0到4,294,967,295的正值。",
    "{}\n          An unsigned, 8bit integer. This is a positive value from 0 to 255.":"{}\n一个无符号的8位整数。这是0到255之间的正值。",
    "{}\n          This is a UTF-8 null terminated (0x00) string. Basically a GameMaker string is dumped in the buffer, and a 0 is put at the end.":"{}\n这是一个UTF-8空终止(0x00)字符串。基本上，GameMaker字符串被转储到缓冲区中，最后放一个0。",
    "{}\n          This is a special \"stripped down\" buffer that is extremely fast to read/write to. However it can only be used with {}{}buffer_u8{}{} data types, and must be 1 byte aligned. (Information on {}data types{} and {}byte alignment{} can be found further down this page).":"{}\n这是一个特殊的\"精简\"缓冲区，读取/写入速度极快。但是，它只能与{}{}buffer_u8{}{}数据类型一起使用，并且必须1字节对齐。(有关{}数据类型{}和{}字节对齐{}的信息可以在此页面下方找到)。",
    "{}\n    That would create a fixed buffer of 16384 bytes and byte-aligned to 2, with the function returning a unique ID value that is stored in a variable for later referencing of this buffer.":"{}\n这将创建一个16384字节的固定缓冲区，并且字节对齐为2，函数返回一个存储在变量中的唯一ID值，以供以后引用此缓冲区。",
    "{}Buffer Checkpoint{}{}Buffer Checkpoint{}":"{}缓冲区检查点{}{}缓冲区检查点{}",
    "{}Buffers are created by allocating a space in the system memory, calculated in&nbsp;{}byte{} {}s{}, which is then reserved for your game as long as your game is running or until you delete the buffer using the appropriate function (you can find all the GML buffer functions listed {}here{}). This means that even when your game is not in focus (for example, on a mobile device when you take a call the game will be put into the background) the buffer will still exist, however if the game is closed or re-started the buffer will be lost.":"{}缓冲区是通过在系统内存中分配一个空间来创建的，该空间以{}字节{}{}{}计算，然后在游戏运行期间为您的游戏保留该空间，或者直到您使用适当的功能删除缓冲区(您可以在{}此处{}找到列出的所有GML缓冲区功能)。这意味着即使您的游戏不在焦点中(例如，在移动设备上，当您接听电话时，游戏将被放入后台)，缓冲区仍然存在，但是如果游戏关闭或重新启动，缓冲区将丢失。",
    "{}GameMaker{} permits the creation of four different buffer types. The reason for this is that buffers are designed to be a highly optimised temporary storage medium, and as such you should create a buffer that is appropriate to the type of data that you wish it to store, otherwise you could get errors or cause a bottleneck in your code. Before explaining this further, let\u0027s look at the four available buffer types (defined as {}constants {}in GML):":"{}GameMaker{}允许创建四种不同的缓冲区类型。其原因是缓冲区被设计为一种高度优化的临时存储介质，因此，您应该创建一个适合您希望其存储的数据类型的缓冲区，否则可能会出现错误或导致代码瓶颈。在进一步解释之前，让我们看一下四种可用的缓冲区类型(在 GML 中定义为{}constants{})：",
    "{}NOTE{}: Restarting the game will not clear or delete the buffer! But it will prevent any further access to the previously created buffer as the ID handle will have been lost, causing a memory leak which will crash your game eventually. So, when re-starting a game, remember to delete any buffers first.":"{}注意{}：重新启动游戏不会清除或删除缓冲区！但它将阻止对先前创建的缓冲区的任何进一步访问，因为ID句柄将丢失，导致内存泄漏，最终会使您的游戏崩溃。因此，当重新开始游戏时，请记住先删除任何缓冲区。",
    "{}NOTE{}: The buffer that is created from the DS map is automatically removed at the end of the Network Asynchronous Event so there is no need to use {}buffer_delete(){} here.":"{}注意{}：从DS映射创建的缓冲区会在网络异步事件结束时自动删除，因此无需在此处使用{}buffer_delete(){}。",
    "{}NOTE{}: This function is very limited and it is designed for the beginner to get a checkpoint system up and running quickly, but more advanced users may prefer to code their own system using the File functions, due to the fact that the game will not save any of the dynamic resources that you can create at run-time like data structures, surfaces, added sprites, etc...":"{}注意{}：这个功能非常有限，它是为初学者设计的，可以让检查点系统快速启动和运行，但是更高级的用户可能更喜欢使用文件函数来编写他们自己的系统，因为游戏不会保存您可以在运行时创建的任何动态资源，如数据结构、表面、添加的精灵等…",
    "{}NOTE{}: This is only for use in the same room, and not for generating complete saved games for after your game has been closed or restarted!":"{}注意{}：这仅适用于在同一房间内使用，而不是在游戏关闭或重新启动后生成完整的保存游戏！",
    "{}Network Buffers{}{}Network Buffers{}":"{}网络缓冲区{}{}网络缓冲区{}",
    "{}So, if your byte-alignment is set to, say, 4 bytes and you write a single piece of data which is 1 byte in size then do a buffer {}tell {}(a tell gets the current position for reading/writing for the buffer), you\u0027ll get an {}offset {}of 1 byte (the offset in this case is the number of bytes from the start of the buffer to the current read/write position).":"{}因此，如果您的字节对齐设置为4字节，并且您写入一段大小为1字节的数据，然后执行缓冲区{}指令{}(指令获取缓冲区读/写的当前位置)，您将获得1字节的{}偏移量{}(本例中的偏移量是从缓冲区开始到当前读/写位置的字节数)。",
    "{}When creating a buffer, you should always try to create it to a size that is appropriate to the type, with the general rule being that it should be created to accommodate the maximum size of data that it is to store, and if in doubt, use a grow buffer to prevent overwrite errors.":"{}创建缓冲区时，应始终尝试将其创建为适合该类型的大小，一般规则是创建缓冲区应适应要存储的最大数据大小，如果有疑问，请使用增长缓冲区以防止覆盖错误。"
}