{
    "A sprite, drawn normally. Parts of this will be \"removed\" so we can see through it.":"一个精灵，正常绘制。其中的一部分将被 \" 删除\"，以便我们可以看穿它。",
    "A {}circle{}, drawn at the mouse position, using the {}bm_eq_subtract{} equation.":"使用 {2}bm_eq_subtract{3} 方程在鼠标位置绘制的 {} 圆 {}。",
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let\u0027s just have a look at the dry technical answer first before we go any further:":"上面我们已经讨论了函数 {}{}gpu_set_blendmode（）{}{}，但现在我们将看看 {}{}gpu_set_blendmode_ext（）{}{}。顾名思义，这是一个用于设置 {}custom {}blend 模式的扩展函数，但这是如何工作的呢？在我们进一步讨论之前，让我们先看一下枯燥的技术答案：",
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode{}{}, but now we are going to look at {}{}gpu_set_blendmode_ext{}{}.":"上面我们讨论了函数 {}{}gpu_set_blendmode{}{}，但现在我们要看看 {}{}gpu_set_blendmode_ext{}{}。",
    "Add both together (the default equation).":"将两者相加 (默认方程)。",
    "Additive blending. Luminosity values of light areas are added.":"添加混合。添加亮区域的亮度值。",
    "And the destination would be like this:":"目的地应该是这样的：",
    "As you already know, both source and destination colours have RGBA components.&nbsp;Each of these components are values between 0 and 1.":"如您所知，源颜色和目标颜色都具有 RGBA 分量。每个分量的值都在 0 到 1 之间。",
    "As you can see, it is multiplying the source and destination RGBAs with their set factors. It then adds them together as per the default {}equation{}.":"正如您所看到的，它将源 RGBA 和目标 RGBA 与其设定因子相乘。然后，它根据默认 {} 方程 {} 将它们加在一起。",
    "As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}.":"如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 {}(128, 255, 64, 255){}。",
    "As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}. You can see how the inclusion of alpha affects this value too:":"如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 {}(128, 255, 64, 255){}。 您还可以看到 alpha 的包含如何影响该值：",
    "BASIC BLEND MODES":"基本混合模式",
    "Basic Blend Modes":"基本混合模式",
    "Before we actually draw something using this blend mode, let\u0027s have a look at how it should look in Photoshop:":"在我们实际使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：",
    "Blend Equations":"混合方程",
    "Blend factors are defined in {}GameMaker{} by a number of GML constants. Each constant is a factor that you can use for the source or destination (or both). The following factors are available:":"混合因子在 {}GameMaker{} 中由许多 GML 常量定义。每个常量都是可用于源或目标 (或两者) 的因子。可以考虑以下因素：",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是{}完全{}正确.)，但{}GameMaker{}有许多内置的混合模式，可以设置来改变这种行为。",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - {}Red{}, {}Green{}, {}Blue{} and {}Alpha{} - and by default they are drawn to the screen using the blend mode {}bm_normal{}.":"混合模式基本上告诉你的游戏将某些东西与事先已经绘制的其他东西混合起来。您绘制到屏幕上的所有内容均由四个组成部分组成 -{} 红色 {}、{} 绿色 {}、{} 蓝色 {} 和 {}Alpha{}- 默认情况下，它们使用混合绘制到屏幕上模式 {}bm_normal{}。",
    "Both the source colour and destination colour contain RGBA ({}Red{}, {}Green{}, {}Blue{} and {}Alpha{}) components, each of which are floating point values between 0 and 1.":"源颜色和目标颜色均包含 RGBA({} 红色 {}、{} 绿色 {}、{} 蓝色 {} 和 {}Alpha{}) 分量，每个分量都是 0 到 1 之间的浮点值。",
    "By default, both the source and destination values are {}added{} together, as the default equation is {}bm_eq_add{}.":"默认情况下，源值和目标值都会 {} 相加 {} 在一起，因为默认方程为 {}bm_eq_add{}。",
    "CREATING YOUR OWN BLEND MODES":"创建您自己的混合模式",
    "Calculating Final Colour":"计算最终颜色",
    "Calculating The Final Pixel":"计算最终像素",
    "Creating Your Own Blend Modes":"创建您自己的混合模式",
    "Denoting Components":"表示组件",
    "Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to that which you may think. The above image was created on a surface cleared to black over a black background, but if we clear the surface to red, we get this instead:":"即使表面的 Alpha 为 0，{}{}颜色分量仍然存在并且会影响所有混合操作{}{}。 因此，绘制到已使用红色（例如）清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能认为的不同效果。 上面的图像是在黑色背景上清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：",
    "Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to what you may think. The above image was created on a surface cleared to black, but if we clear the surface to red, we get this instead:":"即使表面的 Alpha 为 0，{}{} 颜色分量仍然存在并且会影响所有混合操作 {}{}。因此，绘制到已使用红色 (例如) 清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能想到的不同效果。上面的图像是在清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：",
    "Extended Blend Modes":"扩展混合模式",
    "Extended Blend Modes (Factors)":"扩展混合模式 (因子)",
    "First we create a surface and define its room position. Then in the Draw event, we check if the surface doesn\u0027t exist, and then recreate it.":"首先，我们创建一个表面并定义其房间位置。然后在 Draw 事件中，我们检查表面是否不存在，然后重新创建它。",
    "Following the same rule, if you wanted to simply reduce the brightness of a background by 50% then you would have a colour that is 50% red, 50% green and 50% blue, ie: RGB (128, 128, 128). This blend mode is mainly used for drawing shadows, or creating interesting fade out effects.":"按照同样的规则，如果你想简单地将背景的亮度降低50%，那么你就会有一个50%红色，50%绿色和50%蓝色的颜色，即：RGB(128，128，128)。这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。",
    "Guide To Using Blend Modes":"混合模式使用指南",
    "Guide To Using Blendmodes":"Blendmodes使用指南",
    "Here, both values are finally {}added together{}, as the default equation is {}bm_add{}, however you can change that to subtract or to use some other equation (covered later on this page).":"此处，两个值最终会 {} 相加 {}，因为默认方程为 {}bm_add{}，不过您可以更改该方程以进行减法或使用其他方程 (本页稍后介绍)。",
    "Here, we\u0027re drawing a sprite to a {}surface{}, and then drawing a circle that subtracts whatever is in the surface. The surface is then drawn to the screen.":"在这里，我们将精灵绘制到 {} 表面 {}，然后绘制一个圆圈，减去表面中的所有内容。然后将表面绘制到屏幕上。",
    "Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects.":"希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。",
    "Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects. We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。 现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。",
    "How Things Are Drawn":"事物是如何绘制的",
    "If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:":"如果你在现有的圆上再画一个alpha值为0.5的圆，那么在圆外的alpha值为0，在圆间的alpha值为0.25，在较小的圆内的alpha值为0.375：",
    "If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:":"如果你继续在一个alpha值为0的曲面上画一些alpha值为0.5的圆，然后把这个曲面画到房间上，你可以清楚地看到：",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您已经使用{}GameMaker{}一段时间，您几乎肯定会遇到{}混合模式{}，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how to use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您使用 {}GameMaker{} 已有一段时间，那么您几乎肯定会遇到过 {} 混合模式 {}，甚至可能会在您的游戏中使用它们。混合模式是改变某些内容的绘制方式以提供有趣且特定的图形效果的好方法，但是您知道它们如何工作以及如何使用它们吗？这是一个可能令人困惑的主题，因此在本节中，我们希望消除有关混合模式的一些神秘面纱，并使您能够在游戏中充分利用它们。",
    "It\u0027s worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha(){}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won\u0027t cover this function here as it\u0027s explained in depth already in the manual, but it\u0027s worth mentioning just so you know it\u0027s available for use.":"值得一提的是，通过 {}GameMaker{}，您可以使用函数 {}{}gpu_set_blendmode_ext_sepalpha(){}{} 更进一步。 这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。 我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。",
    "It\u0027s worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha{}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won\u0027t cover this function here as it\u0027s explained in depth already in the manual, but it\u0027s worth mentioning just so you know it\u0027s available for use.":"值得一提的是，通过 {}GameMaker{}，您可以使用函数 {}{}gpu_set_blendmode_ext_sepalpha{}{} 更进一步。这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。",
    "Knowing these will help you understand how each factor works, as one factor may use e.g. the {}Rs{} value (source red), but another may use&nbsp;{}Rd{} (destination red), and so on.":"了解这些将帮助您了解每个因素的工作原理，因为一个因素可能会使用例如 {}Rs{} 值 (源红色)，但另一个可能使用 {}Rd{}( 目标红色)，依此类推。",
    "Let\u0027s now look through how each basic blend mode works.":"现在让我们看看每种基本混合模式的工作原理。",
    "Max blending. Similar to additive blending.":"最大混合。类似于添加剂混合。",
    "Normal blending (the default blend mode).":"正常混合 (默认混合模式)。",
    "Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn\u0027t mean you can\u0027t create passable imitations of these effects, or even brand new effects, using them.":"请注意，尽管并非艺术程序使用的所有混合模式都可以在 {}GameMaker{} 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。",
    "Now you know how setting blend modes works and have seen an example of it being used for everyday drawing, let\u0027s look at something abit more complex...":"现在你知道了如何设置混合模式的工作原理，并看到了一个例子，它被用于日常绘图，让我们看看一些更复杂的东西。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在你知道了在GameMaker中使用混合模式的基本原理，它为源图像获取RGB和alpha值(正在绘制的内容)，然后将其与目标的RGB和alpha值混合(也正在绘制)。这种混合是通过将每个像素颜色和alpha的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们来看看{}扩展混合模式{}，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGBA values for the source image (what is being drawn) and it then blends these with the RGBA values of the destination (what is being drawn to).":"现在您已经了解了在 {}GameMaker{} 中使用混合模式的基础知识。它获取源图像 (正在绘制的内容) 的 RGBA 值，然后将这些值与目标图像 (正在绘制的内容) 的 RGBA 值混合。",
    "Now, while that text is correct and explains what blend modes do, it\u0027s not really intuitive... so let\u0027s go into a bit more detail and explain what this is all about.":"现在，虽然文本是正确的，并解释了混合模式的作用，但它并不直观......所以让我们更详细地解释一下这是怎么回事。",
    "OVERVIEW":"概述",
    "One final thing is worth noting about blend modes, and that is how they affect the {}alpha {}component of a colour. When simply drawing to the {}application surface{} or the {}display buffer{}, you don\u0027t really need to take into consideration the destination alpha value as it will {}always {}be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.":"关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的 {}Alpha{} 分量。 当仅绘制到{}应用程序表面{}或{}显示缓冲区{}时，您实际上不需要考虑目标 Alpha 值，因为它{}始终{}为 1。 然而，您自己制作的表面是不同的，因为您可以清除表面以使其具有您希望的从零到一的任何 alpha 值。 这会导致一些有趣的效果，与大多数人的预期相反。",
    "One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we\u0027ll use this blend mode as our test subject since it\u0027s the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour (128, 255, 64, 255) over a background with the colour (64, 128, 255, 255):":"人们使用混合模式的一个问题是可视化结果，所以为了展示它们背后的数学原理，我们将使用这种混合模式作为我们的测试主题，因为它是每个人使用最多的混合模式，我们确切地知道它会带来什么。(128，255，64，255)的颜色的背景上：",
    "One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we\u0027ll use this blend mode as our test subject since it\u0027s the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour {}(128, 255, 64, 255){} over a background with the colour {}(64, 128, 255, 255){}:":"人们在使用混合模式时遇到的问题之一是可视化结果，因此为了展示其背后的数学原理，我们将使用此混合模式作为我们的测试对象，因为它是每个人使用最多的混合模式，并且我们确切地知道会发生什么从中。假设我们在颜色为 {}(64, 128, 255, 255){} 的背景上绘制一个颜色为 {}(128, 255, 64, 255){} 的矩形：",
    "Overview":"概述",
    "Q(+y?>^":"",
    "Reverse subtractive blending. Destination is subtracted from the source.":"反向减法混合。从源中减去目标。",
    "SURFACES AND ALPHA":"曲面和阿尔法",
    "Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the {}bm_normal{} blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:":"假设你有一个表面，每个像素的alpha都是0，然后你用{}bm_normal{}混合模式在上面画一个alpha为0.5的圆。整个表面仍然是alpha 0，但是在圆中alpha实际上是0.25，因为：",
    "Smaller value from source and destination is selected.":"选择源和目标中较小的值。",
    "So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"所以当我们在屏幕上画东西时，我们的图形处理器实际上对每个像素都做了以下操作：",
    "Subtract destination from source.":"从源中减去目的地。",
    "Subtract source from destination.":"从目的地减去源。",
    "Subtractive blending. Source is subtracted from the destination.":"减法混合。从目标中减去源。",
    "Surfaces And Alpha":"表面 和 透明度",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式使用可用的GML常量之一设置，其中有四个用于基本模式：",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are six for basic modes:":"该代码使用 {} 加法 {} 混合模式绘制实例精灵。加法混合模式使用可用的 GML 常量之一进行设置，其中有六个用于基本模式：",
    "The \"Extended Blend Mode\" column shows the factors that are applied to the source and the destination (respectively), and the \"Blend Equation\" column shows the equation used to bring those two values together.":"\"扩展混合模式 \" 列显示 (分别) 应用于源和目标的因子，\"混合方程 \" 列显示用于将这两个值结合在一起的方程。",
    "The background colour in this example is {}(50, 100, 0, 255){}.":"本示例中的背景颜色为 {}(50, 100, 0, 255){}。",
    "The blend factor {}bm_zero{} effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name \"multiply\" for the mode. To use this in {}GameMaker{}, you would simply have something like this in your {}Draw Event{}:":"混合因子{}bm_zero{}有效地将目标颜色从等式中移除(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此该模式的名称为\"乘\"。要在{}GameMaker{}中使用此模式，您只需在{}Draw Event{}中设置如下内容：",
    "The circle will subtract its alpha value from whatever is already in the surface, allowing us to see through it.":"圆将从表面已有的任何内容中减去其 alpha 值，使我们能够看穿它。",
    "The final colour of a pixel is calculated by multiplying each component of the source and destination by a {}factor{}, and then bringing them together according to the set {}equation{}.":"像素的最终颜色是通过将源和目标的每个分量乘以一个 {} 因子 {}，然后根据设置的 {} 方程 {} 将它们组合在一起来计算的。",
    "The following equations are available in&nbsp;{}GameMaker{}, which can be set using&nbsp;{}{}gpu_set_blendequation{}{}:":"{}GameMaker{} 中提供了以下方程，可以使用 {}{}gpu_set_blendequation{}{} 设置：",
    "The four \"basic\" blend modes that {}GameMaker{} has are actually composites of two of these blend factors.":"{}GameMaker{}拥有的四种\"基本\"混合模式实际上是其中两种混合因子的组合。",
    "The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数 {}gpu_set_blendmode_ext{}{}（src， dest）{} 指示用于源颜色和目标颜色的混合模式。新颜色是某个因素乘以来源，另一个因素乘以目的地。这些因素是用这个函数设置的。为了理解这一点，源和目标都具有红色、绿色、蓝色和 alpha 分量。所以 {}source {}is （{}Rs， Gs， Bs， As{}） 和 {}destination {}is （{}Rd， Gd， Bd， Ad{}）。所有值都被认为介于 0 和 1 之间。",
    "The next image was taken from a test project in GameMaker using this exact code:":"下一张图片是使用以下代码从GameMaker的测试项目中拍摄的：",
    "The second column shows you what values each of the R, G, B, A components are multiplied with, when that factor is being used.":"第二列显示使用该因子时，R、G、B、A 各分量乘以的值。",
    "The surface is then drawn in the room at its defined position.":"然后在房间中的定义位置绘制表面。",
    "The {}blend factors{} mentioned above are defined in {}GameMaker{} by a number of GML constants, and each one represents a factor by which the source or destination R, G, B and A values should be multiplied by. The factors available are:":"上述{}混合因子{}在{}GameMaker{}中由多个GML常量定义，每个常量代表源或目标R、G、B和A值应乘以的因子。可用因子包括：",
    "Then it does the following for every single pixel:":"然后它对每个像素执行以下操作：",
    "Then we draw the following to that surface:":"然后我们在该表面上绘制以下内容：",
    "This again uses the same factors as both {}bm_add{} and {}bm_subtract{}, but uses the reverse-subtract equation, so the destination colour is subtracted from the source colour (i.e. background is removed from the foreground).":"这再次使用与 {}bm_add{} 和 {}bm_subtract{} 相同的因子，但使用逆减方程，因此从源颜色中减去目标颜色 (即从前景中移除背景)。",
    "This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果背景图像是RGB值为(100，15，70)，然后绘制一个RGB为(120，25，30)，然后(使用bm_add)矩形的每个像素的最终RGB值将为(220，40，100).注意颜色值不能超过255(或小于0)，所以任何加起来超过255的值都将被箝位到255。",
    "This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of {}built-in blend modes{} that can be set to change this behaviour.":"此混合模式会绘制所有像素，其颜色和 Alpha 值基本保持不变 (不过，在本节后面您将看到这 {} 完全 {} 不正确 ...)，但 {}GameMaker{} 有一个数字可以通过设置来改变此行为的 {} 内置混合模式 {}。",
    "This blend mode is a bit different to the previous one, as it it works on a percentage basis rather than a direct value. This percentage is what will be subtracted from the destination colour (the colour of the pixel being drawn to). To explain this better, let\u0027s look at an example.":"这个混合模式与前一个有点不同，因为它是基于百分比而不是直接值。这个百分比是从目标颜色(正在绘制的像素的颜色)中减去的百分比。为了更好地解释这一点，让我们看一个例子。",
    "This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind bm_max (and the other blend modes) we\u0027ll cover in part two of our article, but all you need to know is that the result will be a more \"saturated\" and brighter colour, without leading to the same pure white brilliance that using {}bm_add{} will cause.":"这种混合模式更难解释，但它基本上是将源颜色乘以源alpha，然后将它们添加到目标颜色值乘以逆源颜色值。bm_max背后的实际数学(以及其他混合模式)我们将在文章的第二部分介绍，但您需要知道的是，结果将是一个更\"饱和\"和更明亮的颜色，而不会导致使用{}BM_add{}将导致的相同的纯白色亮度。",
    "This blend mode multiplies the source colour with its alpha, just like {}bm_normal{}, however it keeps the destination as-is ({}bm_one{}). It then adds both together, resulting in a lighter colour. Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源颜色与其 Alpha 相乘，就像 {}bm_normal{} 一样，但它保持目标原样 ({}bm_one{})。然后将两者加在一起，产生更浅的颜色。请注意，颜色值不能超过 255( 或低于 0)，因此任何加起来超过该值的值都将被限制为 255。",
    "This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve, and then calculating the final pixel value from both using the set equation.":"这种混合是通过将每个像素颜色和 Alpha 的各个分量乘以不同的量来完成的，具体取决于我们希望实现的效果，然后使用设置的方程计算两者的最终像素值。",
    "This can be achieved with the following {}Create{} and {}Draw{} event code:":"这可以通过以下 {}Create{} 和 {}Draw{} 事件代码来实现：",
    "This gives a final pixel colour (96, 192, 159, 192), and will give an image like that shown below:":"这给出了最终的像素颜色（96、192、159、192），并将给出如下所示的图像：",
    "This gives a final pixel colour {}(96, 192, 159, 192){}, and will give an image like that shown below:":"这将给出最终像素颜色 {}(96, 192, 159, 192){}，并给出如下所示的图像：",
    "This is useful for removing parts of an image using a mask, as shown in an example later on this page under \"{}Blend Equations{}\".":"这对于使用遮罩移除部分图像非常有用，如本页后面 \"{} 混合方程 {}\" 下的示例所示。",
    "This means that the way a final pixel colour is calculated is the following: {}(source * factor) + (destination * factor){}.":"这意味着最终像素颜色的计算方式如下：{}( 源 * 因子 )+( 目标 * 因子 ){}。",
    "This mode uses the same factors as {}bm_add{}, however it uses the subtract equation so the source colour is subtracted from the destination colour (i.e. foreground is removed from the background).":"此模式使用与 {}bm_add{} 相同的因子，但它使用减法方程，以便从目标颜色中减去源颜色 (即从背景中移除前景)。",
    "This uses the {}bm_one{} factor for both source and destination colours, so they are not changed at all. Then it makes use of the minimum equation, so that whichever component value is smaller between the source and the destination (for each of R, G, B and A) is used for the final pixel.":"这对源颜色和目标颜色都使用了 {}bm_one{} 因子，因此它们根本不会改变。然后它利用最小方程，以便源和目标 (对于 R、G、B 和 A 中的每一个) 之间较小的分量值用于最终像素。",
    "Through reading this guide, you should already have a basic understanding of what a blend equation is. It controls how the source and destination colours are mixed together, after the factors have been applied.":"通过阅读本指南，您应该已经对什么是混合方程有了基本的了解。它控制应用因素后源颜色和目标颜色如何混合在一起。",
    "Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at bm_normal, which is really:":"是时候看看一个实际的例子了，它是如何在{}GameMaker{}中进行绘图的。为此，我们将看看bm_normal，它实际上是：",
    "Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at the&nbsp;{}bm_normal{}&nbsp;blend mode, which is simply:":"现在我们来看看一个实际示例，了解如何将其结合起来在 {}GameMaker{} 中进行绘图。为此，我们将了解 {}bm_normal{} 混合模式，它很简单：",
    "To illustrate this, we are going to look at drawing using the basic default {}bm_normal{}. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... {}but this is not the case{} and is something that many people think is a \"bug\" in how {}GameMaker{} renders things. However, as you will see, it\u0027s not a bug at all!":"为了说明这一点，我们将使用基本的默认值{}bm_normal{}进行绘制。大多数人认为将表面清除为alpha 0，然后绘制alpha为0.5的东西将给予结果alpha值也为0.5.{}但事实并非如此{}，许多人认为这是{}GameMaker{}渲染事物的\"错误\"。然而，正如你所看到的，这根本不是一个bug！",
    "Use the function {}{}gpu_set_blendmode{}{}&nbsp;to apply a set of blend factors and equation {}at the same time{}, as a \"preset\" blend mode.":"使用函数 {}{}gpu_set_blendmode{}{}{} 同时 {} 应用一组混合因子和方程，作为 \" 预设 \" 混合模式。",
    "Use whichever value is larger.":"使用较大的值。",
    "Use whichever value is smaller.":"使用较小的值。",
    "Using Equations":"使用方程式",
    "Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a {}multiply {}effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:":"使用不同的可用因子，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个类似于Photoshop中使用的{}乘{}效果。我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：",
    "Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, lasers or just about anything that you want to appear to glow or have luminescence.":"使用这种混合模式是获得 \" 霓虹灯发光 \" 外观的好方法，并且最常用于照明效果、激光或任何您想要发光或发光的东西。",
    "We denote the source RGBA as {}(Rs, Gs, Bs, As){} and destination RGBA as {}(Rd, Gd, Bd, Ad){}.":"我们将源 RGBA 表示为 {}(Rs, Gs, Bs, As){}，将目标 RGBA 表示为 {}(Rd, Gd, Bd, Ad){}。",
    "We have seen already how {}bm_normal{} looks - since that\u0027s what everything defaults to! - so let\u0027s continue on to look at the other three in a bit more detail...":"我们已经看到了{}bm_normal{}的外观-因为这是所有默认设置！-所以让我们继续更详细地查看其他三个.",
    "We saw that each of the built-in blend modes applies {}factors{} to the {}source{} and {}destination{} colours. For example, {}bm_add{} multiplies the source with its alpha, and multiplies the destination with 1.":"我们看到每种内置混合模式都会将 {} 因子 {} 应用于 {} 源 {} 和 {} 目标 {} 颜色。例如，{}bm_add{} 将源与其 Alpha 相乘，并将目标与 1 相乘。",
    "We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。",
    "When determining the final colour of a pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}&nbsp;-- basically asking, \"how should I combine the pink and the yellow?\".":"在确定像素的最终颜色时，GameMaker 会根据 {} 混合模式 {} 组合源颜色和目标颜色 - 基本上是在问 \" 我应该如何组合粉色和黄色？\"。",
    "When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it\u0027s components, like this:":"当我们谈论{}source{}时，我们谈论的是正在绘制的像素的颜色和alpha值，而当我们谈论{}destination{}时，我们谈论的是正在绘制的像素的颜色和alpha值。为了使事情更容易，我们可以将源颜色写为它的组件，如下所示：",
    "When you go to draw something, the GPU gets this:":"当你去画东西时，GPU 会得到以下信息：",
    "When {}GameMaker{} goes to draw a pixel there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已有的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}将源颜色和目标颜色联合收割机组合，颜色的每个分量被存储为0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子并且通过将目的地颜色的每个分量乘以某个其它因子并且然后将结果加在一起分量，成分",
    "When {}GameMaker{} goes to draw a pixel, there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). For example, if you\u0027re drawing a pink colour after having drawn a yellow colour at the same pixel, pink is the {}source{}&nbsp;(what you\u0027re drawing), and yellow is the {}destination{} (as it\u0027s already there).":"当 {}GameMaker{} 开始绘制像素时，会存在一个 {} 源颜色 {}( 您要绘制的像素的颜色) 和一个 {} 目标颜色 {}( 我们已经存在于像素中的颜色) 重新绘制)。例如，如果您在同一像素绘制黄色后绘制粉红色，则粉红色是 {} 源 {}( 您正在绘制的内容)，黄色是 {} 目标 {}( 因为它是已经在那了)。",
    "With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes {}(factors), as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"有了这些知识，您就可以开始在游戏中使用混合模式来获得发光的激光、逼真的阴影或饱和的过渡效果，但这里还有更多东西需要学习！下面我们将了解 {} 扩展混合模式 {}( 因子)，并探讨其背后的一些数学知识，以便您可以创建自己的混合效果，例如相乘或叠加。",
    "With {}{}gpu_set_blendmode_ext{}{}, you can {}manually set the factors{} for the source and destination colours, separately. This gives you a ton more options to draw your pixels, as you can now manually choose what the source multiplies with, and then what the destination multiplies with.":"通过 {}{}gpu_set_blendmode_ext{}{}，您可以分别为源颜色和目标颜色 {} 手动设置系数 {}。这为您提供了更多绘制像素的选项，因为您现在可以手动选择源乘什么，然后选择目标乘什么。",
    "You can also set the equation used for RGB and Alpha separately using&nbsp;{}{}gpu_set_blendequation_sepalpha{}{}.":"您还可以使用 {}{}gpu_set_blendequation_sepalpha{}{} 分别设置用于 RGB 和 Alpha 的方程。",
    "You can see how the inclusion of a lower alpha affects this calculation:":"您可以看到包含较低的 alpha 如何影响此计算：",
    "You can use the {}bm_eq_subtract{} equation to achieve the following effect:":"您可以使用 {}bm_eq_subtract{} 方程来实现以下效果：",
    "You would call this before (for example) drawing a sprite, then reset it afterwards, something like this:":"您可以在 (例如) 绘制精灵之前调用此函数，然后在之后重置它，如下所示：",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour that is already there at the pixel position.":"{}(Rd、Gd、Bd、Ad){}= 像素位置处已存在的颜色的 RGB 和 Alpha。",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd，Gd，Bd，Ad){}=您要绘制的颜色的RGB和Alpha。",
    "{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs，Gs，Bs，As){}=您要绘制的颜色的RGB和Alpha。",
    "{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it\u0027s almost exactly as you would expect.":"{} 您看得出来差别吗？可能不会！然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。",
    "{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it\u0027s almost exactly as you would expect. Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn\u0027t mean you can\u0027t create passable imitations of these effects, or even brand new effects, using them.":"{}您看得出来差别吗？ 可能不会！ 然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。 请注意，尽管并非艺术程序使用的所有混合模式都可以在 {}GameMaker{} 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着 这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。",
    "{}Example of how bm_normal Works{}{}Example of how bm_normal Works{}":"{}bm_normal 工作原理示例 {}{}bm_normal 工作原理示例 {}",
    "{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{}使用函数{}gpu_set_blendmode(){}来更改游戏用于绘制的混合。您可以在绘制精灵之前(例如)调用此函数，然后在绘制精灵之后再次设置它，类似于以下内容：",
    "{}Hopefully you can now work out why this happens for yourself using the formulas I\u0027ve outlined above and applying the appropriate figures for {}bm_normal{}.":"{}希望您现在可以使用我上面概述的公式并应用 {}bm_normal{} 的适当数字来弄清楚为什么会发生这种情况。",
    "{}Hopefully you can now work out why this happens for yourself using the formulas we\u0027ve outlined above and applying the appropriate figures for {}bm_normal{}.":"{} 希望您现在可以使用我们上面概述的公式并应用适当的 {}bm_normal{} 数字来弄清楚为什么会发生这种情况。",
    "{}If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It\u0027s just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even {}bm_normal{})...":"{}如果您对 Alpha 仍然有点困惑，请尝试将其想象为另一种颜色。 它的行为就像一种颜色，所有关于它的计算都以类似的方式完成。 它只是不太明显，尽管它对其他颜色的影响是可见的。 这就是我们在使用曲面和混合模式（甚至是 {}bm_normal{}）时需要注意的最后一点...",
    "{}Imagine you want to reduce the red value of all pixels drawn in an area of the room by 25%. You would first need to get 25% of 255, then convert that into an RGB colour value, and then finally use that along with bm_subtract to draw over the area. Something like this:":"{}假设你想将房间某个区域中所有像素的红色值减少25%。你首先需要得到255的25%，然后将其转换为RGB颜色值，最后使用沿着bm_subtract在该区域上绘制。类似这样：",
    "{}So, our blend mode looks like this:":"{}因此，我们的混合模式如下所示：",
    "{}So, our blending calculations look like this:":"{} 因此，我们的混合计算如下所示：",
    "{}The background colour in this example is {}(50, 100, 0, 255){}.":"{} 此示例中的背景颜色为 {}(50, 100, 0, 255){}。",
    "{}This blend mode can be useful when you need to draw overlapping images without them becoming so bright that they can\u0027t be seen. The bright parts will become brighter, but they should still maintain a level of colour and hue. Note though that the alpha value of the source image will also influence in the final effect when using this blend mode.":"{}当你需要绘制重叠的图像时，此混合模式非常有用，而不会让它们变得太亮而看不见。明亮的部分会变得更亮，但它们仍然应该保持一定的颜色和色调。请注意，使用此混合模式时，源图像的alpha值也会影响最终效果。",
    "{}This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind {}bm_max{} (and the other blend modes) we\u0027ll cover in part two of our article, but all you need to know is that the result will be a more \"saturated\" and brighter colour, without leading to the same pure white brilliance that using{}&nbsp;{}{}{}bm_add{}{}{}&nbsp;{}will cause.{}":"{} 这种混合模式解释起来比较复杂，但它基本上是将源颜色乘以源 Alpha，然后将它们与目标颜色值乘以源颜色值的逆值相加。我们将在文章的第二部分介绍 {}bm_max{}( 以及其他混合模式) 背后的实际数学原理，但您需要知道的是，结果将是更 \" 饱和 \" 且更明亮的颜色，而不会导致达到与使用 {}{}{}{}bm_add{}{}{}{} 相同的纯白色亮度。{}",
    "{}Using our extended blend mode we get the following:":"{}使用我们的扩展混合模式，我们得到以下结果：",
    "{}Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, or lasers or just about anything that you want to appear to glow or have luminescence.":"{}使用此混合模式是获得\"氖发光\"外观的好方法，并且最常用于照明效果，或激光或任何您想要看起来发光或发光的东西。",
    "{}bm_normal{} is the default blend mode, which multiplies the source colour with its alpha, and multiplies the destination colour with the&nbsp;{}inverse{}&nbsp;of the source alpha (to make space for the source colour to fit in). Finally it adds both together (as the equation is {}bm_add{}):":"{}bm_normal{} 是默认混合模式，它将源颜色与其 Alpha 相乘，并将目标颜色与源 Alpha 的 {} 逆 {} 相乘 (为源颜色留出空间)。最后将两者相加 (因为等式为 {}bm_add{})：",
    "{}{}IMPORTANT{}{}&nbsp;{}Blend factors{} are not applied when {}bm_eq_min{} or {}bm_eq_max{} is used as the blend equation, which is effectively the same as using&nbsp;{}bm_one{}&nbsp;as the factors.":"{}{} 重要{}{} 当使用 {}bm_eq_min{} 或 {}bm_eq_max{} 作为混合方程时，不会应用 {} 混合因子 {}，这与使用 {}bm_one{} 作为混合方程实际上相同的因素。",
    "{}{}NOTE{}{}&nbsp;These examples demonstrate blend modes using a green background, with a blue square drawn on it, both of which count as the destination. A grey square is drawn as the source, using each of the blend modes.":"{}{} 注意{}{} 这些示例演示了使用绿色背景并在其上绘制蓝色方块的混合模式，这两种模式都算作目标。使用每种混合模式绘制一个灰色方块作为源。"
}