{
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let\u0027s just have a look at the dry technical answer first before we go any further:":"在上面我们已经讨论了函数{}{}gpu_set_blendmode(){}{}，但是现在我们要看看{}{}gpu_set_blendmode_ext(){}{}。这(顾名思义)是一个用于设置{}自定义{}混合模式的扩展函数，但这是如何工作的呢?在我们进一步讨论之前，让我们先看看枯燥的技术答案:",
    "And the destination would be like this:":"目标是这样的:",
    "As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}. You can see how the inclusion of alpha affects this value too:":"如您所见，我们将目标值乘以 0，这也为它们提供了 0 值，这意味着源颜色未更改，因此我们的最终颜色值为{}(128, 255, 64, 255){} . 您还可以看到包含 alpha 是如何影响这个值的：",
    "BASIC BLEND MODES":"基本混合模式",
    "Before we actually draw something using this blend mode, let\u0027s have a look at how it should look in Photoshop:":"在我们真正使用这种混合模式绘制之前，让我们先看看它在 Photoshop 中应该是什么样子:",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏要将某些东西与预先绘制的东西混合在一起。你在屏幕上绘制的所有东西都是由四个分量组成的 -红色、绿色、蓝色和透明度 -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制所有像素的颜色和alpha值基本不变(尽管在本节的后面，你将看到这不是{}完全{} 的…)，但{}GameMaker{}有许多内建的混合模式，可以设置来改变这种行为。",
    "CREATING YOUR OWN BLEND MODES":"创建你自己的混合模式",
    "Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to that which you may think. The above image was created on a surface cleared to black over a black background, but if we clear the surface to red, we get this instead:":"即使表面的透明度为0，{}{}颜色成分仍然存在，并将影响所有的混合操作{}{}。所以绘制到一个零透明度清除的表面，使用红色(例如)将混合源颜色和目标颜色，给不同的效果，你可能认为。上图是在黑色背景的黑色表面上创建的，但如果我们把表面清除为红色，我们会得到这样的结果:",
    "Extended Blend Modes":"扩展混合模式",
    "Following the same rule, if you wanted to simply reduce the brightness of a background by 50% then you would have a colour that is 50% red, 50% green and 50% blue, ie: RGB (128, 128, 128). This blend mode is mainly used for drawing shadows, or creating interesting fade out effects.":"遵循相同的规则，如果您只想将背景的亮度降低 50%，那么您将获得 50% 红色、50% 绿色和 50% 蓝色的颜色，即：RGB (128, 128, 128)。 这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。",
    "Guide To Using Blendmodes":"混合模式使用指南",
    "Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects. We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"希望您现在可以清楚地看到混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。 我们现在将通过一个实际示例来了解如何结合这些因素来创建您自己的自定义混合模式。",
    "If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:":"如果你继续在现有的圆中画另一个圆，alpha值也是0.5，那么圆外的alpha值是0，圆之间的alpha值是0.25，小圆内的alpha值是0.375:",
    "If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:":"如果你继续在一个alpha值为0的表面上画一些0.5的圆，然后把这个表面画到房间里，你会清楚地看到:",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果你一直在使用{}GameMaker{}，你几乎肯定会遇到{}混合模式{}，甚至可能在你的游戏中使用它们。混合模式是一种很好的方法，可以改变物体的绘制方式，从而产生有趣和特定的图像效果，但你知道它们是如何工作的吗?这是一个容易让人困惑的话题，所以在本节中，我们希望能解开一些围绕混合模式的谜题，让你能在游戏中最大限度地使用它们。",
    "It\u0027s worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha(){}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won\u0027t cover this function here as it\u0027s explained in depth already in the manual, but it\u0027s worth mentioning just so you know it\u0027s available for use.":"值得一提的是，对于{}GameMaker{}，你可以进一步使用函数{}{}gpu_set_blendmode_ext_sepalpha(){}{}。这允许您分离出不同混合模式因子的alpha部分，并单独使用它们来创建更多可能的组合。我们在这里不讨论这个函数，因为在手册中已经对它进行了深入的解释，但是为了让您知道它可以使用，这里有必要提到它。",
    "Now you know how setting blend modes works and have seen an example of it being used for everyday drawing, let\u0027s look at something abit more complex...":"现在你知道如何设置混合模式的工作原理，并已经看到了一个例子，它被用于日常绘制，让我们看看更复杂的东西..。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在您已经了解了在{}GameMaker{}中使用混合模式的基本原理。它获取源图像(正在绘制的图像)的RGB和alpha值，然后将这些值与目标图像(也正在绘制的图像)的RGB和alpha值混合。这种混合是通过将每个像素颜色和alpha的单独成分乘以不同的数量来完成的，这取决于我们想要达到的效果。有了这些知识，你可以开始在你的游戏中使用混合模式来获得发光的激光，逼真的阴影，或饱和过渡效果，但这里仍然有更多的东西需要学习!下面我们来看看{}扩展的混合模式{}，以及探索它们背后的一些数学知识，这样你就可以创建自己的混合效果，如乘法或叠加。",
    "Now, while that text is correct and explains what blend modes do, it\u0027s not really intuitive... so let\u0027s go into a bit more detail and explain what this is all about.":"现在，虽然该文本是正确的并解释了混合模式的作用，但它并不是很直观……所以让我们更详细地解释一下这到底是怎么回事。",
    "OVERVIEW":"概述",
    "One final thing is worth noting about blend modes, and that is how they affect the {}alpha {}component of a colour. When simply drawing to the {}application surface{} or the {}display buffer{}, you don\u0027t really need to take into consideration the destination alpha value as it will {}always {}be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.":"关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的{}透明度{}部分。当简单地绘制到{}应用程序表面{}或{}显示缓冲区{}时，实际上不需要考虑目标透明度值，因为{}总是{}为1。然而，你自己制作的表面是不同的，因为你可以清除一个表面，使其具有从0到1的任意透明度值。这导致了一些有趣的结果，与大多数人的预期相反。",
    "One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we\u0027ll use this blend mode as our test subject since it\u0027s the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour (128, 255, 64, 255) over a background with the colour (64, 128, 255, 255):":"人们在使用混合模式时遇到的问题之一是将结果可视化，因此为了展示其背后的数学原理，我们将使用这种混合模式作为我们的测试对象，因为它是每个人使用最多的混合模式，而且我们确切地知道会发生什么 从中。 假设我们在颜色为 (64, 128, 255, 255) 的背景上绘制一个颜色为 (128, 255, 64, 255) 的矩形：",
    "SURFACES AND ALPHA":"表面和透明度",
    "Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the {}bm_normal{} blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:":"假设你有一个像素为0的表面，然后使用{}bm_normal{}混合模式在其上用0.5的像素画一个圆。整个表面仍然是0，但在圆中实际上是0.25，因为:",
    "So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"所以当我们在屏幕上画东西的时候，我们的图形处理器实际上对每一个像素都做以下操作:",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}加法{}混合模式绘制实例精灵。 使用可用的 GML 常量之一设置加法混合模式，其中有四种用于基本模式：",
    "The blend factor {}bm_zero{} effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name \"multiply\" for the mode. To use this in {}GameMaker{}, you would simply have something like this in your {}Draw Event{}:":"混合因子 {}bm_zero{} 有效地从等式中删除了目标颜色（因为零乘以任何东西都是零），所以我们剩下的是源颜色乘以目标颜色的混合因子，因此名称为“乘以” 模式。 要在 {}GameMaker{} 中使用它，您只需在 {}绘制{} 中添加类似这样的内容：",
    "The four \"basic\" blend modes that {}GameMaker{} has are actually composites of two of these blend factors.":"{}GameMaker{} 的四种“基本”混合模式实际上是其中两种混合系数的组合。",
    "The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数 {}gpu_set_blendmode_ext{}{}(src, dest){} 指示用于源颜色和目标颜色的混合模式。 新颜色是某个因子乘以源，另一个因子乘以目标。 这些因子是用这个函数设置的。 要理解这一点，源和目标都有红色、绿色、蓝色和 alpha 分量。 因此，{}源{}是({}Rs、Gs、Bs、As{})，{}目标{}是 ({}Rd、Gd、Bd、Ad{})。 所有值都被认为介于 0 和 1 之间。",
    "The next image was taken from a test project in GameMaker using this exact code:":"下一张图片来自 GameMaker 中的一个测试项目，使用的代码如下:",
    "The {}blend factors{} mentioned above are defined in {}GameMaker{} by a number of GML constants, and each one represents a factor by which the source or destination R, G, B and A values should be multiplied by. The factors available are:":"上面提到的{}混合因子{}在 {}GameMaker{} 中由多个 GML 常量定义，每个常量代表一个因子，源或目标 R、G、B 和 A 值应乘以该因子。 可用的因子是：",
    "This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"这种混合模式将源像素和目标像素的颜色加在一起（但不影响 alpha 值）。 例如，如果您的背景图像是 RGB 值为 (100,15,70) 的纯色，然后您绘制了一个 RGB 值为 (120,25,30) 的矩形，那么（使用 bm_add）最终 RGB 矩形的每个像素的值为 (220,40,100)。 请注意，颜色值不能超过 255（或低于 0），因此加起来超过该值的任何值都将被限制为 255。",
    "This blend mode is a bit different to the previous one, as it it works on a percentage basis rather than a direct value. This percentage is what will be subtracted from the destination colour (the colour of the pixel being drawn to). To explain this better, let\u0027s look at an example.":"这种混合模式与之前的有点不同，因为它基于百分比而不是直接值。 这个百分比是将从目标颜色（被绘制到的像素的颜色）中减去的百分比。 为了更好地解释这一点，让我们看一个例子。",
    "This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind bm_max (and the other blend modes) we\u0027ll cover in part two of our article, but all you need to know is that the result will be a more \"saturated\" and brighter colour, without leading to the same pure white brilliance that using {}bm_add{} will cause.":"这种混合模式解释起来比较复杂，但它基本上是将源颜色乘以源alpha，然后将它们添加到目标颜色值乘以反源颜色值。我们将在本文的第二部分介绍bm_max(和其他混合模式)背后的实际数学原理，但您所需要知道的是，结果将是一个更“饱和”和更明亮的颜色，而不会导致使用{}bm_add{}将导致的纯白色光泽。",
    "This gives a final pixel colour (96, 192, 159, 192), and will give an image like that shown below:":"这给出了一个最终的像素颜色(96,192,159,192) ，并将给出一个如下图所示的图像:",
    "Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at bm_normal, which is really:":"现在我们来看一个实际的例子，说明如何在{} GameMaker {}中绘制。为此，我们将查看 bm _ Normal，它实际上是:",
    "To illustrate this, we are going to look at drawing using the basic default {}bm_normal{}. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... {}but this is not the case{} and is something that many people think is a \"bug\" in how {}GameMaker{} renders things. However, as you will see, it\u0027s not a bug at all!":"为了说明这一点，我们将看看如何使用基本默认{}bm_normal{}进行绘制。大多数人认为把一个表面清除到透明度0，然后画一个透明度为0.5的东西，结果透明度值也会是0.5…{}但{}并非如此，许多人认为这是{}GameMaker{}渲染方式中的一个“bug”。然而，正如您将看到的，这根本不是一个bug !",
    "Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a {}multiply {}effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:":"使用可用的不同因子，您可以创建自己的混合模式以实现通常无法使用的混合选项。 在此示例中，我们将创建一个类似于 Photoshop 中使用的{}乘法{}效果。 我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：",
    "We have seen already how {}bm_normal{} looks - since that\u0027s what everything defaults to! - so let\u0027s continue on to look at the other three in a bit more detail...":"我们已经看到了 {}bm_normal{} 的外观 - 因为这是所有内容的默认设置！ - 让我们继续更详细地了解其他三个......",
    "When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it\u0027s components, like this:":"当我们谈论{}源{}时，我们谈论的是正在绘制的像素的颜色和 alpha 值，而当我们谈论{}目标{}时，我们谈论的是像素的颜色和 alpha 值 它正在被绘制。 为了让事情更简单，我们可以写出源颜色作为它的组成，如下所示：",
    "When {}GameMaker{} goes to draw a pixel there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(你要绘制的像素的颜色)和一个{}目标颜色{}(我们要绘制的像素中已经存在的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}将源颜色和目标颜色结合起来，如上所述。颜色的每个组成部分都存储为0到1之间的浮点值，新颜色的计算方法是:将源颜色的每个组成部分乘以某个因子，将目标颜色的每个组成部分乘以其他因子，然后将结果逐项相加。",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd, Gd, Bd, Ad){} = 您要绘制的颜色的 RGB 和 Alpha。",
    "{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs, Gs, Bs, As){} = 您要绘制的颜色的 RGB 和 Alpha。",
    "{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it\u0027s almost exactly as you would expect. Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn\u0027t mean you can\u0027t create passable imitations of these effects, or even brand new effects, using them.":"{}您看得出来差别吗？ 可能不是！ 然而，由于所使用的渲染工具之间的差异，两者之间会有一些偏差，但这几乎完全符合您的预期。 请注意，并非艺术程序使用的所有混合模式都可以在 {}GameMaker{} 中使用，因为其中一些实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不是 意味着您不能使用它们创建这些效果的合格模仿，甚至是全新的效果。",
    "{}Example of how bm_normal Works{}{}Example of how bm_normal Works{}":"{}bm_normal 工作原理示例{}{}bm_normal 工作原理示例{}",
    "{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{} 使用函数 {}gpu_set_blendmode(){} 更改您的游戏用于绘制的混合。 您可以在（例如）绘制精灵之前调用它，然后再将其设置回去，如下所示：",
    "{}Hopefully you can now work out why this happens for yourself using the formulas I\u0027ve outlined above and applying the appropriate figures for {}bm_normal{}.":"{}希望您现在可以使用我上面列出的公式，并为{}bm_normal{}应用适当的数字，自己找出为什么会发生这种情况。",
    "{}If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It\u0027s just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even {}bm_normal{})...":"{}如果你对透明度还是有点困惑，试着把它想象成另一种颜色。它就像一种颜色，所有关于它的计算都以类似的方式完成。它只是不太可见，尽管它对其他颜色的影响是可见的。这就引出了我们在使用表面和混合模式(甚至是{}bm_normal{})时需要注意的最后一点……",
    "{}Imagine you want to reduce the red value of all pixels drawn in an area of the room by 25%. You would first need to get 25% of 255, then convert that into an RGB colour value, and then finally use that along with bm_subtract to draw over the area. Something like this:":"{}假设您想将房间某个区域中绘制的所有像素的红色值降低 25%。 您首先需要获得 255 的 25%，然后将其转换为 RGB 颜色值，最后使用它与 bm_subtract 一起绘制该区域。 是这样的：",
    "{}So, our blend mode looks like this:":"{}我们的混合模式是这样的:",
    "{}This blend mode can be useful when you need to draw overlapping images without them becoming so bright that they can\u0027t be seen. The bright parts will become brighter, but they should still maintain a level of colour and hue. Note though that the alpha value of the source image will also influence in the final effect when using this blend mode.":"{}当你需要绘制重叠的图像时，这种混合模式很有用，因为它们不会变得太亮以至于看不见。明亮的部分会变得更亮，但它们应该仍然保持一定的颜色和色调。注意，当使用这种混合模式时，源图像的alpha值也会影响最终效果。",
    "{}Using our extended blend mode we get the following:":"{}使用扩展混合模式，我们得到以下结果:",
    "{}Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, or lasers or just about anything that you want to appear to glow or have luminescence.":"{}使用这种混合模式是获得“霓虹发光”效果的一个很好的方法，并且通常用于灯光效果，或激光，或任何你想要看起来发光或发光的东西。",
    "{}bm_add{}{}bm_add{}":"{}bm_add{}{}bm_add{} 加法混合",
    "{}bm_dest_alpha{}: Blend factor is (Ad, Ad, Ad, Ad)":"{}bm_dest_alpha{}: 混合系数为 (Ad, Ad, Ad, Ad)",
    "{}bm_dest_colour{}: Blend factor is (Rd, Gd, Bd, Ad)":"{}bm_dest_colour{}: 混合系数为 (Rd, Gd, Bd, Ad)",
    "{}bm_inv_dest_alpha{}: Blend factor is (1-Ad, 1-Ad, 1-Ad, 1-Ad)":"{}bm_inv_dest_alpha{}: 混合系数为 (1-Ad, 1-Ad, 1-Ad, 1-Ad)",
    "{}bm_inv_dest_colour{}: Blend factor is (1-Rd, 1-Gd, 1-Bd, 1-Ad)":"{}bm_inv_dest_colour{}: 混合系数为 (1-Rd, 1-Gd, 1-Bd, 1-Ad)",
    "{}bm_inv_src_alpha{}: Blend factor is (1-As, 1-As, 1-As, 1-As)":"{}bm_inv_src_alpha{}: 混合系数为 (1-As, 1-As, 1-As, 1-As)",
    "{}bm_inv_src_colour{}: Blend factor is (1-Rs, 1-Gs, 1-Bs, 1-As)":"{}bm_inv_src_colour{}: 混合系数为 (1-Rs, 1-Gs, 1-Bs, 1-As)",
    "{}bm_one{}: Blend factor is (1, 1, 1, 1)":"{}bm_one{}: 混合系数为 (1, 1, 1, 1)",
    "{}bm_src_alpha_sat{}: Blend factor is (f, f, f, 1); f = min(As, 1-Ad)":"{}bm_src_alpha_sat{}: 混合系数为 (f, f, f, 1); f = min(As, 1-Ad)",
    "{}bm_src_alpha{}: Blend factor is (As, As, As, As)":"{}bm_src_alpha{}: 混合系数为 (As, As, As, As)",
    "{}bm_src_colour{}: Blend factor is (Rs, Gs, Bs, As)":"{}bm_src_colour{}: 混合系数为 (Rs, Gs, Bs, As)",
    "{}bm_subtract{}{}bm_subtract{}":"{}bm_subtract{}{}bm_subtract{} 减法混合",
    "{}bm_zero{}: Blend factor is (0, 0, 0, 0)":"{}bm_zero{}: 混合系数为 (0, 0, 0, 0)"
}