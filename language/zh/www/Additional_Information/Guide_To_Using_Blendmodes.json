{
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let\u0027s just have a look at the dry technical answer first before we go any further:":"上面我们已经谈到了函数{}{}gpu_set_blendmode(){}{}但是现在我们要看看{}{}gpu_set_blendmode_ext(){}{}. 这是一个设置{}自定义{}混合模式的扩展函数，但是这是如何工作的呢？在我们继续之前，让我们先看看干巴巴的技术答案：",
    "And the destination would be like this:":"目的地是这样的：",
    "As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}. You can see how the inclusion of alpha affects this value too:":"如您所见，我们将目标值乘以0，这也使它们的值为0，这意味着源颜色不变，因此我们的最终颜色值为{}(128,255,64,255){}。您可以看到包含alpha如何影响此值：",
    "BASIC BLEND MODES":"基本混合模式",
    "Before we actually draw something using this blend mode, let\u0027s have a look at how it should look in Photoshop:":"在我们真正使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏要绘制某些东西，这些东西与之前已经绘制的东西混合在一起。你画到屏幕上的所有东西都由四个组成部分组成——红色、绿色、蓝色和阿尔法——默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制所有像素，其颜色和阿尔法值基本不变(尽管，在本节后面，你会看到这不是{}完全{}真实的…)，但是{}GameMaker{}有许多内置的混合模式，可以设置来改变这种行为。",
    "CREATING YOUR OWN BLEND MODES":"创建您自己的混合模式",
    "Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to that which you may think. The above image was created on a surface cleared to black over a black background, but if we clear the surface to red, we get this instead:":"即使表面的alpha为0，{}{}颜色成分仍然存在，并将影响所有混合操作{}{}。因此，绘制到使用红色(例如)清除的零alpha清除表面将混合源颜色和目标颜色，并为您可能认为的效果提供不同的效果。上图是在黑色背景上清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：",
    "Extended Blend Modes":"扩展混合模式",
    "Following the same rule, if you wanted to simply reduce the brightness of a background by 50% then you would have a colour that is 50% red, 50% green and 50% blue, ie: RGB (128, 128, 128). This blend mode is mainly used for drawing shadows, or creating interesting fade out effects.":"按照同样的规则，如果你想简单地将背景亮度降低50%，那么你将拥有50%红色、50%绿色和50%蓝色的颜色，即：RGB(128、128、128)。这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。",
    "Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects. We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"希望您现在可以清楚地看到混合模式因素的作用，以及组合它们如何改变绘制的内容以创建一些有趣的效果。我们现在将看一个如何结合这些因素来创建您自己的自定义混合模式的实际示例。",
    "If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:":"如果您接着在现有圆中绘制另一个圆，alpha值也是0.5，那么圆外的alpha值将为0，在圆之间为0.25，在较小的圆中为0.375：",
    "If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:":"如果你继续画一些alpha 0.5的圆到一个alpha 0的表面上，然后把这个表面画到房间里，你将能够清楚地看到：",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果你已经使用{}GameMaker{}一段时间了，你几乎肯定会遇到{}混合模式{}，甚至可能在你的游戏中使用它们。混合模式是改变绘制方式以提供有趣和特定的图形效果的好方法，但是你知道它们是如何工作的以及如何使用它们吗？这是一个会让人困惑的话题，所以在本节中，我们希望消除一些围绕混合模式的神秘之处，并使您能够在游戏中充分利用它们。",
    "It\u0027s worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha(){}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won\u0027t cover this function here as it\u0027s explained in depth already in the manual, but it\u0027s worth mentioning just so you know it\u0027s available for use.":"值得一提的是，使用{}GameMaker{}，您可以使用函数{}{}gpu_set_blendmode_ext_sepalpha(){}{}. 这允许您分离出不同混合模式因素的阿尔法成分，并单独使用它们来创建更多可能的组合。我们不会在这里介绍这个功能，因为它已经在手册中进行了深入的解释，但值得一提的是，您可以使用它。",
    "Now you know how setting blend modes works and have seen an example of it being used for everyday drawing, let\u0027s look at something abit more complex...":"现在你知道设置混合模式是如何工作的，并且已经看到了一个用于日常绘图的例子，让我们看一些更复杂的东西…",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在您知道在{}GameMaker{}中使用混合模式背后的基本知识了。它获取源图像(正在绘制的内容)的RGB和alpha值，然后将它们与目标图像(也正在绘制的内容)的RGB和alpha值混合。这种混合是通过将每个像素颜色和alpha的单个组件乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在你的游戏中使用混合模式来获得发光的激光、逼真的阴影或饱和的过渡效果，但是这里还有更多需要学习的！下面我们看看{}扩展混合模式{}，并探索它们背后的一些数学，这样你就可以创建自己的混合效果，比如乘法或叠加。",
    "Now, while that text is correct and explains what blend modes do, it\u0027s not really intuitive... so let\u0027s go into a bit more detail and explain what this is all about.":"现在，虽然这篇文章是正确的，并解释了混合模式的作用，但它并不真正直观…所以让我们更详细地解释一下这是怎么回事。",
    "OVERVIEW":"概览",
    "One final thing is worth noting about blend modes, and that is how they affect the {}alpha {}component of a colour. When simply drawing to the {}application surface{} or the {}display buffer{}, you don\u0027t really need to take into consideration the destination alpha value as it will {}always {}be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.":"关于混合模式，最后一件值得注意的事情是，它们是如何影响颜色的{}alpha{}分量的。当简单地绘制到{}应用程序表面{}或{}显示缓冲区{}时，您实际上不需要考虑目标alpha值，因为{}始终{}是1。然而，您自己制作的曲面是不同的，因为您可以清除曲面以使其具有您希望的从0到1的任何alpha值。这导致了一些有趣的效果，与大多数人的预期相反。",
    "One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we\u0027ll use this blend mode as our test subject since it\u0027s the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour (128, 255, 64, 255) over a background with the colour (64, 128, 255, 255):":"人们对混合模式的问题之一是可视化结果，所以为了展示它们背后的数学，我们将使用这种混合模式作为我们的测试对象，因为这是每个人使用最多的混合模式，我们确切地知道会发生什么。想象一下，我们正在用颜色(128,255,64,255)在背景(64,128,255,255)上绘制一个矩形：",
    "SURFACES AND ALPHA":"表面和阿尔法",
    "Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the {}bm_normal{} blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:":"假设你有一个表面，每个像素alpha都是0，然后你用alpha 0.5在上面画一个圆，使用{}bm_normal{}混合模式。整个表面仍然是alpha 0，但在圆圈中，alpha实际上是0.25，因为：",
    "So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"因此，当我们在屏幕上绘制内容时，我们的图形处理器实际上会对每个像素执行以下操作：",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式是使用可用的GML常量之一设置的，其中有四种用于基本模式：",
    "The blend factor {}bm_zero{} effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name \"multiply\" for the mode. To use this in {}GameMaker{}, you would simply have something like this in your {}Draw Event{}:":"混合因子{}bm_zero{}有效地从等式中删除了目标颜色(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此模式的名称为\"相乘\"。要在{}GameMaker{}中使用它，您只需在{}绘制事件{}中添加类似的内容：",
    "The four \"basic\" blend modes that {}GameMaker{} has are actually composites of two of these blend factors.":"{}GameMaker{}拥有的四种\"基本\"混合模式实际上是其中两种混合因素的组合。",
    "The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数{}gpu_set_blendmode_ext{}{}(src,est){}指示对源颜色和目标颜色使用哪种混合模式。新颜色是某种因素乘以来源，另一种因素乘以目的地。这些因素是使用此功能设置的。为了理解这一点，源和目标都有一个红色、绿色、蓝色和alpha组件。所以{}源{}是({}Rs,Gs,Bs,As{})，{}目标{}是({}Rd,Gd,Bd,Ad{})。所有值都被认为介于0和1之间。",
    "The next image was taken from a test project in GameMaker using this exact code:":"下一张图片取自GameMaker中的一个测试项目，使用了以下确切代码：",
    "The {}blend factors{} mentioned above are defined in {}GameMaker{} by a number of GML constants, and each one represents a factor by which the source or destination R, G, B and A values should be multiplied by. The factors available are:":"上面提到的{}混合因子{}在{}GameMaker{}中由许多GML常量定义，每个常量代表一个因子，源或目标R、G、B和A值应乘以该因子。可用的因素有：",
    "This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果您的背景图像是RGB值为(100,15,70)的纯色，然后您绘制RGB值为(120,25,30)的矩形，那么(使用bm_add)该矩形的每个像素的fina RGB值将为(220,40,100)。请注意，颜色值不能超过255(或低于0)，因此任何加起来超过255的值都将被限制为255。",
    "This blend mode is a bit different to the previous one, as it it works on a percentage basis rather than a direct value. This percentage is what will be subtracted from the destination colour (the colour of the pixel being drawn to). To explain this better, let\u0027s look at an example.":"这种混合模式与前一种有点不同，因为它是基于百分比而不是直接值的。这个百分比是从目标颜色(被绘制的像素的颜色)中减去的。为了更好地解释这一点，让我们看一个例子。",
    "This gives a final pixel colour (96, 192, 159, 192), and will give an image like that shown below:":"这给出了最终的像素颜色(96,192,159,192)，并将给出如下所示的图像：",
    "Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at bm_normal, which is really:":"是时候看看如何在{}GameMaker{}中结合绘图的实际例子了。为此，我们将看看bm_normal，它实际上是：",
    "To illustrate this, we are going to look at drawing using the basic default {}bm_normal{}. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... {}but this is not the case{} and is something that many people think is a \"bug\" in how {}GameMaker{} renders things. However, as you will see, it\u0027s not a bug at all!":"为了说明这一点，我们将使用基本的默认{}bm_normal{}进行绘图。大多数人认为，将曲面清除为alpha 0，然后绘制alpha为0.5的东西也会得到0.5的alpha值…{}但事实并非如此{}，许多人认为{}GameMaker{}渲染事物的方式是一个\"bug\"。然而，正如你将看到的，这根本不是bug！",
    "Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a {}multiply {}effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:":"使用可用的不同因素，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个像Photoshop中使用的{}乘法{}效果。我们可以使用上面提到的两个混合模式因子常数来模拟这种混合模式，如下所示：",
    "We have seen already how {}bm_normal{} looks - since that\u0027s what everything defaults to! - so let\u0027s continue on to look at the other three in a bit more detail...":"我们已经看到了{}bm_normal{}的样子——因为这是一切的默认值！-所以让我们继续更详细地看看其他三个…",
    "When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it\u0027s components, like this:":"当我们谈论{}源{}时，我们谈论的是正在绘制的像素的颜色和阿尔法值，当我们谈论{}目标{}时，我们谈论的是被绘制覆盖像素的颜色和阿尔法值。为了让事情更简单，我们可以写出源颜色作为它的组件，如下所示：",
    "When {}GameMaker{} goes to draw a pixel there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}绘制像素时，有{}源颜色{}(您要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已经存在的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}组合源颜色和目标颜色，如上所述。颜色的每个成分都存储为0到1之间的浮点值，新颜色的计算方法是将源颜色的每个成分乘以某个因子，将目标颜色的每个成分乘以某个其他因子，然后将结果逐个分量相加。",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd, Gd, Bd, Ad){} = 您要被绘制覆盖颜色的RGB和Alpha。",
    "{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs, Gs, Bs, As){} = 您要绘制的颜色的RGB和Alpha。",
    "{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it\u0027s almost exactly as you would expect. Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn\u0027t mean you can\u0027t create passable imitations of these effects, or even brand new effects, using them.":"{}你能看出区别吗？可能不会！然而，由于所使用的渲染工具之间的差异，两者之间会有一些偏差，但这几乎与您所期望的完全一样。请注意，在{}GameMaker{}中，并不是艺术程序使用的所有混合模式都可用，因为其中一些混合模式实际上可以强制颜色值超过255，从而创建特殊效果，但这并不意味着您不能使用它们创建这些效果的过得去的模仿效果，甚至是全新的效果。",
    "{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{}使用函数{}gpu_set_blendmode(){}来更改游戏用于绘图的混合。你可以在(例如)绘制精灵之前调用它，然后在之后再次设置它，如下所示：",
    "{}Hopefully you can now work out why this happens for yourself using the formulas I\u0027ve outlined above and applying the appropriate figures for {}bm_normal{}.":"{}希望您现在可以使用我上面概述的公式并为{}bm_normal{}应用适当的数字来解决为什么会发生这种情况。",
    "{}If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It\u0027s just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even {}bm_normal{})...":"{}如果你仍然对alpha有点困惑，试着把它想象成另一种颜色。它的行为就像一种颜色，所有的计算都以类似的方式进行。虽然它对其他颜色的影响是可见的，但它并不真正可见。这就引出了使用表面和混合模式(甚至{}bm_normal{})时需要注意的最后一件事…",
    "{}Imagine you want to reduce the red value of all pixels drawn in an area of the room by 25%. You would first need to get 25% of 255, then convert that into an RGB colour value, and then finally use that along with bm_subtract to draw over the area. Something like this:":"{}想象一下，您想将房间某个区域中绘制的所有像素的红色值减少25%。您首先需要获得255的25%，然后将其转换为RGB颜色值，然后最后将其与bm_subtract一起用于绘制该区域。像这样的东西：",
    "{}Using our extended blend mode we get the following:":"{}使用我们的扩展混合模式，我们得到以下结果：",
    "{}Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, or lasers or just about anything that you want to appear to glow or have luminescence.":"{}使用这种混合模式是获得\"霓虹灯\"外观的好方法，最常用于照明效果、激光或任何你想看起来发光或发光的东西。",
    "{}bm_dest_alpha{}: Blend factor is (Ad, Ad, Ad, Ad)":"{}bm_dest_alpha{}：混合因子为 (Ad, Ad, Ad, Ad)",
    "{}bm_dest_colour{}: Blend factor is (Rd, Gd, Bd, Ad)":"{}bm_dest_colour{}：混合因子为 (Rd, Gd, Bd, Ad)",
    "{}bm_inv_dest_alpha{}: Blend factor is (1-Ad, 1-Ad, 1-Ad, 1-Ad)":"{}bm_inv_dest_alpha{}：混合因子为 (1-Ad, 1-Ad, 1-Ad, 1-Ad)",
    "{}bm_inv_dest_colour{}: Blend factor is (1-Rd, 1-Gd, 1-Bd, 1-Ad)":"{}bm_inv_dest_colour{}：混合因子为 (1-Rd, 1-Gd, 1-Bd, 1-Ad)",
    "{}bm_inv_src_alpha{}: Blend factor is (1-As, 1-As, 1-As, 1-As)":"{}bm_inv_src_alpha{}：混合因子为 (1-As, 1-As, 1-As, 1-As)",
    "{}bm_inv_src_colour{}: Blend factor is (1-Rs, 1-Gs, 1-Bs, 1-As)":"{}bm_inv_src_colour{}：混合因子为 (1-Rs, 1-Gs, 1-Bs, 1-As)",
    "{}bm_one{}: Blend factor is (1, 1, 1, 1)":"{}bm_one{}：混合因子为 (1,1,1,1)",
    "{}bm_src_alpha_sat{}: Blend factor is (f, f, f, 1); f = min(As, 1-Ad)":"{}bm_src_alpha_sat{}：混合因子为 (f, f, f, 1); f = min(As, 1-Ad)",
    "{}bm_src_alpha{}: Blend factor is (As, As, As, As)":"{}bm_src_alpha{}：混合因子为 (As, As, As, As)",
    "{}bm_src_colour{}: Blend factor is (Rs, Gs, Bs, As)":"{}bm_src_colour{}：混合因子为 (Rs, Gs, Bs, As)",
    "{}bm_zero{}: Blend factor is (0, 0, 0, 0)":"{}bm_zero{}：混合因子为 (0,0,0,0)"
}