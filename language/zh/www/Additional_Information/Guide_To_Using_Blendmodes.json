{
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let\u0027s just have a look at the dry technical answer first before we go any further:":"上面我们已经讨论了函数 {}{}gpu_set_blendmode（）{}{}，但现在我们将看看 {}{}gpu_set_blendmode_ext（）{}{}。顾名思义，这是一个用于设置 {}custom {}blend 模式的扩展函数，但这是如何工作的呢？在我们进一步讨论之前，让我们先看一下枯燥的技术答案：",
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode{}{}, but now we are going to look at {}{}gpu_set_blendmode_ext{}{}.":"上面我们已经讨论了函数 {}{}gpu_set_blendmode{}{}，但现在我们要看看 {}{}gpu_set_blendmode_ext{}{}。",
    "Additive blending. Luminosity values of light areas are added.":"加法混合。提高灯光区域的亮度值。",
    "And the destination would be like this:":"目的地应该是这样的：",
    "As you already know, both source and destination colours have RGBA components.&nbsp;Each of these components are values between 0 and 1.":"正如你已经知道的，源颜色和目标颜色都有 RGBA 分量。每个分量的值都在 0 和 1 之间。",
    "As you can see, it is multiplying the source and destination RGBAs with their set factors. It then adds them together as per the default {}equation{}.":"如您所见，它将源 RGBA 和目标 RGB乘以它们的设置因子。然后按照默认的{}公式{}将它们相加。",
    "As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}. You can see how the inclusion of alpha affects this value too:":"如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 {}(128, 255, 64, 255){}。 您还可以看到 alpha 的包含如何影响该值：",
    "BASIC BLEND MODES":"基本混合模式",
    "Basic Blend Modes":"基本混合模式",
    "Before we actually draw something using this blend mode, let\u0027s have a look at how it should look in Photoshop:":"在我们实际使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：",
    "Blend Equation":"混合方程",
    "Blend Mode Constant":"混合模式常数",
    "Blend factors are defined in {}GameMaker{} by a number of GML constants. Each constant is a factor that you can use for the source or destination (or both). The following factors are available:":"混合因子在 {}GameMaker{} 中由多个 GML 常量定义。每个常量都是可用于源或目标 (或两者) 的因子。以下因子可用：",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是{}完全{}正确.)，但{}GameMaker{}有许多内置的混合模式，可以设置来改变这种行为。",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - {}Red{}, {}Green{}, {}Blue{} and {}Alpha{} - and by default they are drawn to the screen using the blend mode {}bm_normal{}.":"混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。",
    "Both the source colour and destination colour contain RGBA ({}Red{}, {}Green{}, {}Blue{} and {}Alpha{}) components, each of which are floating point values between 0 and 1.":"源颜色和目标颜色都包含RGBA({}红色{}、{}绿色{}、{}蓝色{}和 {}Alpha{}) 分量，每个分量都是 0 和 1 之间的浮点值。",
    "CREATING YOUR OWN BLEND MODES":"创建您自己的混合模式",
    "Calculating Final Colour":"计算最终颜色",
    "Calculating The Final Pixel":"计算最终像素",
    "Denoting Components":"表示组件",
    "Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to that which you may think. The above image was created on a surface cleared to black over a black background, but if we clear the surface to red, we get this instead:":"即使表面的 Alpha 为 0，{}{}颜色分量仍然存在并且会影响所有混合操作{}{}。 因此，绘制到已使用红色（例如）清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能认为的不同效果。 上面的图像是在黑色背景上清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：",
    "Extended Blend Mode":"扩展混合模式",
    "Extended Blend Modes":"扩展混合模式",
    "Extended Blend Modes (Factors)":"扩展混合模式(因子)",
    "Following the same rule, if you wanted to simply reduce the brightness of a background by 50% then you would have a colour that is 50% red, 50% green and 50% blue, ie: RGB (128, 128, 128). This blend mode is mainly used for drawing shadows, or creating interesting fade out effects.":"按照同样的规则，如果你想简单地将背景的亮度降低50%，那么你就会有一个50%红色，50%绿色和50%蓝色的颜色，即：RGB(128，128，128)。这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。",
    "Guide To Using Blend Modes":"混合模式使用指南",
    "Guide To Using Blendmodes":"Blendmodes使用指南",
    "Here, both values are finally {}added together{}, as the default equation is {}bm_add{}, however you can change that to subtract or to use some other equation (covered later on this page).":"在这里，两个值最终{}相加{}，因为默认公式是 {}bm_add{}，但是您可以将其更改为减去或使用其他公式(稍后将在本页中介绍)。",
    "Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects. We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。 现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。",
    "How Things Are Drawn":"事物是如何绘制的",
    "If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:":"如果你在现有的圆上再画一个alpha值为0.5的圆，那么在圆外的alpha值为0，在圆间的alpha值为0.25，在较小的圆内的alpha值为0.375：",
    "If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:":"如果你继续在一个alpha值为0的曲面上画一些alpha值为0.5的圆，然后把这个曲面画到房间上，你可以清楚地看到：",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您已经使用{}GameMaker{}一段时间，您几乎肯定会遇到{}混合模式{}，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how to use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您已经使用{}GameMaker{}一段时间，您几乎肯定会遇到{}混合模式{}，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。",
    "It\u0027s worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha(){}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won\u0027t cover this function here as it\u0027s explained in depth already in the manual, but it\u0027s worth mentioning just so you know it\u0027s available for use.":"值得一提的是，通过 {}GameMaker{}，您可以使用函数 {}{}gpu_set_blendmode_ext_sepalpha(){}{} 更进一步。 这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。 我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。",
    "Knowing these will help you understand how each factor works, as one factor may use e.g. the {}Rs{} value (source red), but another may use&nbsp;{}Rd{} (destination red), and so on.":"了解这些将有助于您了解每个因子的工作原理，因为一个因子可能使用{}Rs{}值(源红色)，但另一个因子可能使用{}Rd{}(目标红色)，等等。",
    "Let\u0027s now look through how each basic blend mode works.":"现在让我们来看看每个基本的混合模式是如何工作的。",
    "Normal blending (the default blend mode).":"正常混合(默认混合模式)。",
    "Now you know how setting blend modes works and have seen an example of it being used for everyday drawing, let\u0027s look at something abit more complex...":"现在你知道了如何设置混合模式的工作原理，并看到了一个例子，它被用于日常绘图，让我们看看一些更复杂的东西。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在你知道了在GameMaker中使用混合模式的基本原理，它为源图像获取RGB和alpha值(正在绘制的内容)，然后将其与目标的RGB和alpha值混合(也正在绘制)。这种混合是通过将每个像素颜色和alpha的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们来看看{}扩展混合模式{}，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGBA values for the source image (what is being drawn) and it then blends these with the RGBA values of the destination (what is being drawn to).":"现在你知道了在 {}GameMaker{} 中使用混合模式的基本原理。它获取源图像 (正在绘制的图像) 的 RGBA 值，然后将这些值与目标图像 (正在绘制的图像) 的 RGBA 值混合。",
    "Now, while that text is correct and explains what blend modes do, it\u0027s not really intuitive... so let\u0027s go into a bit more detail and explain what this is all about.":"现在，虽然文本是正确的，并解释了混合模式的作用，但它并不直观......所以让我们更详细地解释一下这是怎么回事。",
    "OVERVIEW":"概述",
    "One final thing is worth noting about blend modes, and that is how they affect the {}alpha {}component of a colour. When simply drawing to the {}application surface{} or the {}display buffer{}, you don\u0027t really need to take into consideration the destination alpha value as it will {}always {}be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.":"关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的 {}Alpha{} 分量。 当仅绘制到{}应用程序表面{}或{}显示缓冲区{}时，您实际上不需要考虑目标 Alpha 值，因为它{}始终{}为 1。 然而，您自己制作的表面是不同的，因为您可以清除表面以使其具有您希望的从零到一的任何 alpha 值。 这会导致一些有趣的效果，与大多数人的预期相反。",
    "One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we\u0027ll use this blend mode as our test subject since it\u0027s the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour (128, 255, 64, 255) over a background with the colour (64, 128, 255, 255):":"人们使用混合模式的一个问题是可视化结果，所以为了展示它们背后的数学原理，我们将使用这种混合模式作为我们的测试主题，因为它是每个人使用最多的混合模式，我们确切地知道它会带来什么。(128，255，64，255)的颜色的背景上：",
    "Overview":"概述",
    "Q(+y?>^":"",
    "SURFACES AND ALPHA":"曲面和阿尔法",
    "Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the {}bm_normal{} blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:":"假设你有一个表面，每个像素的alpha都是0，然后你用{}bm_normal{}混合模式在上面画一个alpha为0.5的圆。整个表面仍然是alpha 0，但是在圆中alpha实际上是0.25，因为：",
    "So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"所以当我们在屏幕上画东西时，我们的图形处理器实际上对每个像素都做了以下操作：",
    "Subtractive blending. Source is subtracted from the destination.":"减法混合。从目标中减去源。",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式使用可用的GML常量之一设置，其中有四个用于基本模式：",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are six for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式使用可用的 GML 常量之一设置，其中有六个用于基本模式：",
    "The \"Extended Blend Mode\" column shows the factors that are applied to the source and the destination (respectively), and the \"Blend Equation\" column shows the equation used to bring those two values together.":"\"扩展混合模式\"列显示分别应用于源和目标的因子，\"混合方程\"列显示用于将这两个值结合在一起的方程。",
    "The background colour in this example is {}(50, 100, 0, 255){}.":"本例中的背景色为 {}(50, 100, 0, 255){}。",
    "The blend factor {}bm_zero{} effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name \"multiply\" for the mode. To use this in {}GameMaker{}, you would simply have something like this in your {}Draw Event{}:":"混合因子{}bm_zero{}有效地将目标颜色从等式中移除(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此该模式的名称为\"乘\"。要在{}GameMaker{}中使用此模式，您只需在{}Draw Event{}中设置如下内容：",
    "The final colour of a pixel is calculated by multiplying each component of the source and destination by a {}factor{}, and then bringing them together according to the set {}equation{}.":"像素的最终颜色是通过将源和目标的每个分量乘以{}因子{}，然后根据集合{}等式{}将它们放在一起来计算的。",
    "The four \"basic\" blend modes that {}GameMaker{} has are actually composites of two of these blend factors.":"{}GameMaker{}拥有的四种\"基本\"混合模式实际上是其中两种混合因子的组合。",
    "The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数 {}gpu_set_blendmode_ext{}{}（src， dest）{} 指示用于源颜色和目标颜色的混合模式。新颜色是某个因素乘以来源，另一个因素乘以目的地。这些因素是用这个函数设置的。为了理解这一点，源和目标都具有红色、绿色、蓝色和 alpha 分量。所以 {}source {}is （{}Rs， Gs， Bs， As{}） 和 {}destination {}is （{}Rd， Gd， Bd， Ad{}）。所有值都被认为介于 0 和 1 之间。",
    "The next image was taken from a test project in GameMaker using this exact code:":"下一张图片是使用以下代码从GameMaker的测试项目中拍摄的：",
    "The second column shows you what values each of the R, G, B, A components are multiplied with, when that factor is being used.":"第二列显示使用该因子时，R、G、B、A 分量中的每个分量乘以的值。",
    "The {}blend factors{} mentioned above are defined in {}GameMaker{} by a number of GML constants, and each one represents a factor by which the source or destination R, G, B and A values should be multiplied by. The factors available are:":"上述{}混合因子{}在{}GameMaker{}中由多个GML常量定义，每个常量代表源或目标R、G、B和A值应乘以的因子。可用因子包括：",
    "Then it does the following for every single pixel:":"然后它对每个像素执行以下操作：",
    "This again uses the same factors as both {}bm_add{} and {}bm_subtract{}, but uses the reverse-subtract equation, so the destination colour is subtracted from the source colour (i.e. background is removed from the foreground).":"这再次使用与 {}bm_add{} 和 {}bm_subtract{} 相同的因子，但使用反向减法方程，因此从源颜色中减去目标颜色(即从前景中去除背景)。",
    "This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果背景图像是RGB值为(100，15，70)，然后绘制一个RGB为(120，25，30)，然后(使用bm_add)矩形的每个像素的最终RGB值将为(220，40，100).注意颜色值不能超过255(或小于0)，所以任何加起来超过255的值都将被箝位到255。",
    "This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of {}built-in blend modes{} that can be set to change this behaviour.":"这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是{}完全{}正确...)，但{}GameMaker{}有许多{}内置的混合模式{}，可以设置来改变这种行为。",
    "This blend mode is a bit different to the previous one, as it it works on a percentage basis rather than a direct value. This percentage is what will be subtracted from the destination colour (the colour of the pixel being drawn to). To explain this better, let\u0027s look at an example.":"这个混合模式与前一个有点不同，因为它是基于百分比而不是直接值。这个百分比是从目标颜色(正在绘制的像素的颜色)中减去的百分比。为了更好地解释这一点，让我们看一个例子。",
    "This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind bm_max (and the other blend modes) we\u0027ll cover in part two of our article, but all you need to know is that the result will be a more \"saturated\" and brighter colour, without leading to the same pure white brilliance that using {}bm_add{} will cause.":"这种混合模式更难解释，但它基本上是将源颜色乘以源alpha，然后将它们添加到目标颜色值乘以逆源颜色值。bm_max背后的实际数学(以及其他混合模式)我们将在文章的第二部分介绍，但您需要知道的是，结果将是一个更\"饱和\"和更明亮的颜色，而不会导致使用{}BM_add{}将导致的相同的纯白色亮度。",
    "This blend mode multiplies the source colour with its alpha, just like {}bm_normal{}, however it keeps the destination as-is ({}bm_one{}). It then adds both together, resulting in a lighter colour. Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"这种混合模式将源颜色与其alpha相乘，就像 {}bm_normal{} 一样，但它会保持目标颜色不变 ({}bm_one{})。然后将两者相加，得到较浅的颜色。请注意，颜色值不能超过 255 (或低于 0)，因此任何加起来超过 255 的颜色都会被箝位为 255。",
    "This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve, and then calculating the final pixel value from both using the set equation.":"这种混合是通过将每个像素颜色和 alpha 的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果，然后使用集合方程从两者计算最终的像素值。",
    "This gives a final pixel colour (96, 192, 159, 192), and will give an image like that shown below:":"这给出了最终的像素颜色（96、192、159、192），并将给出如下所示的图像：",
    "This is useful for removing parts of an image using a mask, as shown in an example later on this page under \"{}Blend Equations{}\".":"这对于使用遮罩移除图像的某些部分非常有用，如本页后面\"{}混合方程{}\"下的示例所示。",
    "This means that the way a final pixel colour is calculated is the following: {}(source * factor) + (destination * factor){}.":"这意味着最终像素颜色的计算方式如下：{}(源*因子)+(目标*因子)|(source * factor) + (destination * factor){}。",
    "This mode uses the same factors as {}bm_add{}, however it uses the subtract equation so the source colour is subtracted from the destination colour (i.e. foreground is removed from the background).":"此模式使用与 {}bm_add{} 相同的因子，但它使用减法公式，因此源颜色从目标颜色中减去(即前景从背景中删除)。",
    "This uses the {}bm_one{} factor for both source and destination colours, so they are not changed at all. Then it makes use of the minimum equation, so that whichever component value is smaller between the source and the destination (for each of R, G, B and A) is used for the final pixel.":"它对源颜色和目标颜色都使用 {}bm_one{} 因子，因此它们根本不会改变。然后它使用最小值方程，因此源和目标颜色 (对于 R、G、B 和 A 中的每一个) 之间的任何分量值都较小，用于最终像素。",
    "Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at bm_normal, which is really:":"是时候看看一个实际的例子了，它是如何在{}GameMaker{}中进行绘图的。为此，我们将看看bm_normal，它实际上是：",
    "To illustrate this, we are going to look at drawing using the basic default {}bm_normal{}. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... {}but this is not the case{} and is something that many people think is a \"bug\" in how {}GameMaker{} renders things. However, as you will see, it\u0027s not a bug at all!":"为了说明这一点，我们将使用基本的默认值{}bm_normal{}进行绘制。大多数人认为将表面清除为alpha 0，然后绘制alpha为0.5的东西将给予结果alpha值也为0.5.{}但事实并非如此{}，许多人认为这是{}GameMaker{}渲染事物的\"错误\"。然而，正如你所看到的，这根本不是一个bug！",
    "Use the function {}{}gpu_set_blendmode{}{}&nbsp;to apply a set of blend factors and equation {}at the same time{}, as a \"preset\" blend mode.":"使用函数 {}{}gpu_set_blendmode{}{} 同时{}应用一组混合因子和公式{}，作为\"预设\"混合模式。",
    "Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a {}multiply {}effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:":"使用不同的可用因子，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个类似于Photoshop中使用的{}乘{}效果。我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：",
    "Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, lasers or just about anything that you want to appear to glow or have luminescence.":"使用这种混合模式是一个伟大的方式来获得\"氖发光\"的外观，最常用的照明效果，激光或只是任何你想看起来有光晕或有发光。",
    "We denote the source RGBA as {}(Rs, Gs, Bs, As){} and destination RGBA as {}(Rd, Gd, Bd, Ad){}.":"我们将源 RGBA 表示为 {}(Rs, Gs, Bs, As){} 并且将目标 RGBA 表示为 {}(Rd, Gd, Bd, Ad){}。",
    "We have seen already how {}bm_normal{} looks - since that\u0027s what everything defaults to! - so let\u0027s continue on to look at the other three in a bit more detail...":"我们已经看到了{}bm_normal{}的外观-因为这是所有默认设置！-所以让我们继续更详细地查看其他三个.",
    "We saw that each of the built-in blend modes applies {}factors{} to the {}source{} and {}destination{} colours. For example, {}bm_add{} multiplies the source with its alpha, and multiplies the destination with 1.":"我们看到，每个内置混合模式都将{}因子{}应用于{}源{}和{}目标{}颜色。例如，{}bm_add{} 将源与其alpha相乘，并将目标与1相乘。",
    "When determining the final colour of a pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}&nbsp;-- basically asking, \"how should I combine the pink and the yellow?\".":"当确定像素的最终颜色时，GameMaker 将根据{}混合模式{}将源颜色和目标颜色进行组合--基本上是在问\"我应该如何将粉红色和黄色组合？\"。",
    "When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it\u0027s components, like this:":"当我们谈论{}source{}时，我们谈论的是正在绘制的像素的颜色和alpha值，而当我们谈论{}destination{}时，我们谈论的是正在绘制的像素的颜色和alpha值。为了使事情更容易，我们可以将源颜色写为它的组件，如下所示：",
    "When you go to draw something, the GPU gets this:":"当你去画一些东西时，GPU 会得到这个：",
    "When {}GameMaker{} goes to draw a pixel there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已有的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}将源颜色和目标颜色联合收割机组合，颜色的每个分量被存储为0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子并且通过将目的地颜色的每个分量乘以某个其它因子并且然后将结果加在一起分量，成分",
    "When {}GameMaker{} goes to draw a pixel, there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). For example, if you\u0027re drawing a pink colour after having drawn a yellow colour at the same pixel, pink is the {}source{}&nbsp;(what you\u0027re drawing), and yellow is the {}destination{} (as it\u0027s already there).":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已经存在的颜色)。例如，如果在同一像素上绘制了黄色之后，又绘制了粉色，则粉色是{}源{}(您正在绘制的内容)，黄色是{}目的地{}(因为它已经在那里)。",
    "With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes {}(factors), as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们看看{}扩展混合模式{}(因素)，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。",
    "With {}{}gpu_set_blendmode_ext{}{}, you can {}manually set the factors{} for the source and destination colours, separately. This gives you a ton more options to draw your pixels, as you can now manually choose what the source multiplies with, and then what the destination multiplies with.":"使用 {}{}gpu_set_blendmode_ext{}{}，您可以分别{}手动设置源颜色和目标颜色的因子{}。这为您提供了更多的选项来绘制像素，因为您现在可以手动选择源颜色与之相乘，然后选择目标颜色与之相乘。",
    "You would call this before (for example) drawing a sprite, then reset it afterwards, something like this:":"你可以在(例如)绘制精灵之前调用它，然后重置它，类似于这样：",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour that is already there at the pixel position.":"{}(Rd，Gd，Bd，Ad){} = 像素位置处已经存在的颜色的 RGB 和 Alpha。",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd，Gd，Bd，Ad){}=您要绘制的颜色的RGB和Alpha。",
    "{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs，Gs，Bs，As){} = 您要绘制的颜色的 RGB 和 Alpha。",
    "{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it\u0027s almost exactly as you would expect. Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn\u0027t mean you can\u0027t create passable imitations of these effects, or even brand new effects, using them.":"{}您看得出来差别吗？ 可能不会！ 然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。 请注意，尽管并非艺术程序使用的所有混合模式都可以在 {}GameMaker{} 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着 这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。",
    "{}Example of how bm_normal Works{}{}Example of how bm_normal Works{}":"{}bm_normal 工作原理示例 {}{}bm_normal 工作原理示例 {}",
    "{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{}使用函数{}gpu_set_blendmode(){}来更改游戏用于绘制的混合。您可以在绘制精灵之前(例如)调用此函数，然后在绘制精灵之后再次设置它，类似于以下内容：",
    "{}Hopefully you can now work out why this happens for yourself using the formulas I\u0027ve outlined above and applying the appropriate figures for {}bm_normal{}.":"{}希望您现在可以使用我上面概述的公式并应用 {}bm_normal{} 的适当数字来弄清楚为什么会发生这种情况。",
    "{}If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It\u0027s just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even {}bm_normal{})...":"{}如果您对 Alpha 仍然有点困惑，请尝试将其想象为另一种颜色。 它的行为就像一种颜色，所有关于它的计算都以类似的方式完成。 它只是不太明显，尽管它对其他颜色的影响是可见的。 这就是我们在使用曲面和混合模式（甚至是 {}bm_normal{}）时需要注意的最后一点...",
    "{}Imagine you want to reduce the red value of all pixels drawn in an area of the room by 25%. You would first need to get 25% of 255, then convert that into an RGB colour value, and then finally use that along with bm_subtract to draw over the area. Something like this:":"{}假设你想将房间某个区域中所有像素的红色值减少25%。你首先需要得到255的25%，然后将其转换为RGB颜色值，最后使用沿着bm_subtract在该区域上绘制。类似这样：",
    "{}So, our blend mode looks like this:":"{}因此，我们的混合模式如下所示：",
    "{}The background colour in this example is {}(50, 100, 0, 255){}.":"{}本例中的背景色为 {}(50, 100, 0, 255){}。",
    "{}This blend mode can be useful when you need to draw overlapping images without them becoming so bright that they can\u0027t be seen. The bright parts will become brighter, but they should still maintain a level of colour and hue. Note though that the alpha value of the source image will also influence in the final effect when using this blend mode.":"{}当你需要绘制重叠的图像时，此混合模式非常有用，而不会让它们变得太亮而看不见。明亮的部分会变得更亮，但它们仍然应该保持一定的颜色和色调。请注意，使用此混合模式时，源图像的alpha值也会影响最终效果。",
    "{}This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind {}bm_max{} (and the other blend modes) we\u0027ll cover in part two of our article, but all you need to know is that the result will be a more \"saturated\" and brighter colour, without leading to the same pure white brilliance that using{}&nbsp;{}{}{}bm_add{}{}{}&nbsp;{}will cause.{}":"{}这种混合模式解释起来比较复杂，但它基本上是将源颜色与源 Alpha 相乘，然后将它们与目标颜色值相加，再乘以反相源颜色值。我们将在文章的第二部分介绍 {}bm_max{} (以及其他混合模式) 背后的实际数学原理，但您所需要知道的是，结果将是更\"饱和\"和更明亮的颜色，而不会产生使用 {} {}{}{}bm_add{} {}{}{} 将产生的纯白色光泽。{}",
    "{}Using our extended blend mode we get the following:":"{}使用我们的扩展混合模式，我们得到以下结果：",
    "{}Using this blend mode is a great way to get that \"neon glow\" look, and is most often used for lighting effects, or lasers or just about anything that you want to appear to glow or have luminescence.":"{}使用此混合模式是获得\"氖发光\"外观的好方法，并且最常用于照明效果，或激光或任何您想要看起来发光或发光的东西。",
    "{}bm_normal{} is the default blend mode, which multiplies the source colour with its alpha, and multiplies the destination colour with the&nbsp;{}inverse{}&nbsp;of the source alpha (to make space for the source colour to fit in). Finally it adds both together (as the equation is {}bm_add{}):":"{}bm_normal{} 是默认的混合模式，它将源颜色与其alpha相乘，并将目标颜色与源alpha的{}逆{}相乘(为源颜色留出空间)。最后它将两者相加(公式为 {}bm_add{})：",
    "{}{}NOTE{}{}&nbsp;These examples demonstrate blend modes using a green background, with a blue square drawn on it, both of which count as the destination. A grey square is drawn as the source, using each of the blend modes.":"{}{}注意{}{} 这些示例演示了使用绿色背景的混合模式，并在其上绘制一个蓝色正方形，这两个背景均视为目标。使用每种混合模式，绘制一个灰色正方形作为源。"
}