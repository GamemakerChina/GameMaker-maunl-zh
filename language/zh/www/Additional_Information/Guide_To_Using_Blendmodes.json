{
    "\u0011t\uFFFDy\uFFFD3Т\uFFFD\uFFFDև\uFFFD\uFFFD\uFFFD~&\uFFFDo\u000E\uFFFD\u007FPs\uFFFD\uFFFD\uFFFDr\u000E\uFFFD\b\uFFFDmε\uFFFD\uFFFD/":"W\fy\uFFFD\uFFFD\uFFFDߍvܪ\uFFFD4^\uFFFD\uFFFDz\u0000\u007F\uFFFDn\uFFFD\uFFFD#l^\uFFFD",
    "+\uFFFD\uFFFD2\uFFFDP":"\fd>\uFFFD\uFFFD\uFFFDz\uFFFD\u0019%b\u07FD\u2E78\uFFFD3",
    "-n\uFFFD\uFFFD\uFFFDs\u0027\uFFFD/\uFFFD\uFFFD\uFFFDЂ\uFFFDZ\uFFFD\uFFFDr\uFFFDX\u0002@\uFFFD\uFFFDpZ":"\uFFFD\u0002\uFFFDT\b\tɥ؍u\uFFFD\uFFFD\uFFFD\uFFFD\u001A*ɀ\uFFFD\u0007\uFFFDl1?\uFFFD&\uFFFD\uFFFD|C0\u0016\uFFFD\u0359y\uFFFD\u0019o&g\uFFFDn\u000F\uFFFDK\u0015\uFFFDW\uFFFD\uFFFD\uFFFD\u0007\uFFFD\uFFFD\uFFFD\uFFFDa\u0019BL=",
    "8\uFFFDߞ7\uFFFD\uFFFD\uFFFD":"l",
    "Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let\u0027s just have a look at the dry technical answer first before we go any further:":"上面我们已经讨论了函数 {}{}gpu_set_blendmode（）{}{}，但现在我们将看看 {}{}gpu_set_blendmode_ext（）{}{}。顾名思义，这是一个用于设置 {}custom {}blend 模式的扩展函数，但这是如何工作的呢？在我们进一步讨论之前，让我们先看一下枯燥的技术答案：",
    "And the destination would be like this:":"目的地应该是这样的：",
    "Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you\u0027ll see that this isn\u0027t {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是{}完全{}正确.)，但{}GameMaker{}有许多内置的混合模式，可以设置来改变这种行为。",
    "B\uFFFD\u0007\u0015\uFFFDQ\uFFFD\uFFFD\uFFFDo\uFFFD\uFFFD\uFFFDw9ے\uFFFD\u0019\uFFFD\uFFFD\uFFFD\uFFFD\u000El\uFFFD\uFFFD(8\uFFFD\u0018\uFFFDY\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDpH\uFFFD\uFFFDOeU]\uFFFD\uFFFD\uFFFDU\uFFFD\u06D9b\uFFFD\uFFFD\uFFFD\uFFFD":"\uFFFDW\u0003\u0012\uFFFD\u0000\uFFFD`\uFFFD\uFFFD#\uFFFD\b\uFFFD\uFFFDJS\uFFFD&5\uFFFD\uFFFD\uFFFD3\uFFFDpk\u007F\uFFFD\uFFFDO\uFFFD\uFFFD\u0019\uFFFDt*",
    "If you\u0027ve been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您已经使用{}GameMaker{}一段时间，您几乎肯定会遇到{}混合模式{}，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。",
    "Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在你知道了在GameMaker中使用混合模式的基本原理，它为源图像获取RGB和alpha值(正在绘制的内容)，然后将其与目标的RGB和alpha值混合(也正在绘制)。这种混合是通过将每个像素颜色和alpha的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们来看看{}扩展混合模式{}，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。",
    "Now, while that text is correct and explains what blend modes do, it\u0027s not really intuitive... so let\u0027s go into a bit more detail and explain what this is all about.":"现在，虽然文本是正确的，并解释了混合模式的作用，但它并不直观......所以让我们更详细地解释一下这是怎么回事。",
    "Q(+y?>^":"",
    "So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"所以当我们在屏幕上画东西时，我们的图形处理器实际上对每个像素都做了以下操作：",
    "That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式使用可用的GML常量之一设置，其中有四个用于基本模式：",
    "The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数 {}gpu_set_blendmode_ext{}{}（src， dest）{} 指示用于源颜色和目标颜色的混合模式。新颜色是某个因素乘以来源，另一个因素乘以目的地。这些因素是用这个函数设置的。为了理解这一点，源和目标都具有红色、绿色、蓝色和 alpha 分量。所以 {}source {}is （{}Rs， Gs， Bs， As{}） 和 {}destination {}is （{}Rd， Gd， Bd， Ad{}）。所有值都被认为介于 0 和 1 之间。",
    "This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can\u0027t go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果背景图像是RGB值为(100，15，70)，然后绘制一个RGB为(120，25，30)，然后(使用bm_add)矩形的每个像素的最终RGB值将为(220，40，100).注意颜色值不能超过255(或小于0)，所以任何加起来超过255的值都将被箝位到255。",
    "We have seen already how {}bm_normal{} looks - since that\u0027s what everything defaults to! - so let\u0027s continue on to look at the other three in a bit more detail...":"我们已经看到了{}bm_normal{}的外观-因为这是所有默认设置！-所以让我们继续更详细地查看其他三个.",
    "When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it\u0027s components, like this:":"当我们谈论{}source{}时，我们谈论的是正在绘制的像素的颜色和alpha值，而当我们谈论{}destination{}时，我们谈论的是正在绘制的像素的颜色和alpha值。为了使事情更容易，我们可以将源颜色写为它的组件，如下所示：",
    "When {}GameMaker{} goes to draw a pixel there\u0027s a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that\u0027s already in the pixel we\u0027re drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已有的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}将源颜色和目标颜色联合收割机组合，颜色的每个分量被存储为0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子并且通过将目的地颜色的每个分量乘以某个其它因子并且然后将结果加在一起分量，成分",
    "]":"\u000B\uFFFD\uFFFD\uFFFD[\uFFFD\uFFFDŷ\u0013\uFFFD\uFFFD\uFFFD\u000E\uFFFD\u0004\uFFFDY\uFFFDM:\uFFFD\uFFFD\t\uFFFD~՜\uFFFDD\u001C\uFFFD\uFFFD\uFFFDb1q\uFFFD\u0018$[\uFFFD\uFFFD\u05B0X\uFFFDpDCP\bكwdl\uFFFD",
    "]V\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD":"\u000B\uFFFD\uFFFDq>\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDbЋ#ˢ\u001E\u00157\uFFFDK\uFFFD6S\uFFFDEd3q\uFFFD",
    "]f\uFFFD\u0016\u0015\uFFFDJ\uFFFDmg\u0000\uFFFDV\uFFFD\u0006t2H)\uFFFD\uFFFD\uFFFD4\uFFFD1V9\uFFFD\uFFFD\uFFFD9\uFFFD*d\u0006\uFFFD43\uFFFDп1\uFFFD\uFFFD[)\uFFFD\uFFFD\uFFFD\uFFFD\u001D饳$N\u02D2\uFFFDs\u0018\uFFFD\uFFFDr\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD8\uFFFD\u001A\uFFFDh\u000Fl\uFFFD/e\uFFFD\u0004T/\uFFFD\u06EDC\uFFFDZ":"\u0018\uFFFD\uFFFDЎx\uFFFD\uFFFD\u001C\u0012\uFFFD\uFFFD\uFFFD%\u007F\uFFFDa\uFFFD\uFFFD\u0019\uFFFD\uFFFDe\uFFFD\uFFFD\u000B\uFFFD",
    "]nw\uFFFD{-\u0015\uFFFD\uFFFD\uFFFD>\u0000؞\u0027\uFFFD0f<\uFFFD\uFFFDǬ":"\uFFFD\t\uFFFDk\uFFFD\uFFFD\uFFFD8)\u001E\uFFFD:\uFFFDL\uFFFD\uFFFD\uFFFD\"\uFFFD\uFFFD",
    "]\uFFFD\u0006(sHS\uFFFD\u001E\uFFFD\uFFFD\uFFFDЬw\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDs9|N\uFFFDl":"\u000B\b\uFFFD\u0019\uFFFD:\uFFFD\u0011\uFFFD\uFFFDޛ\u001C",
    "]\uFFFD\u007F\uFFFD\uFFFDf\u0017\uFFFDD\uFFFDa\uFFFD#\uFFFD{\uFFFD\\\uFFFD\uFFFD\uFFFD\uFFFD\u0000\uFFFDdB\uFFFDG64\uFFFDB\uFFFD":"\uFFFDS\uFFFD?_\uFFFD\uFFFDR8\uFFFDvr)\u0000\u000E:\uFFFD眝\u001F\uFFFD$\u00038\uFFFDC\uFFFDlE\uFFFD\uFFFD\uFFFDq\uFFFD\uFFFDƋ\uFFFD\uFFFD/\uFFFD\uFFFDj\uFFFDL\u0000o\uFFFD\uFFFD\u001C\uFFFD#D\"v4",
    "o\u000EOtu\uFFFD\uFFFD\uFFFD\u0012\u0012lK\uFFFD\uFFFD\uFFFD\uFFFDC&\\\u001B\u0015\uFFFD\uFFFD":"\uFFFD\u001Bڈ\uFFFD\u0017\uFFFD-\uFFFD\uFFFD!E\u0002\uFFFD\uFFFD\u0019\uFFFD!e\uFFFD\uFFFD\uFFFD@-\uFFFDK&UL\uFFFD\u000E\uFFFD K\u033Cr\uFFFD6ݐe\uFFFD\uFFFD7\u000F\uFFFDnج\uFFFDg\uFFFD\u001Do\u001D\uFFFDQOt\u007FMr&\uFFFD0\uFFFD\uFFFD߸\uFFFD\uFFFD\uFFFD\"$\uFFFD[?\uFFFD\u0010\uFFFD\uFFFDA\u001D\uFFFDZ\uFFFD\uFFFD0R\uFFFD\u0000Nէ\u001A",
    "p\uFFFD":"\u000BU\u0001\uFFFDH6p8f\uFFFD\uFFFD\u02EB\u0010\uFFFD2\uFFFDb\uFFFD6\uFFFDA(\uFFFD\uFFFD\u001FY\uFFFD%\uFFFD.x\uFFFD\uFFFDߵ\uFFFD\u0018\uFFFD\uFFFD\u0017g\uFFFD\u0013B\u0002\u001D\u001E\uFFFD\uFFFDԅ\uFFFD\uFFFD=\\\uFFFD\\\uFFFD\uFFFD\uFFFD\uFFFDs\uFFFD\u0010\uFFFD\uFFFDZE\uFFFD\u000E)E\uFFFDƅ\uFFFD\u0011\u0741\uFFFD\uFFFD#J&h\uFFFD\uFFFD2\uFFFDҦ\uFFFD\uFFFD\\\u02C2\u0005\u001A\u001AK\uFFFDr6밷\uFFFD\u0001ڏb\uFFFD\"{D\uFFFDFII\uFFFD\uFFFDS\uFFFD\ba\uFFFDY\uFFFD\u0368\uFFFD\u007F\u000F\uFFFD\uFFFDcT\u0010\uFFFD:2\uFFFD\uFFFD\uFFFDȴK",
    "{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd，Gd，Bd，Ad){}=您要绘制的颜色的RGB和Alpha。",
    "{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs，Gs，Bs，As){}=您要绘制的颜色的RGB和Alpha。",
    "{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{}使用函数{}gpu_set_blendmode(){}来更改游戏用于绘制的混合。您可以在绘制精灵之前(例如)调用此函数，然后在绘制精灵之后再次设置它，类似于以下内容：",
    "|&I\uFFFD":"\f\u000B\uFFFD-B",
    "\uFFFD\u000F\uFFFD\uFFFDu\u000EZ\uFFFD4\uFFFD7":"",
    "\uFFFD.A\uFFFD\uFFFD\u000El\uFFFD\uFFFD(8\uFFFDf\u0014)\uFFFD\uFFFDH\uFFFD\uFFFD\uFFFDf\uFFFD\\\uFFFD\uFFFD{\u0015\uFFFDR\uFFFDFE\uFFFD\uFFFD":"\uFFFD\u001FqﮠF.՜\uFFFDeZ\uFFFDQ\uFFFD\uFFFD\uFFFD\uFFFDδ\uFFFDZ\uFFFD6\uFFFD\uFFFD\u0018\uFFFD\uFFFD5\u001C\uFFFD\uFFFDk1\u000F\uFFFD7iX\uFFFD@*\uFFFD\uFFFD\\\uFFFDe`\uFFFD\u007FL\uFFFD@0\uFFFDOl",
    "\uFFFD>\u001C\uFFFDC\u0001\u0005*C~a\uFFFD\uFFFD\u0006\uFFFD\u0019y9\uFFFD\uFFFD8\uFFFD[":"\u0015*\\מ\uFFFD\uFFFD\u007F\uFFFD\u000F\uFFFD\u02F2\u0001\uFFFDC\uFFFDP\uFFFD\uFFFD\u0016\uFFFD#\uFFFDiǾu<\uFFFD\uFFFDx\uFFFDb\tO\uFFFDEgJ\uFFFDu5f\uFFFDv\uFFFD\uFFFD9",
    "\uFFFDa\u00183\uFFFD\u0003?g\u0015\u0016\"\uFFFD\uFFFDb\uFFFD\uFFFD\uFFFDcZ9o\uFFFD!iL\uFFFD\uFFFD\u0005\uFFFDR\uFFFDOLb\uFFFDK\uFFFDp\uFFFD!\uFFFD\u0018\uFFFD\uFFFDu\uFFFD\uFFFD\uFFFD\u00175\uFFFD\uFFFD\uFFFD\uFFFD^\uFFFDo":"\f*\uFFFDG#\uFFFDp\uFFFD\uFFFD\uFFFD=&G\uFFFD\uFFFD(|p>2\b\u0004Z\uFFFD\uFFFD/\uFFFD\uFFFD\uFFFD2\uFFFD\uFFFD\uFFFD\uFFFD\u007F\uFFFDRF\uFFFD\uFFFDN\uFFFD/)C[\uFFFD\uFFFD\u001D\uFFFDl\u0003\uFFFD\u001D/\uFFFD7\uFFFD\uFFFD\uFFFD\uFFFD\u001C\uFFFDF\uFFFD=\u0011\uFFFD\uFFFDfLs7\uFFFD\uFFFD\uFFFD\u000B\uFFFD\u0591\u0001\uFFFD@\uFFFD4^\uFFFD{\uFFFD\uFFFD-\uFFFD\uFFFDW\uFFFD\u0004\uFFFD{\u001C@\uFFFD\uFFFDJ\u001E\uFFFD\uFFFDe\uFFFDy\uFFFDb\uFFFD<\uFFFDX\uFFFD>\u0002\uFFFD`\uFFFDz\uFFFD\uFFFD\uFFFD\uFFFD\uFFFDԶ\uFFFD\u0013\uFFFD\uFFFD\uFFFD\uFFFD\u0000*\uFFFD\u0027\uFFFD*\uFFFD\uFFFD",
    "\uFFFDz䜷m[\uFFFDV_\uFFFD0\u0090\uFFFD\uFFFD\u001Fic\u0749\uFFFD\uFFFD\u0010\u001F\uFFFD\uFFFD\u001DXF\uFFFD\uFFFD":"I\uFFFD:Ⲋ\u000E\uFFFD\u0000\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\\0\u001A\uFFFD\uFFFD\uFFFDൡ\u0016\uFFFD\uFFFDA\uFFFD\uFFFD\u0600R\uFFFD\uFFFD\uFFFD6[\uFFFDW\u000F\u0017\u001C\uFFFDH+\u0018\uFFFD\uFFFDS\uFFFDu\u000F\uFFFD{E\uFFFD?\uFFFD\uFFFD\uFFFDw\uFFFD\u000F0R\uFFFD\uFFFD\uFFFDP\uFFFDX\u0012g\uFFFD5\uFFFD\uFFFDG\u0014\u0012\uFFFD\uFFFD\u0014\"Yv\uFFFDz\uFFFD(\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u000739\uFFFD\uFFFD\uFFFDN",
    "\uFFFD\uFFFD\u00013\uFFFD\u001F\uFFFDPSp\uFFFD\u0002\u000F\uFFFD\u05B5M\u0017\u001D\uFFFD\uFFFD)3\uFFFD>V":"\uFFFDi\t\u0002^GQ\uFFFD\u0000\uFFFDu=\uFFFD",
    "\uFFFD\uFFFD6\uFFFDz7\uFFFDY\uFFFD5OF\uFFFD\uFFFD\u0013k\uFFFD\uFFFDx&%\uFFFDu\uFFFD5\uFFFD!":"TCMb\u000B\uFFFD\uFFFD>\uFFFD\u001D\uFFFDX\uFFFD_g\uFFFD\u0015\uFFFD|\uFFFD\uFFFD\">\uFFFDKC\uFFFD",
    "\uFFFD\uFFFD95\u001E9\u0000\uFFFDehojL\uFFFDIY\uFFFD\uFFFDN\u0013\uFFFDx\uFFFD\uFFFDp\uFFFD\u0027\uFFFD\u0017\uFFFD3\u007F\uFFFD\uFFFDLJt\uFFFD\uFFFD\uFFFD\uFFFD\u0015Qh\u0017\uFFFD":"\uFFFD\uFFFD\uFFFD/.\uFFFD\uFFFD\u001E\uFFFD\uFFFD5\uFFFD\u001E\uFFFD*\u070F\uFFFDG\uFFFDh\uFFFDrj\uFFFD\uFFFD2\uFFFD\uFFFD\uFFFD\u0018ᇇ\uFFFDI>\uFFFD6\uFFFDp3<\u0010\uFFFD\uFFFD6\uFFFD\uFFFD\uFFFD\uFFFDJ\u000F\uFFFD\u001A\u0001@\uFFFD\uFFFD=\uFFFD=u\uFFFD^\uFFFD\uFFFD\\&`z8\uFFFD:3\uFFFD\uFFFD\uFFFDN\uFFFD\uFFFD\uFFFD\uFFFDƉS\u0002ÿk0*/(1\uFFFD\uFFFD\u0011\uFFFDd\uFFFD\uFFFDY\u0003<e\uFFFD!a",
    "\uFFFD\uFFFDEg0":"\uFFFD\uFFFD\uFFFDG\uFFFD\uFFFD\uFFFDF\u0007ߒ\uFFFD\bRd\uFFFD+ǹ<K\u0013.\u00057D7",
    "\uFFFD\uFFFDS\uFFFD":"\u0018>\uFFFDu>\u0014O\uFFFD#\uFFFD-r\uFFFDūW\uFFFDΛli\uFFFD\uFFFD\uFFFD\uFFFDA*\u0027\uFFFDD\uFFFD\uFFFD\u02D9\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD.\uFFFD\u0011M\uFFFD\u0018\uFFFD8\uFFFDo\uFFFDʩ\uFFFD\uFFFD\uFFFD.\uFFFDK\u0006\u0001\uFFFD\uFFFD\uFFFD\uFFFDP\uFFFD\u0013F\"\uFFFD\uFFFDK\uFFFDK\u0000wr \u001C/++DF\u0655߁\uFFFDJ.\u0002\uFFFD\uFFFD\uFFFD\uFFFD:B\u0005$\uFFFDQ\uFFFD\uFFFD\u0013\uFFFD\uFFFD6",
    "\uFFFD\uFFFDkh\uFFFDZ\u0017\uFFFDmh!\uFFFD\uD97F\uDFBE\uFFFD\uFFFD\uFFFD\"\uFFFD\uFFFD\uFFFDq-\uFFFD\uFFFD<\uFFFD\uFFFD":"\u001C\u000E\u00149\uFFFD6\uFFFD",
    "\uFFFD\uFFFDڈ\uFFFD\uFFFD\uFFFD\u0011\uFFFD\uFFFD(Rlv[C\uFFFD\u0019":"f\uFFFD\uFFFD~t`0g\u000F\u0001\uFFFD\uFFFD\u0002\uFFFD\uFFFD\uFFFD/\uFFFDD\uFFFD\u0014\uFFFD\uFFFD\uFFFDy1x\uFFFD\u0010\uFFFD\uFFFD\u0001\uFFFD*\u0018\u0007_\uFFFDuPs\uFFFD\uFFFD\uFFFDr\u000E\uFFFDOx \uFFFD\"\uFFFD\uFFFD\uFFFD \uFFFD\uFFFD\uFFFD|\uFFFD",
    [
        "\u0007t\uFFFD"
    ]:"\uFFFD\uFFFD\uFFFDPp\uFFFD\b\uFFFD\uFFFDӽS\uFFFD\uFFFD\uFFFD\uFFFD\u0006\uFFFD"
}