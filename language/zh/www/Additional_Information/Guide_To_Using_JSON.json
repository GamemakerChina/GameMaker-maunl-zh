{
    "A collection of name/value pairs, known as a \"map\", \"dictionary\" or \"object\" in programming languages. It is represented in&nbsp;{}GameMaker{}&nbsp;by a&nbsp;{}{}Struct{}{}&nbsp;or a&nbsp;{}{}DS Map{}{}.":"名称 / 值对的集合，在编程语言中称为 \" 映射\"、\"字典 \" 或 \" 对象\"。它在 {}GameMaker{} 中由 {}{}Struct{}{} 或 {}{}DS Map{}{} 表示。",
    "An ordered list of values, known as a \"list\",&nbsp;\"array\" or \"sequence\" in other programming languages. It is represented in&nbsp;{}GameMaker{}&nbsp;by an&nbsp;{}{}Array{}{}&nbsp;or a&nbsp;{}{}DS List{}{}.":"值的有序列表，在其他编程语言中称为 \" 列表\"、\"数组 \" 或 \" 序列\"。它在 {}GameMaker{} 中由 {}{}Array{}{} 或 {}{}DS List{}{} 表示。",
    "And then be written to a file using either the text file functions:&nbsp;":"然后使用文本文件函数写入文件：",
    "And you can use them like any other {}Vector{}&nbsp;struct:&nbsp;":"您可以像任何其他 {}Vector{} 结构一样使用它们：",
    "As an example, suppose you have a constructor {}Vector{}:&nbsp;":"例如，假设您有一个构造函数 {}Vector{}：",
    "At you point you might want to restore these vectors in another instance of the game, not just their values ({}x{}, {}y{} and {}z{}) but also their behaviour ({}add{}, {}sum{}, {}dot{}, ...).":"此时，您可能希望在游戏的另一个实例中恢复这些向量，不仅仅是它们的值 ({}x{}、{}y{} 和 {}z{})，还有它们的行为 ({}add{}, {}sum{}, {}dot{},...)。",
    "By default, string values in the JSON will be checked to see if they contain special values. If so, these values are converted to the internal&nbsp;{}GameMaker{}&nbsp;value. For example:&nbsp;":"默认情况下，将检查 JSON 中的字符串值以查看它们是否包含特殊值。如果是，这些值将转换为内部 {}GameMaker{} 值。例如：",
    "By default,&nbsp;{}{}json_stringify{}{}&nbsp;writes the JSON&nbsp;{}linearised{}. In this case everything is placed on the same line, with no space in between and no indentation added. This format is useful when every byte counts, though it is not particularly readable.":"默认情况下，{}{}json_stringify{}{} 写入 {} 线性化 {} 的 JSON。在这种情况下，所有内容都放在同一行上，中间没有空格，也没有添加缩进。当每个字节都很重要时，这种格式很有用，尽管它不是特别可读。",
    "By manually setting the&nbsp;{}Static Struct{} of the structs that&nbsp;{}{}json_parse{}{}&nbsp;returns with&nbsp;{}{}static_set{}{}&nbsp;you can restore those structs to their original state.":"通过手动设置 {}{}json_parse{}{} 使用 {}{}static_set{}{} 返回的结构的 {0} 静态结构 {1}，您可以将这些结构恢复到其原始状态。",
    "By using&nbsp;{}{}static_set{}{}&nbsp;on the structs you first detach them from the static as a simple \"data\" struct and reattach them to the static chain as \"child\" structs of the&nbsp;static struct of&nbsp;{}Vector{}. Since you can access all static members of the hierarchy of static structs (or constructors) a struct belongs to, this way you give the structs access to {}Vector{}\u0027s&nbsp;{}Static Chain{}, restoring their behaviour.":"通过在结构上使用 {}{}static_set{}{}，您首先将它们作为简单的 \" 数据 \" 结构与静态分离，然后将它们作为 {}Vector{} 静态结构的 \" 子 \" 结构重新附加到静态链。由于您可以访问结构所属的静态结构 (或构造函数) 层次结构的所有静态成员，因此您可以通过这种方式为结构提供对 {}Vector{} 的 {} 静态链 {} 的访问权限，从而恢复其行为。",
    "Can be converted to a&nbsp;JSON string using {}{}json_stringify{}{}:&nbsp;":"可以使用 {}{}json_stringify{}{} 转换为 JSON 字符串：",
    "Care should be taken when writing a&nbsp;JSON string to an INI file, as the INI specification can cause issues when using quotes and escape characters. See&nbsp;{}{}ini_write_string(){}{} for more information.":"将 JSON 字符串写入 INI 文件时应小心，因为 INI 规范在使用引号和转义字符时可能会导致问题。请参阅 {}{}ini_write_string(){}{} 了解更多信息。",
    "Circular references in DS maps, such as references back to the main map itself (forming an infinite loop) or references to maps within the main map forming such infinite loops, will be serialised only on the first level where they\u0027re encountered, and converted to {}null{}&nbsp;for deeper references. In the case of structs&nbsp;such references are immediately converted to {}null{}&nbsp;upon stringifying.":"DS 地图中的循环引用，例如对主地图本身的引用 (形成无限循环) 或对主地图内形成此类无限循环的地图的引用，将仅在遇到它们的第一级进行序列化并进行转换为 {}null{} 以获取更深入的参考。对于结构体，此类引用在字符串化时会立即转换为 {}null{}。",
    "Compared to the linearised output, the JSON above shows at a glance how the data is constructed.":"与线性化输出相比，上面的 JSON 一目了然地显示了数据的构造方式。",
    "Contents":"内容",
    "Data Conversions":"数据转换",
    "Filter Function":"过滤功能",
    "From here on, {}v1{}&nbsp;to {}v4{}&nbsp;{}are{}&nbsp;instances of&nbsp;{}Vector{}!":"从现在开始，{}v1{} 到 {}v4{} {}都是{}  {}Vector{} 的实例！",
    "Handles are stored in their string representation&nbsp;{}{}\"ref&nbsp;&lt;type&gt;&nbsp;&lt;id&gt;\"{}{}&nbsp;when writing JSON and are converted back to runtime values when reading back the JSON.{} {} The exception is when using&nbsp;{}{}json_encode{}{}: nested&nbsp;{}DS Maps{}&nbsp;and&nbsp;{}DS Lists{}&nbsp;that you\u0027ve {}marked{} {}as such{} will be written as JSON objects and arrays respectively.{} {} {}{}NOTE{}{} Relying on this behaviour will generally be of little use as the index will change between runs of the game. ":"写入 JSON 时，句柄存储在其字符串表示形式 {}{}“ref &lt;type&gt; &lt;id&gt;”{}{} 中，读回 JSON 时则转换回运行时值。{}\n\n{} 使用 {}{}json_encode{}{} 时会出现例外情况：\n您已{14}标记{15}的嵌套 {}DS Maps{} 和 {}DS List{} 将分别被写入 JSON 对象和数组。{}{}{}\n\n{} {}{}注意{}{} 依赖此行为通常没什么用，因为索引会在游戏运行之间发生变化。",
    "If you want full control over how the contents of the JSON are read or written, you can optionally provide a filter function that runs for each element to&nbsp;{}{}json_stringify{}{}&nbsp;and&nbsp;{}{}json_parse{}{}. See the function pages for more information.":"如果您希望完全控制 JSON 内容的读取或写入方式，您可以选择提供一个针对每个元素运行的过滤器函数，以便 {}{}json_stringify{}{} 和 {}{}json_parse{}{}。请参阅功能页面了解更多信息。",
    "In&nbsp;{}GameMaker{}, a struct is such a data structure. It can have both variables and functions as its members. When you stringify&nbsp;a struct\u0027s contents with {}{}json_stringify{}{}, only the struct\u0027s variables are written, not its functions.":"在 {}GameMaker{} 中，结构体就是这样一种数据结构。它可以包含变量和函数作为其成员。当您使用 {}{}json_stringify{}{} 对结构体的内容进行字符串化时，仅写入结构体的变量，而不写入其函数。",
    "JSON (JavaScript Object Notation) is a lightweight data-interchange format which is easy to read and write, for both people and machines. It is built on two basic structures:":"JSON(JavaScript 对象表示法) 是一种轻量级数据交换格式，对于人和机器来说都易于读写。它建立在两个基本结构之上：",
    "JSON in&nbsp;{}GameMaker{}":"{}GameMaker{} 中的 JSON",
    "Or the buffer functions:&nbsp;":"或者缓冲函数：",
    "Prettify":"美化",
    "Reading JSON":"读取 JSON",
    "Serialisation":"序列化",
    "The JSON standard has a limited number of values that it supports: an object, an array, a string, a number and the values&nbsp;{}true{}, {}false{}&nbsp;and&nbsp;{}null{}.&nbsp;{}GameMaker{}&nbsp;uses more&nbsp;{}Data Types{}&nbsp;than this and in order to store these&nbsp;in a way they can be read back later, it converts them to a string representation. Both the&nbsp;{}{}json_parse{}{}&nbsp;/&nbsp;{}{}json_stringify{}{}&nbsp;and&nbsp;{}{}json_decode{}{}&nbsp;/&nbsp;{}{}json_encode{}{}&nbsp;perform these conversions.":"JSON 标准支持的值数量有限：对象、数组、字符串、数字以及值 {}true{}、{}false{} 和 {}null{}。{}GameMaker{} 使用的 {} 数据类型 {} 比这更多，为了以稍后可以读回的方式存储这些数据，它将它们转换为字符串表示形式。{}{}json_parse{}{}/{}{}json_stringify{}{} 和 {}{}json_decode{}{}/{}{}json_encode{}{} 都会执行这些转换。",
    "The following code:&nbsp;":"以下代码：",
    "The following table lists the conversions that take place when converting between&nbsp;JSON&nbsp;data and&nbsp;{}GameMaker{}:&nbsp;":"下表列出了在 JSON 数据和 {}GameMaker{} 之间进行转换时发生的转换：",
    "The following text is the output:&nbsp;":"以下文本是输出：",
    "The structs have now been read back from the JSON string, but they are entirely new structs that don\u0027t belong to a constructor anymore. The structs were&nbsp;{}Vector{} structs in the original instance of the game, but aren\u0027t anymore. At least, not \"officially\", as you\u0027ll see with a call to the function {}{}instanceof{}{}:&nbsp;":"现在，这些结构已从 JSON 字符串中读回，但它们是完全新的结构，不再属于构造函数。这些结构在游戏的原始实例中是 {}Vector{} 结构，但现在不再是了。至少，不是 \" 官方 \" 的，正如您在调用函数 {}{}instanceof{}{} 时看到的那样：",
    "The {}prettify{} parameter can be set to {}true{} to add indentation to the generated JSON string to make it look \"pretty\", i.e. more human-readable.":"{}prettify{} 参数可以设置为 {}true{}，以向生成的 JSON 字符串添加缩进，使其看起来 \" 漂亮\"，即更易于人类阅读。",
    "The&nbsp;maximum nesting limit of the JSON string to be parsed or decoded is&nbsp;{}128{}.":"要解析或解码的 JSON 字符串的最大嵌套限制为 {}128{}。",
    "These four vectors can be stored in an array and converted to JSON using&nbsp;{}{}json_stringify{}{}:":"这四个向量可以存储在数组中，并使用 {}{}json_stringify{}{} 转换为 JSON：",
    "This JSON string can be saved or sent somewhere else.":"该 JSON 字符串可以保存或发送到其他地方。",
    "This guide focuses on the functions&nbsp;{}{}json_parse{}{}&nbsp;and&nbsp;{}{}json_stringify{}{}.":"本指南重点介绍函数 {}{}json_parse{}{} 和 {}{}json_stringify{}{}。",
    "This page describes how to work with JSON in&nbsp;{}GameMaker{}.":"本页介绍如何在 {}GameMaker{} 中使用 JSON。",
    "To get the information back into structs you parse the JSON string using&nbsp;{}{}json_parse{}{} and then assign the individual array elements to the variable names used earlier:&nbsp;":"要将信息返回到结构中，您可以使用 {}{}json_parse{}{} 解析 JSON 字符串，然后将各个数组元素分配给之前使用的变量名称：",
    "To read data from a previously created JSON string, you turn it into a struct using&nbsp;{}{}json_parse{}{}:&nbsp;":"要从之前创建的 JSON 字符串中读取数据，您可以使用 {}{}json_parse{}{} 将其转换为结构体：",
    "To tell&nbsp;{}GameMaker{}&nbsp;that&nbsp;each of these structs should, once again, belong to the {}Vector{} constructor, you can use the function&nbsp;{}{}static_set{}{}:&nbsp;":"要告诉 {}GameMaker{} 这些结构中的每一个都应再次属于 {}Vector{} 构造函数，您可以使用函数 {}{}static_set{}{}：",
    "Usage Notes":"使用说明",
    "Use&nbsp;{}{}json_encode{}{}&nbsp;and&nbsp;{}{}json_decode{}{}&nbsp;when working with&nbsp;{}Data Structures{}. The item passed to&nbsp;{}{}json_encode{}{}&nbsp;(the \"root\") must always be a&nbsp;{}{}DS Map{}{}. Similarly,&nbsp;{}{}json_decode{}{}&nbsp;always returns a DS map, no matter the data type that you pass it (anything you pass to the function that\u0027s not a DS map is wrapped in one).":"使用 {} 数据结构 {} 时，请使用 {0}{1}json_encode{2}{3} 和 {4}{5}json_decode{6}{7}。传递给 {}{}json_encode{}{}(\" 根 \") 的项目必须始终是 {}{}DS Map{}{}。同样，{}{}json_decode{}{} 始终返回一个 DS 映射，无论您传递给它的数据类型是什么 (您传递给函数的所有非 DS 映射都将封装在一个 DS 映射中)。",
    "Use&nbsp;{}{}json_encode{}{}&nbsp;on a&nbsp;{}{}DS Map{}{}&nbsp;that contains nested&nbsp;{}structs{}&nbsp;and&nbsp;{}Arrays{}. The structs and arrays will also be converted to JSON, i.e.&nbsp;{}{}json_encode{}{} allows you to convert a mixed hierarchy.":"在包含嵌套 {8} 结构 {9} 和 {10} 数组 {11} 的 {4}{5}DS Map{6}{7} 上使用 {}{}json_encode{}{}。结构体和数组也将转换为 JSON，即 {}{}json_encode{}{} 允许您转换混合层次结构。",
    "Which Functions to Use":"使用哪些功能",
    "Writing JSON":"编写 JSON",
    "Writing JSON is done with {}{}json_stringify{}{}. For example, the following struct:&nbsp;":"编写 JSON 是通过 {}{}json_stringify{}{} 完成的。例如，以下结构体：",
    "You can also send the JSON string over a network or store it somewhere else (e.g. in a text field in a database).":"您还可以通过网络发送 JSON 字符串或将其存储在其他位置 (例如数据库的文本字段中)。",
    "You then create a few of these vectors:&nbsp;":"然后，您创建其中一些向量：",
    "{}GameMaker{} will write it as:{} - an {}int{} if it\u0027s in the valid range for an int32.{} - a {}double{} if it can do so without losing precision.{} - a {}string{} with an identifier {}\"@i64@\"{} before it and {}\"$i64$\"{} after it&nbsp;if neither of those cases is applicable{}.{}{} {} When you read the&nbsp;JSON&nbsp;again,&nbsp;{}GameMaker{} will pick up these identifiers and convert the value back into an int64 (unless conversion is disabled).{} {} {}{}WARNING{}{} If the JSON is intended for a server or some other non-{}GameMaker{} target, these values will not be appropriate and so should be avoided. ":"{}GameMaker{} 会将其写为：{}- 如果在 int32 的有效范围内，则为 {}int{}。{}- 如果可以在不丢失精度的情况下这样做，则为 {}double{}。{}- 一个 {} 字符串 {}，其前面带有标识符 {}\"@i64@\"{}，后面带有标识符 {}\"$i64$\"{}( 如果这两种情况都不适用)。{}{}{}{} 当您再次读取 JSON，{}GameMaker{} 将获取这些标识符并将值转换回 int64( 除非禁用转换)。{}{}{}{} 警告 {}{} 如果 JSON 用于服务器或某些其他非 {}GameMaker{} 目标，这些值不合适，因此应避免使用。",
    "{}GameMaker{}&nbsp;has built-in support for reading and writing&nbsp;JSON through two sets of functions:&nbsp;":"{}GameMaker{} 通过两组函数内置支持读取和写入 JSON：",
    "{}Guide To Using JSON{}":"{}JSON 使用指南 {}",
    "{}NaN{} is written as a string":"{}NaN{} 写为字符串",
    "{}Serialisation{} is described as follows:&nbsp;":"{} 序列化{} 描述如下：",
    "{}infinity{} is written as a string":"{} infinity{} 被写为字符串",
    "{}undefined{} and {}pointer_null{} are written as JSON {}null{}. JSON {}null{} is always read back as {}undefined{}&nbsp;when&nbsp;{}parsing{}&nbsp;or&nbsp;{}decoding{}.":"{}undefined{} 和 {}pointer_null{} 写入为 JSON{}null{}。{10}解析{11} 或 {12}解码{13} 时，JSON{}null{} 始终会读回为 {} undefined {}。",
    "{}{}IMPORTANT{}{}&nbsp;In order for this to work, the functions must be defined as static so they belong to the {}constructor{}, rather than to the struct {}instance{}. If you don\u0027t declare the functions as static, each struct instance should receive a copy of the function through execution of the constructor. However, setting the static struct with&nbsp;{}{}static_set{}{} doesn\u0027t call the constructor, rather it moves the struct to a different place in the&nbsp;{}Static Chain{}&nbsp;which enables it to access a different static struct\u0027s functions (see&nbsp;{}How the Dot Operator Looks Up a Variable Name{}).":"{}{} 重要{}{} 为了使其正常工作，函数必须定义为静态，以便它们属于 {} 构造函数 {}，而不是结构体 {} 实例 {}。如果不将函数声明为静态，则每个结构体实例都应通过执行构造函数来接收该函数的副本。不过，使用 {}{}static_set{}{} 设置静态结构不会调用构造函数，而是将该结构移动到 {} 静态链 {} 中的不同位置，从而使其能够访问不同静态结构的函数 (请参阅 {} 点运算符如何查找变量名称 {})。",
    "{}{}IMPORTANT{}{}&nbsp;JSON is {}agnostic{} about numbers. In any programming language, there can be a variety of number types of various capacities and complements, fixed or floating, binary or decimal. That can make interchange between different programming languages difficult. JSON instead offers only the representation of numbers that humans use: a sequence of digits. All programming languages know how to make sense of digit sequences even if they disagree on internal representations. For more information see the {}ECMA JSON Standard{}.":"{}{} 重要{}{}JSON 与数字 {} 无关 {}。在任何编程语言中，都可以有各种不同容量和补数的数字类型，固定或浮动，二进制或十进制。这会使不同编程语言之间的互换变得困难。相反，JSON 只提供人类使用的数字表示形式：数字序列。所有编程语言都知道如何理解数字序列，即使它们在内部表示上存在分歧。如需了解更多信息，请参阅 {}ECMA JSON 标准 {}。",
    "{}{}NOTE{}{}&nbsp;You can disable the automatic string conversion when parsing&nbsp;JSON by setting the&nbsp;{}inhibit_string_convert{} argument of&nbsp;{}{}json_parse{}{}&nbsp;to {}true{}.":"{}{} 注意{}{} 您可以通过将 {6}{7}json_parse{8}{9} 的 {}inhibit_string_convert{} 参数设置为 {}true{} 来禁用解析 JSON 时的自动字符串转换。",
    "{}{}NOTE{}{}&nbsp;You can only serialise&nbsp;{}structs{}&nbsp;this way in&nbsp;{}GameMaker{}, not&nbsp;{}Data Structures{}&nbsp;or {}Instances{}.":"{}{} 注意{}{} 您只能在 {}GameMaker{} 中以这种方式序列化 {} 结构 {}，而不能序列化 {} 数据结构 {} 或 {} 实例 {}。",
    "{}{}json_encode{}{}&nbsp;and&nbsp;{}{}json_decode{}{}&nbsp;which you use to convert a JSON string to a collection of {}DS Maps{}&nbsp;and {}DS Lists{}&nbsp;and back. Encoding requires you to {}mark{}&nbsp;{}DS map keys{} and {}DS list items{} as such (so it is clear which map keys and list items should become nested JSON objects and arrays).":"{}{}json_encode{}{} 和 {}{}json_decode{}{}，用于将 JSON 字符串与 {}DS Maps{} 和 {}DS Lists{} 的集合相互转换。编码要求您 {} 标记 {}{}DS 映射键 {} 和 {}DS 列表项 {}( 以便清楚哪些映射键和列表项应成为嵌套 JSON 对象和数组)。",
    "{}{}json_parse{}{}&nbsp;and&nbsp;{}{}json_stringify{}{}&nbsp;are the main functions to use when working with JSON. If you\u0027re not using any&nbsp;{}Data Structures{}&nbsp;or when you start a new project, these are the functions to use.":"{}{}json_parse{}{} 和 {}{}json_stringify{}{} 是处理 JSON 时使用的主要函数。如果您不使用任何 {} 数据结构 {} 或者当您启动新项目时，可以使用这些函数。",
    "{}{}json_parse{}{}&nbsp;and&nbsp;{}{}json_stringify{}{}&nbsp;which you use to convert a JSON string to a collection of {}Structs{}&nbsp;and&nbsp;{}Arrays{}&nbsp;and back.":"{}{}json_parse{}{} 和 {}{}json_stringify{}{}，用于将 JSON 字符串与 {} 结构 {} 和 {} 数组 {} 的集合相互转换。"
}