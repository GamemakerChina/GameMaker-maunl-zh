{
    "As you can see, the difference is pretty obvious, and if the instance moves more than 1 or 2 pixels per step, then it becomes very noticiable that diagonal movement is {}much {}faster! So how do we limit this? There are a number of ways to go about this, but we\u0027re going to concentrate on just one of them, because it introduces a couple of functions and concepts that will be useful to you later on in your games.":"正如您所看到的，差异非常明显，如果实例每步移动超过1或2个像素，那么对角线移动就会变得{}非常{}明显！那么，我们如何限制这一点呢？有很多方法可以做到这一点，但我们将只关注其中的一种，因为它引入了几个函数和概念，这些函数和概念将在稍后的游戏中对您有用。",
    "Before going any further, you might want to make a new project (either GML or GML Visual) from the {}Start Page{}, and add (or create) a few sprites as well as an object or two - as we\u0027ll be giving you some code that you can test using these - and make sure that the project has a room to place instances in. Don\u0027t worry too much about what the sprites you make look like, as even a simple white square will do, and once you\u0027ve&nbsp;got everything ready you can start working on the examples listed below.":"在继续之前，您可能希望从{}开始页{}创建一个新项目(GML或GML可视化)，并添加(或创建)几个精灵以及一个或两个对象--因为我们将提供一些代码，您可以使用这些代码进行测试-并确保项目有空间放置实例。不要太担心你制作的精灵看起来像什么，即使是一个简单的白色方块也可以，一旦你准备好了，你就可以开始制作下面列出的例子了。",
    "Before we leave this example, there is one final issue that we need to resolve... If you click and {}hold {}the mouse button, but don\u0027t move the cursor, then the instance will move towards the cursor and then \"vibrate\" around it. This is because the instance is moving faster than 1 pixel at a time and so \"over-shoots\" the position and then tries to move back, and then over-shoots again, etc... (make the movement speed 5 or something like that to see the issue if it\u0027s not immediately obvious).":"在我们离开这个例子之前，我们需要解决最后一个问题...。如果您单击并{}按住{}鼠标按钮，但不移动光标，则实例将朝向光标移动，然后绕着它“振动”。这是因为实例一次移动的速度超过1个像素，因此会“过度拍摄”该位置，然后尝试向后移动，然后再次过度拍摄，依此类推。(如果问题不是很明显，请将移动速度设置为5或类似的值以查看问题)。",
    "Finally, we use the {}{}lengthdir_x(){}{}&nbsp;and {}{}lengthdir_y(){}{}&nbsp;functions to actually move the variable. These are {} {}vector{}&nbsp;{}functions that take a length (distance) and a direction and then calculate the new position on the given axis based on these values (see the function descriptions for a more in-depth explanation).":"最后，我们使用 {}{}lengthdir_x(){}{} 和 {}{}lengthdir_y(){}{} 函数来实际移动变量。这些是 {}{} 向量 {}{} 函数，它们获取长度 (距离) 和方向，然后根据这些值计算给定轴上的新位置 (有关更深入的说明，请参阅函数说明)。",
    "Here we are checking the {}left {}stick for horizontal or vertical movement. The axis functions return a value between -1 and 1, so for the horizontal axis -1 is left, 0 is not moving and 1 is right, and for the vertical axis it\u0027s -1 for up, 0 for not moving and 1 for down. Note too that the values are {}between {}-1 and 1, so - for example - the horizontal axis could return a value of 0.5, meaning the stick is halfway between the \"rest\" position and fully pushed to the right. For that reason, we then multiply the value by 4 (you can multiply by any value really, depending on the speed you want the instance to move) - it means that the speed of the instance will vary depending on how much of a movement has been made on the stick axis.":"在这里，我们正在检查 {} 左 {} 杆是否水平或垂直移动。轴函数返回一个介于 -1 和 1 之间的值，因此对于水平轴，-1 为左，0 不移动，1 为右，而对于垂直轴，它为 -1，表示向上，0 表示不移动，1 表示向下。还请注意，这些值介于 {}-1 和 1 之间，因此-例如-水平轴可能返回值 0.5，这意味着操纵杆处于 \" 静止 \" 位置的中间，并完全向右推。出于这个原因，我们将该值乘以 4( 实际上可以乘以任何值，具体取决于您希望实例移动的速度 )- 这意味着实例的速度将根据在杆轴上移动的程度而有所不同。",
    "Here we are telling the instance to move towards a position on the screen, in this case the \"{}mouse_x{}\" and \"{}mouse_y{}\" position (\"{}mouse_x{}\" and \"{}mouse_y{}\" are {}built-in {} {}variable{}{}s{} that always hold the current mouse cursor position). The GML Visual does this by setting the \"{}direction{}\"&nbsp;and \" {}speed{}\"&nbsp;{}{}Instance Variables{}{}, while the GML does this using the function {}{}move_towards_point(){}{}&nbsp;(this also sets the {}speed {}and {}direction {}variables, just in a single, easy to use function).":"在这里，我们告诉实例向屏幕上的某个位置移动，在本例中是\"{}mouse_x{}\"和\"{}mouse_y{}\"位置(\"{}mouse_x{}\"和\"{}mouse_y{}\"是始终保持当前鼠标光标位置的{}内置{}{}变量{}{}{})。GML 可视化通过设置\"{}方向{}\"和\"{}速度{}\"{}{}实例变量{}{}，而GML使用函数 {}{}move_towards_point(){}{} (这也只在一个简单易用的函数中设置{}速度{}和{}方向{}变量)来实现这一点。",
    "Here we just check the distance from the instance to the mouse position, and if it\u0027s the same as or less than the current speed, we set the speed to 0. This makes the instance stop when it\u0027s close enough to the mouse position, and we don\u0027t get that nasty \"vibrating\" issue.":"在这里，我们只检查从实例到鼠标位置的距离，如果它等于或小于当前速度，则将速度设置为0。这会使实例在足够接近鼠标位置时停止，并且我们不会遇到讨厌的\"振动\"问题。",
    "In this final example, we\u0027re going to re-visit our 8-way movement code and address an issue it has, which is that diagonal movement is actually faster than up/down/left/right movement. This is simply because when moving diagonally, you are moving along the hypotenuse of a right-angled triangle created by the x/y movement values:":"在这个最后的例子中，我们将重新访问我们的8向移动代码，并解决它存在的一个问题，即对角线移动实际上比上/下/左/右移动更快。这只是因为当沿对角线移动时，您将沿着由 X/Y 移动值创建的直角三角形的斜边移动：",
    "Notice that in the above code we set the {} {}deadzone{}&nbsp;{}for the gamepad. This is because analog sticks on different makes of gamepads will have different sensibility, and sometimes they can be so sensitive that if you don\u0027t set a deadzone then they can cause unwanted movement in your games. So we set the deadzone to a value like 0.2 to tell {}GameMaker{} to ignore any gamepad stick values under that {}absolute{} value.":"请注意，在上面的代码中，我们为游戏手柄设置了{}{}死区{}{}。这是因为不同品牌的游戏手柄上的模拟杆会有不同的敏感度，有时它们会非常敏感，如果你不设置死区，它们可能会在你的游戏中造成不必要的移动。因此，我们将死区设置为类似 0.2 的值，以告诉 {}GameMaker{} 忽略该 {} 绝对值 {} 下的所有游戏手柄操纵杆。",
    "Now we can add the code that actually moves the instance, so - still in the {}Step Event{}, and after the above code - add this:":"现在，我们可以添加实际移动实例的代码，因此-仍然在{}步事件{}中，在上面的代码之后-添加以下代码：",
    "Now when you press the {}Play {}button {} it\u0027ll look something like this:":"现在，当您按下{}播放{}按钮{}时，它将如下所示：",
    "One final thing that\u0027s worth noting for users coding with GML... When using the GML Visual you can select the keyboard key that you want to use from a drop down list, but with GML it\u0027s not that simple. There are a number of {}Keyboard Constants{}&nbsp;that you can use - like the arrow key constants shown in the code above - but there are {}no {}constants for the alpha-numeric keys. These are handled slightly different, and require you to use the function {}{}ord(){}{}. The code below shows you how this would work using WASD instead of the arrow keys:":"对于使用 GML 代码的用户来说，最后一件值得注意的事情是 ...。当使用 GML 可视化时，您可以从下拉列表中选择想要使用的键盘键，但使用 GML 就没有那么简单了。您可以使用许多 {} 键盘常量 {} -- 就像上面代码中显示的箭头键常量一样 -- 但字母数字键{}没有{}常量。它们的处理方式略有不同，需要使用函数 {}{}ord(){}{}。下面的代码向您展示了如何使用 WASD 而不是箭头键来执行此操作：",
    "One of the simplest ways to get an object moving and interacting with the player is to use the mouse, and in this example we\u0027ll show you how to use some basic code to get an object to move towards wherever the user has clicked the left mouse button {}.":"让对象移动并与玩家交互的最简单方法之一是使用鼠标，在本例中，我们将向您展示如何使用一些基本代码使对象移动到用户单击鼠标左键{}的任何位置。",
    "Place an instance of this object in a room and pres the press {}Play {}button {} {}{}, then move around using the left stick of your connected gamepad. You should see something like this:":"将该对象的一个实例放置在一个房间中，按下{}播放{}按钮{}{}{}，然后使用连接的游戏板的左手柄四处移动。您应该会看到类似这样的内容：",
    "Place an instance of this object in a room and then hit the Play button {}, then click {} around the room to make the instance move towards the mouse:":"将此对象的一个实例放置在房间中，然后点击播放按钮 {}，然后在房间周围单击 {}，使该实例向鼠标移动：",
    "That\u0027s a lot to take in at once, and don\u0027t worry if you don\u0027t quite understand it all! You will in time! All that\u0027s left to do now is add an instance of this object to a room, and then press the {}Play {}button {} {}{}, and you should get silky-smooth 8 way movement without any of the issues related to moving diagonally:":"这一次要理解的东西很多，如果你还不完全理解，也不要担心！你迟早会的！现在要做的就是将这个对象的一个实例添加到一个房间中，然后按下{}播放{}按钮{}{}{}，您应该会得到丝滑的8向移动，而不会出现任何与对角移动相关的问题：",
    "The above code first checks to see if one of two {}expression{}{}s{} is true, ie: if the horizontal or vertical speed variables are not 0. Note how the \" {}if{}\" GML check uses the symbol \" {}||{}\". This means \" {}or{}\" when programming, so - in plain language - you are checking":"上面的代码首先检查两个{}表达式{}{}{}中是否有一个为真，即水平或垂直速度变量是否不为0。请注意 \"{}if{}\" GML 检查如何使用符号 \"{}||{}\"。在编程时，这意味着 \"{}或{}\"，所以--用通俗易懂的语言--你是在检查",
    "The next section of code stores a value for the&nbsp;actual movement speed in a variable and then gets a direction using the {}_hspd {}and {}_vspd {}values, which can be -1, 0, or 1. The direction function checks from (0, 0) as we aren\u0027t using room coordinates, and instead we want it to evaluate as a direction from 0° to 360° based on the variable values. The following diagram illustrates what\u0027s happening better than trying to explain it in words:":"代码的下一部分将 ；实际移动速度的值存储在一个变量中，然后使用 {}_hspd{} 和 {}_vspd{} 值获得方向，这些值可以是 -1、0 或 1。方向函数检查 (0，0)，因为我们没有使用房间坐标，而是希望根据变量值将其计算为从 0°到 360°的方向。下面的图表说明了正在发生的事情，而不是试图用语言来解释：",
    "The {}previous section{} of this Quick Start Guide gave some examples for drawing things to the screen, but just drawing things isn\u0027t much good if you can\u0027t also move them around... so in this section we\u0027ll be giving you some examples of movement for your objects, as well as some basic control schemes for different types of games. All the examples are given using GML Visual as well as the GML Code, so you can use whichever you feel more comfortable with. Note that we won\u0027t be explaining things in too much depth here, as we want you to get started making stuff as quickly as possible, so we encourage you to explore any links as you go along and to use the \"search\" function of the manual to look for additional information on anything you aren\u0027t sure about.":"本快速入门指南的 {} 前一节 {} 给出了一些将东西画到屏幕上的例子，但如果你不能移动它们，那么只画东西并不是很好……。因此，在这一节中，我们将为您的对象提供一些移动的例子，以及不同类型游戏的一些基本控制方案。所有的示例都是使用 GML 可视化和 GML 代码给出的，所以您可以使用您觉得更舒服的任何一个。注意，我们不会在这里做太深入的解释，因为我们希望你尽快开始制作东西，所以我们鼓励你在进行过程中探索任何链接，并使用手册的 \"搜索\" 功能来寻找关于任何你不确定的东西的其他信息。",
    "This type of movement is called {}positional {}movement, as we are essentially picking up the instance and placing it down again at a new position every time the code is run. What we\u0027re going to do in this example is show you how to use this type of movement to move an instance around in 4&nbsp;directions:&nbsp;up, down, left and right.":"这种类型的移动称为{}位置{}移动，因为我们实质上是在每次运行代码时拿起实例并将其放在新位置。在本例中，我们要做的是向您展示如何使用这种移动方式在4个方向上移动实例：向上、向下、向左和向右。",
    "To add the actual movement, we\u0027ll need a {}Step Event{}, so add that now and give it the following GML Visual or GML:":"要添加实际的移动，我们需要一个{}步事件{}，因此现在添加该事件，并为其提供以下 GML 可视化或 GML：",
    "To deal with this, we are going to have to store the input values from the keys pressed independently in {}variable{}{}s{}, and then check them and move according to the combination of keys that have been pressed. So, for this you\u0027ll need an object with a sprite assigned, and you\u0027ll need to give it a {}Step Event{} with the following actions or code:":"为了处理这个问题，我们将不得不将来自独立按下的键的输入值存储在{}变量{}{}{}中，然后检查它们并根据已经按下的键的组合进行移动。因此，您将需要一个分配了精灵的对象，并且需要为其提供一个带有以下操作或代码的{}步事件{}：",
    "To make it clearer what\u0027s happening, let\u0027s remove all the text and sprites and simply show the same line of movement roated 45° so it\u0027s horizontal:":"为了更清楚地了解发生了什么，让我们删除所有文本和精灵，并简单地显示相同的移动线旋转 45°，因此它是水平的：",
    "To start with, open an object and assign it a sprite. Now, we could add in various {}Keyboard Events{} at this point, and in each one have the instance move in the desired direction, however, we only want the player to be able to move in one direction at a time and doing this with only the keyboard events&nbsp;is a bit more complicated than doing it using code. Instead we\u0027ll be using the {}Step Event{} - which you should add now to the object - with the following actions or code to use the Arrow Keys to move:":"首先，打开一个对象并为其指定一个精灵。现在，我们可以在这一点上添加各种{}键盘事件{}，并在每个事件中让实例向所需的方向移动，但是，我们希望玩家一次只能向一个方向移动，并且只使用键盘事件来做这件事比使用代码要复杂一些。相反，我们将使用{}步事件{} - 您现在应该将其添加到对象 - 以及使用箭头键移动的以下操作或代码：",
    "To start with, open an object, assign it a sprite, and then give it a {}Global Left Mouse Down event{}:":"首先，打开一个对象，为其指定一个精灵，然后为其指定一个{}全局鼠标左键按下事件{}：",
    "To start with, we need to detect the gamepad being used. Gamepads are given an ID value from 0 to 11, so we will use a \" {}for{}\" loop to detect the ID of any connected gamepads and store this ID value in a variable for future use. Since we only want to setect the first gamepad that is connected and not all of them, we will use the \" {}break{}\" command after we detect a gamepad so that the it \"breaks\" the loop (for example, if the first gamepad connected is ID 4, then the loop will only run 5 times, checking the ID values 0 - 4 and then breaking out of the loop when the gamepad is encountered). So, make (or open) an object, assign it a sprite, and then add a {}Create Event{} with the following:":"首先，我们需要检测正在使用的游戏手柄。游戏手柄被赋予一个从 0 到 11 的 ID 值，因此我们将使用 \"{}for{}\" 循环来检测任何连接的游戏手柄的 ID，并将该 ID 值存储在一个变量中以备将来使用。因为我们只想设置第一个连接的游戏手柄，而不是所有的游戏手柄，所以我们将在检测到游戏手柄后使用 \"{}Break{}\" 命令，以便它 \" 中断 \" 循环 (例如，如果第一个连接的游戏手柄是 ID4，则循环将只运行 5 次，检查 ID 值 0-4，然后在遇到游戏手柄时退出循环)。因此，创建 (或打开) 一个对象，为其指定一个精灵，然后添加一个具有以下内容的 {} 创建事件 {}：",
    "We are using an \" {}if... else if... else if...{}\" structure to ensure that the instance will only move in one direction at a time, and so the instance should only be able to move up, down, left or right, but not diagonally. Place an instance of the object in a room and press the {}Play {}button {} to test it now! If all has gone correctly, you should have something like this:":"我们使用\" {}if... else if... else if...{}\" 结构来确保实例一次只能向一个方向移动，因此实例应该只能向上、向下、向左或向右移动，但不能沿对角线移动。将该对象的一个实例放置在房间中，然后按下 {} 播放 {} 按钮 {} 立即测试它！如果一切正常，您应该会看到如下内容：",
    "We can modify this code to convert the 4-way movement into 8-way movement easily too... simply remove the \" {}else{}\" commands from the code blocks so that everything looks like this:":"我们可以修改这个代码，将4向移动转换为8向移动也很容易……。只需从代码块中删除“{}Else{}”命令，使一切看起来如下所示：",
    "We use the {}global {}mouse events because they detect a click anywhere in the room, while the regular mouse events will only detect a click if the mouse actually clicks within the instance {}bounding box{}. In this event we want to add these actions or code:":"我们使用{}全局{}鼠标事件，因为它们检测到房间中任何位置的单击，而常规鼠标事件仅在鼠标实际在实例{}边界框{}内单击时才检测到单击。在这种情况下，我们希望添加以下操作或代码：",
    "We\u0027ll need to add some more code to actually move, but before we do, let\u0027s just explain this a bit. We want to convert left/right/up/down into equivalent horizontal and vertical speed values, so to do that we are getting the value of each key and then doing some basic maths on it to get the speed values. This works because if a key is being pressed then the check action or function will return \"1\", and if it\u0027s {}not {}being pressed, then the function will return 0. So, if - for example - right is being pressed, you have \"1 - 0 = 1\" for the \" {}_hspd{}\", and if left is being pressed you have \"0 - 1 = -1\" for the \" {}_hspd{}\" (and if they both get pressed then it\u0027s \"1 - 1 = 0\", so the instance won\u0027t move). Remember, in a {}GameMaker{} room, to move right we add to the {}x {}position and to move left we subtract, so this code will give us a positive or negative value that we can add or subtract to move horizontally or vertically depending on the keyboard input.":"我们需要添加更多代码才能实际移动，但在此之前，让我们先解释一下这一点。我们想要将左 / 右 / 上 / 下转换为相等的水平和垂直速度值，因此，我们得到每个关键点的值，然后对其进行一些基本数学运算，以获得速度值。这是因为如果一个键被按下，那么检查操作或函数将返回 \"1\"，如果它 {} 没有 {} 被按下，则函数将返回 0。因此，例如，如果按下右键，则 \"{}_hspd{}\" 的值为 \"1-0=1\"，如果按下左键，则 \"{}_hspd{}\" 的值为 \"0-1=-1\"( 如果同时按下这两个键，则为 \"1-1=0\"，因此实例不会移动)。请记住，在 {}GameMaker{} 房间中，要向右移动，我们要添加到 {}x{} 位置，要向左移动，我们要减去。因此，此代码将为我们提供一个正值或负值，我们可以根据键盘输入进行相加或相减，以水平或垂直移动。",
    "We\u0027ve covered mouse movement and keyboard movement, so that means it\u0027s time to cover {}gamepad {}movement. Now, we won\u0027t be covering the d-pad, as really that works just like using the keyboard (simply change the keyboard functions in the above example for {}{}gamepad_button_check(){}{}&nbsp;or {}If Gamepad button Down{}), so in this example we\u0027ll look at using the analog stick for movement.":"我们已经介绍了鼠标移动和键盘移动，这意味着是时候介绍 {} 游戏手柄 {} 移动了。现在，我们将不介绍数字键盘，因为它的工作原理与使用键盘一样 (只需将上述示例中的键盘功能更改为 {}{}gamepad_button_check(){}{} 或 {} 如果手柄按钮按下 {})，因此在此示例中，我们将查看使用模拟杆进行移动。",
    "With these examples -&nbsp;and the previous ones for drawing -&nbsp;we hope that you\u0027ve got enough of an understanding to start making your own projects! The last page of this Quick Start Guide contains a summary of some of the things you\u0027ve learned as well as links to additional learning materials.":"有了这些例子 - 和之前的绘制 - 我们希望你有足够的理解来开始制作你自己的项目！本快速入门指南的最后一页包含您所学到的一些内容的摘要以及指向其他学习材料的链接。",
    "With this, the instance will only follow the mouse cursor for as long as the mouse button is held down, and when you release the button it will stop moving. Press Play {} and test it now.":"这样，只要按住鼠标按钮，实例就会一直跟随鼠标光标，而当您松开按钮时，它将停止移动。按播放 {} 并立即测试它。",
    "You can string multiple expressions together in \" {}if{}\" checks in this way, and there are multiple different ways those expressions can be evaluated (for more information please see the section on {}Expressions{} {}here{}).":"通过这种方式，您可以在 \"{}if{}\" 检查中将多个表达式串在一起，并且有多种不同的方法可以计算这些表达式(有关更多信息，请在{4}此处{5}参阅有关{}表达式{}的小节)。",
    "if the variable _hspd does not equal zero{} or{} if the variable _vspd does not equal zero ":"如果变量 _hspd 不等于零{}或{}如果变量 _vspd 不等于零",
    "{}4-Way and 8-Way Movement With The Keyboard{}{}4-Way and 8-Way Movement With The Keyboard{}":"{}键盘的4向和8向移动{}{}键盘的4向和8向移动{}",
    "{}Advanced 8-Way Movement{}{}Advanced 8-Way Movement{}":"{}高级8向移动{}{}高级8向移动{}",
    "{}Gamepad Movement{}{}Gamepad Movement{}":"{}游戏手柄移动{}{}游戏手柄移动{}",
    "{}Great! The instance of the object now moves towards where you clicked, and if you hold down the button, the instance will just keep following the mouse cursor. However, there is a problem... After you click once and release, the instance will keep on moving and eventually leave the room! There are a number of ways that we can fix this, and which one you choose will depend on what you want to do, but the easiest fix for now is to simply add a {}Global Mouse Button Released{} event, so add that now to the object and give it this code:":"{}太棒了！对象的实例现在向您单击的位置移动，如果您按住按钮，该实例将继续跟随鼠标光标。然而，有一个问题……。单击一次并释放后，实例将继续移动并最终离开房间！我们有许多方法可以修复此问题，您可以选择哪种方法取决于您想要做什么，但目前最简单的修复方法是只需添加一个{}全局鼠标按钮释放{}事件，因此现在将其添加到对象并给出以下代码：",
    "{}Move Towards The Mouse{}{}Move Towards The Mouse{}":"{}向鼠标移动{}{}向鼠标移动{}",
    "{}Movement And Controls{}":"{}移动及控制{}",
    "{}NOTE{}&nbsp;We\u0027ve split the Visual actions above over two columns to make it easier to visualise, but in the Visual editor, it will be placed consecutively.":"{}注意{} 我们已将上面的可视操作拆分到两列中，以便于可视化，但在可视编辑器中，它将被连续放置。",
    "{}Right at the start of this guide{}, we showed you the following action and code to move an instance to the right by two pixels every game step:":"{}在本指南的开头{}，我们向您展示了以下操作和代码，用于在每个游戏步骤中将实例向右移动两个像素：",
    "{}To solve this we need to add a {}Step Event{} to the object with this code:":"{}要解决此问题，我们需要使用以下代码向对象添加一个{}步事件{}：",
    "{}{}NOTE{}{}&nbsp;Direction in {}GameMaker{} is calculated {}counter clockwise{}, so 0° and 360°&nbsp;are&nbsp;to the right, 90° is up, 180° is to the left and 270° is down.":"{}{}注意{}{} 在{}GameMaker{} 中的方向是按{}逆时针{}计算的，所以 0° 和 360° 是向右，90° 是向上，180° 是向左，270° 是向下。"
}