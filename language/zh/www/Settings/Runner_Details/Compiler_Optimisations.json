{
    "Automatic Optimisations":"自动优化",
    "See&nbsp;{}{}gml_pragma{}{}&nbsp;for the full list of optimisations you can use and how to use them.":"请参阅 {}{}gml_pragma{}{}，了解您可以使用的优化的完整列表以及如何使用它们。",
    "Strings:&nbsp; {} {}When being used with formatting any constant arguments are inlined into the main string and then the parameters are reordered, i.e.:&nbsp; {}string(\"{0} {1} {2}\", \"a\", \"=\", a);{} becomes: {}string(\"a = {0}\", a);{} {} {}Constant strings are concatenated by the compiler: {}string_concat(\"the \", \"answer \", \"is \", string(a));{} becomes: {}string_concat(\"the answer is \", string(a));{} {} {}Constant string arguments are joined by the compiler: {}string_join(\" \", \"Hello\", \"World\", string(a), \"is\", \"the\", \"answer\");{} becomes: {}string_join(\" \", \"Hello World\", string(a), \"is the answer\" );{} {} {} ":"字符串：{0}{1} 与格式化一起使用时，任何常量参数都会内联到主字符串中，然后对参数重新排序，即：{2}string(\"{0}{1}{2}\", \"a\", \" =\", a);{} 变为：{}string(\"a ={0}\", a);{}{}{} 常量字符串由编译器连接：{}string_concat(\"the \", \"answer \" , \"is \", string(a));{} 变为：{}string_concat(\" 答案是 \", string(a));{}{}{} 常量字符串参数由编译器连接：{}string_join( \" \", \"Hello\", \"World\", string(a), \"is\", \"the\", \"answer\");{} 变为：{}string_join(\" \", \"Hello World\", string(a), \"就是答案 \");{}{}{}",
    "Struct variables are looked up using the hash value instead of the variable name if that name resolves to a constant value at compile time.&nbsp;For example, using this struct:&nbsp; {}a = {this: \"this\", that: \"that\"};{} the following variable lookups: {}b = a[$ \"this\"];{} // OR{} b = a.this{} will be replaced by the compiler by a lookup using the hash value, since it knows the variable name is {}\"this\"{}. However, the following lookup: {}var _varname = choose(\"this\", \"that\");{} b = a[$ _varname];{} cannot be replaced and the hash needs to be calculated at runtime, as the value of&nbsp;{}_varname{}&nbsp;depends on what the {}{}choose{}{}&nbsp;function returns. {}{}{}NOTE{}{}&nbsp;The above optimisations are also applied when you call the&nbsp;{}Struct Functions{}.{} ":"如果结构体变量在编译时解析为常量值，则使用哈希值而不是变量名称来查找结构体变量。例如，使用此结构体： {}a = {this: \"this\", that: \"that\"};{} 以下变量查找: {}b = a[$ \"this\"];{} // OR{} b = a.this{} 将被编译器通过使用哈希值的查找来替换，因为它知道变量名是{}\"this\"{}. 但是，以下查找: {}var _varname = choose(\"this\", \"that\");{} b = a[$ _varname];{} 无法替换，并且需要在运行时计算哈希值，因为 {}_varname{} 的值取决于 {}{}choose{}{} 函数返回的内容。 {}{}{}注意{}{}当您调用{}结构函数{}时，上述优化也会应用。{}",
    "The compiler performs certain optimisations automatically, and does this recursively:&nbsp;":"编译器自动执行某些优化，并递归地执行此操作：",
    "The following functions are optimised by the compiler, according to the rule for deterministic functions when it detects that the parameters are constant (i.e. they cannot change at runtime):&nbsp;":"当编译器检测到参数恒定 (即它们不能在运行时更改) 时，编译器会根据确定性函数的规则对以下函数进行优化：",
    "Using gml_pragma()":"使用 gml_pragma()",
    "You can also optimise how the compiler compiles (parts of) your game\u0027s code by providing it optimisations with the&nbsp;{}\"optimise\"{} (or {}\"optimize\"{}) pragma. These may apply to multiple targets or be specific to some build targets. Using them in the right places in your code can lead to great performance improvements in your game.":"您还可以通过为游戏代码提供 {}\"optimise\"{}( 或 {}\"optimize\"{}) 编译指示来优化编译器编译 (部分) 游戏代码的方式。这些可能适用于多个目标或特定于某些构建目标。在代码中正确的位置使用它们可以极大地提高游戏的性能。",
    "{}Compiler Optimisations{}":"{} 编译器优化 {}",
    "{}Deterministic{}&nbsp;functions (also known as pure functions) that are called with constant parameters are replaced with the return value of the function call. A deterministic function returns a known output for a given input; for every input value that you can pass the output value is known. For example,&nbsp;{}{}dcos{}{}&nbsp;is deterministic (i.e. {}dcos(0){} always returns 1, {}dcos(90){} always returns 0, etc.), while&nbsp;{}{}choose{}{}&nbsp;is not (i.e.&nbsp;{}choose(\"A\", \"B\", \"C\"){}&nbsp;can return any of the three parameters). {} {}{}Template Strings{}&nbsp;are replaced with a call to&nbsp;{}{}string{}{} and are also replaced according to the above rule. {}{}{}NOTE{}{}&nbsp;If you use the template literal string {}$\"Hello, I am {name}!\"{} then internally this becomes {}string(\"Hello, I am {0}!\", name){}. If {}name{} is a string literal (or a macro that maps to a string literal) then this would be optimised out completely and become a string literal.{} {} {} ":"使用常量参数调用的 {0} 确定性 {} 函数 (也称为纯函数) 将替换为函数调用的返回值。确定性函数针对给定输入返回已知输出 ; 对于每个可以传递的输入值，输出值都是已知的。例如，{}{}dcos{}{} 是确定性的 (即 {}dcos(0){} 始终返回 1，{}dcos(90){} 始终返回 0 等)，而 {}{}choose{}{} 不是 (即 {}choose(\"A\", \"B\", \"C\"){} 可以返回三个参数中的任何一个)。{}{}{} 模板字符串 {} 被替换为对 {}{}string{}{} 的调用，并且也根据上述规则进行替换。{}{}{} 注意 {}{} 如果您使用模板文字字符串 {}$\"Hello, I am{name}!\"{}，那么在内部这将变为 {}string(\"Hello, I am{0}! \"， 姓名 ){}。如果 {}name{} 是字符串文字 (或映射到字符串文字的宏)，那么它将完全优化并成为字符串文字。{}{}{}",
    "{}GameMaker{}&nbsp;will optimise parts of your game code when compiling (i.e. building) your game. Some optimisations are performed automatically, others can be turned on or off with a call to {}{}gml_pragma{}{}.":"{}GameMaker{} 将在编译 (即构建) 游戏时优化部分游戏代码。某些优化是自动执行的，其他优化可以通过调用 {}{}gml_pragma{}{} 来打开或关闭。",
    "{}{}{}NOTE{}{}&nbsp;The compiler will only optimise when the arguments are constants that it can evaluate.{}":"{}{}{} 注意{}{} 编译器仅当参数是可计算的常量时才会进行优化。{}"
}